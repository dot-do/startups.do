---
name: ResistWise Spray Planner
slug: resistwise-spray-planner-weed-control-planner-spray-window-scheduler-resistance-aware
domain: resistwise.ai
naics:
  primary: "111110"
  occupations: []
score:
  remote_on_laptop: 0.9
  model_capability: 0.85
  overall: 0.875
vmv:
  vision: "Zero herbicide resistance escapes through AI-driven, resistance-aware spray planning."
  mission: "Optimize weed control programs with localized resistance data, weather-aware scheduling, and compliance automation."
  purpose: "Protect yields while reducing herbicide costs and regulatory risk."
leanCanvas:
  problem:
    - "Rapidly evolving herbicide resistance (e.g., waterhemp, Palmer amaranth, marestail) varies by county/township; generic programs lead to escapes and costly resprays."
    - "Narrow, weather-dependent spray windows; wind/inversions and workload cause missed label cutoffs (e.g., dicamba) and drift incidents, leading to fines and neighbor disputes."
    - "Trait complexity (Enlist, XtendFlex, LibertyLink, conventional) plus label/tank-mix rules create decision overload; mistakes increase risk and cost."
    - "Input inflation and razor-thin margins; growers need to maintain control while reducing $/acre and passes."
    - "Scheduling and coordination across growers, agronomists, and applicators are manual (texts/calls/spreadsheets), causing delays and miscommunication."
    - "Limited measurement of outcomes; decisions rely on anecdotes rather than localized data and control probabilities."
  solution:
    - "Local resistance-aware program design: fuse county/township resistance data with field history to recommend pre- and post-emergence programs aligned with soybean trait (Enlist, XtendFlex, LibertyLink, conventional) and HRAC mode-of-action diversity."
    - "Label-compliant tank mix builder: rates, adjuvants, droplet size/nozzle guidance, buffers, PHI/REI, cutoff dates, endangered species checks; automatic compatibility checks."
    - "Spray window optimizer: 14-day rolling forecast with hyperlocal wind/inversion/temperature thresholds and weed growth-stage model; proposes primary and backup windows with confidence scores."
    - "Work planning and dispatch: sequences fields by priority, distance, and capacity; exports jobs to John Deere Operations Center, Raven, AgLeader; shares with custom applicators."
    - "ROI/risk comparisons: expected control probability, respray risk, and total program cost vs local benchmarks; supports what-if scenarios."
    - "Auto recordkeeping and audit trail: captures who/what/when/where, label references, weather at spray; generates regulator-ready reports."
  uniqueValueProp: "AI-driven, resistance-aware program design and spray-window scheduling that improves weed control consistency, lowers herbicide costs, and reduces drift/compliance risk—integrated with existing farm platforms and applicator workflows."
  unfairAdvantage: "Closed-loop dataset linking product programs, timing, hyperlocal weather, and observed outcomes across millions of acres—creating localized control and drift-risk models competitors without cross-retailer data cannot match—plus a fast-updating, codified label/compliance engine validated with university partners."
  customerSegments:
    - "Row-crop soybean growers managing 1,000–25,000 acres in the U.S. Corn Belt."
    - "Ag retailers/co-ops offering crop protection recommendations and custom application."
    - "Independent crop consultants/agronomists managing 20k–200k acres of client land."
    - "Custom applicators needing compliant, efficient work plans."
    - "Seed/chemical manufacturers' field teams (influencers/channel partners)."
    - "Insurers and ag lenders offering discounts for risk-mitigating practices (secondary)."
  channels:
    - "Retailer/co-op partnerships with a white-label option; revenue-share per managed acre (goal: 10–20 partners in Year 1)."
    - "90-day pilot framework: 5–10 growers per retailer (50k–100k acres). Success criteria: +15 percentage points on-time sprays, −15% resprays, ≥70% conversion to paid."
    - "Integrations and marketplace listings in John Deere Operations Center and Climate FieldView partner ecosystems to drive discovery and reduce switching costs."
    - "University extension collaborations (Iowa State, Purdue, Arkansas) for webinars, field days, and co-authored case studies; leverage state soybean checkoff support."
    - "Industry events (Commodity Classic, Farm Progress, InfoAg) and targeted digital campaigns in IL/IA/MN/IN/MO/NE/OH/SD/ND/KS/AR; retarget agronomist audiences on LinkedIn."
    - "Referral incentives for agronomists/applicators (e.g., $0.10/acre credit for 12 months on referred acres)."
  revenueStreams:
    - "Per-acre seasonal subscription for soybeans: $1.50–$3.00/acre (volume-tiered), includes program design, scheduling, and recordkeeping."
    - "Enterprise licenses for retailers/co-ops: $15,000–$250,000/year based on managed acres and features (SSO, analytics, API, training)."
    - "Professional services: custom program libraries, data migration, integration setup and training ($5,000–$50,000)."
    - "Premium compliance/audit add-on: $0.25/acre for enhanced documentation bundles and legal-defensibility reports."
    - "Aggregated, anonymized insights licensing to manufacturers/insurers (grower opt-in, privacy-protecting)."
    - "Partner margin on rapid resistance testing kits and sample processing (optional add-on)."
  costStructure:
    - "Data acquisition: weather APIs $0.05–$0.12/acre/season; satellite/elevation $0.03/acre; label database licensing (Agrian/CPDA)."
    - "Cloud compute/storage and alerting: $0.20–$0.40/acre/season; architecture optimized for event-driven notifications."
    - "Agronomy/R&D team (weed science, label/compliance): ~$1.2M/year at scale."
    - "Software engineering and MLOps: ~$2.0M/year; mobile + integrations."
    - "Sales/customer success: 20–35% of revenue early stage (pilots, onboarding, training)."
    - "Insurance/legal (E&O, product liability) and compliance monitoring: ~$300k/year."
    - "Field trials/validations: $250–$500/site; 50–100 sites/year to ground-truth control and drift risk models."
    - "Marketing/events/content: $250k–$500k/year."
    - "Target COGS: ≤$0.75/acre; gross margin ≥70% by Year 3."
  keyMetrics:
    - "Acres subscribed and active (MAA): 500k Year 1, 1.5M Year 2, 2.5M+ Year 3."
    - "On-time spray rate: +15–25 percentage points vs prior baseline per customer."
    - "Respray rate reduction: 15–25% reduction in acres requiring a second pass due to escapes/drift."
    - "Herbicide program $/acre: maintain or reduce by $5–$12/acre while achieving equal or higher control."
    - "Drift/compliance incident rate: <0.5% of applications; −50% YoY in reported issues at participating retailers."
    - "Weed control outcome score at 14 and 28 DAA (0–100): average ≥85 across customers."
    - "Alert effectiveness: ≥70% acknowledgment; ≥60% of jobs executed within recommended windows."
    - "Renewal and expansion: acre renewal ≥85%; net revenue retention ≥115%."
    - "Sales efficiency: LTV:CAC ≥4:1; CAC payback ≤12 months."
    - "Integration utilization: ≥60% of jobs exported to equipment/applicator systems."
okrs:
  - objective: "Achieve superior weed control outcomes"
    keyResults:
      - metric: "Control efficacy"
        target: "≥85% average score at 28 DAA"
      - metric: "Respray rate"
        target: "≤15% reduction vs baseline"
  - objective: "Optimize spray timing and compliance"
    keyResults:
      - metric: "On-time spray rate"
        target: "+20 percentage points vs baseline"
      - metric: "Drift incidents"
        target: "<0.5% of applications"
  - objective: "Scale platform adoption"
    keyResults:
      - metric: "Active acres"
        target: "1.5M acres by Year 2"
      - metric: "Integration usage"
        target: "≥60% jobs exported to equipment"
storyBrand:
  character: "Soybean growers and agronomists managing large acreages who need consistent weed control while managing costs and compliance risk."
  problem: "External: Herbicide resistance spreads faster than programs adapt. Internal: Complex label rules and narrow spray windows create decision paralysis. Philosophical: Weed control should be proactive and data-driven, not reactive guesswork."
  guide: "We understand the complexity of modern herbicide resistance and regulatory compliance. Our AI continuously analyzes local resistance patterns, weather windows, and label requirements to deliver precise, compliant spray programs and optimal timing."
  plan: "1) Upload field boundaries and trait information. 2) We generate resistance-aware programs and monitor spray windows. 3) Receive alerts for optimal timing, execute with confidence, and track outcomes. Simple per-acre pricing with equipment integrations."
  callToAction: "Start a 90-day pilot on your operation or book a demo. Upload your fields today and receive your first resistance-aware program within 24 hours."
  success: "Consistent weed control, reduced herbicide costs, fewer resprays, zero compliance incidents, and data-driven decisions that protect yield and profitability."
  failure: "Without it: resistance escapes spread, costly resprays, drift incidents and fines, missed application windows, and another season of reactive herbicide management."
branding:
  nameIdeas: ["ResistWise", "SpraySync", "WeedGuard AI"]
  colors: { primary: "#2D5016", secondary: "#8FBC8F" }
  fonts: { heading: "Inter", body: "Inter" }
  logoPrompt: "Modern shield with spray pattern and resistance symbol"
pricing:
  plans:
    - id: grower
      name: "Grower"
      price: 2.00
      interval: "per acre/season"
      features: ["Resistance-aware programs", "Spray window alerts", "Basic recordkeeping"]
    - id: professional
      name: "Professional"
      price: 3.50
      interval: "per acre/season"
      features: ["All Grower features", "Equipment integrations", "Advanced analytics", "API access"]
    - id: enterprise
      name: "Enterprise"
      price: "Custom"
      interval: "annual"
      features: ["White-label option", "Custom integrations", "Dedicated support", "Training programs"]
  stripe:
    productId: ""
    priceIds: {}
prd:
  summary: "Resistance-aware herbicide program design → spray window optimization → compliance automation → outcome tracking"
  scopeMVP:
    - "Field boundary upload and trait selection"
    - "Local resistance database integration"
    - "Program recommendation engine"
    - "Weather-based spray window alerts"
    - "Basic compliance checking"
    - "Application recordkeeping"
experiments:
  - hypothesis: "Resistance-aware programs reduce respray rates by 20%"
    metric: "Respray rate"
    variantCount: 2
  - hypothesis: "Weather-optimized timing improves on-time spray rate by 25%"
    metric: "On-time spray percentage"
    variantCount: 3
variants:
  - name: "Simplified grower interface"
    changes: ["Reduced complexity", "Mobile-first design"]
  - name: "Retailer white-label"
    changes: ["Co-branded interface", "Retailer-specific programs"]
---

# ResistWise Spray Planner - Business Process Functions

## Customer Acquisition Workflows

```typescript
interface Lead {
  id: string;
  name: string;
  operation: {
    acres: number;
    location: { county: string; state: string };
    crops: string[];
    currentPrograms?: string[];
  };
  contactInfo: {
    email: string;
    phone: string;
    preferredContact: 'email' | 'phone' | 'text';
  };
  source: 'referral' | 'event' | 'digital' | 'partner';
  urgency: 'high' | 'medium' | 'low';
}

interface QualifiedLead extends Lead {
  qualificationScore: number;
  painPoints: string[];
  decisionTimeline: string;
  budget: { min: number; max: number };
  currentSolutions: string[];
}

interface Customer {
  id: string;
  lead: QualifiedLead;
  contract: Contract;
  onboardingStatus: 'pending' | 'in-progress' | 'complete';
  fields: Field[];
  subscription: Subscription;
}

export async function acquireCustomer(lead: Lead): Promise<Customer> {
  try {
    const qualifiedLead = await qualifyLead(lead);
    const proposal = await generateProposal(qualifiedLead);
    const contract = await negotiateContract(proposal);
    const customer = await onboardCustomer(contract);
    
    await trackConversion(lead.source, customer);
    return customer;
  } catch (error) {
    await logAcquisitionFailure(lead, error);
    throw error;
  }
}

export async function qualifyLead(lead: Lead): Promise<QualifiedLead> {
  const resistanceData = await fetchLocalResistanceData(lead.operation.location);
  const competitorAnalysis = await analyzeCurrentPrograms(lead.operation.currentPrograms);
  
  const qualificationScore = calculateQualificationScore({
    acres: lead.operation.acres,
    resistancePressure: resistanceData.severity,
    competitorGaps: competitorAnalysis.gaps,
    urgency: lead.urgency
  });

  if (qualificationScore < 70) {
    throw new Error('Lead does not meet qualification threshold');
  }

  return {
    ...lead,
    qualificationScore,
    painPoints: identifyPainPoints(resistanceData, competitorAnalysis),
    decisionTimeline: estimateDecisionTimeline(lead.urgency, resistanceData.season),
    budget: estimateBudget(lead.operation.acres),
    currentSolutions: competitorAnalysis.solutions
  };
}

export async function generateProposal(qualifiedLead: QualifiedLead): Promise<Proposal> {
  const resistanceProfile = await buildResistanceProfile(qualifiedLead.operation.location);
  const costSavingsAnalysis = await calculatePotentialSavings(qualifiedLead);
  const riskReduction = await assessRiskReduction(qualifiedLead);
  
  return {
    customerId: qualifiedLead.id,
    programs: await designCustomPrograms(resistanceProfile, qualifiedLead.operation),
    pricing: calculateCustomPricing(qualifiedLead.operation.acres),
    roi: {
      costSavings: costSavingsAnalysis,
      riskReduction,
      paybackPeriod: calculatePaybackPeriod(costSavingsAnalysis, qualifiedLead.budget)
    },
    timeline: generateImplementationTimeline(),
    terms: generateContractTerms(qualifiedLead)
  };
}
```

## Product Development Processes

```typescript
interface ResistanceData {
  location: { county: string; state: string };
  species: string[];
  mechanisms: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
  trends: { year: number; severity: string }[];
  sources: string[];
}

interface SprayProgram {
  id: string;
  name: string;
  trait: 'Enlist' | 'XtendFlex' | 'LibertyLink' | 'Conventional';
  applications: Application[];
  totalCost: number;
  expectedEfficacy: number;
  resistanceRisk: number;
}

interface Application {
  timing: 'PRE' | 'POST1' | 'POST2';
  products: Product[];
  rates: { [productId: string]: number };
  adjuvants: Adjuvant[];
  restrictions: LabelRestriction[];
}

export async function developResistanceAwareProgram(
  location: { county: string; state: string },
  trait: string,
  fieldHistory: FieldHistory[]
): Promise<SprayProgram> {
  const resistanceData = await fetchResistanceData(location);
  const labelDatabase = await loadLabelDatabase();
  const efficacyModels = await loadEfficacyModels();
  
  const baseProgram = await generateBaseProgram(trait, resistanceData);
  const optimizedProgram = await optimizeForResistance(baseProgram, resistanceData, fieldHistory);
  const validatedProgram = await validateCompliance(optimizedProgram, labelDatabase);
  
  return await finalizeProgram(validatedProgram, efficacyModels);
}

export async function updateResistanceDatabase(
  newData: ResistanceData[],
  validationResults: ValidationResult[]
): Promise<void> {
  const processedData = await processResistanceData(newData);
  const validatedData = await validateResistanceData(processedData, validationResults);
  
  await updateDatabase(validatedData);
  await recalibrateModels(validatedData);
  await notifyAffectedCustomers(validatedData);
}

export async function enhanceLabelCompliance(
  products: Product[],
  regulations: Regulation[]
): Promise<ComplianceEngine> {
  const labelParser = await initializeLabelParser();
  const ruleEngine = await buildRuleEngine(regulations);
  
  for (const product of products) {
    const labelData = await labelParser.parse(product.label);
    await ruleEngine.addRules(labelData);
  }
  
  return {
    checkCompliance: async (application: Application) => {
      return await ruleEngine.validate(application);
    },
    getRestrictions: async (product: Product, conditions: WeatherConditions) => {
      return await ruleEngine.getRestrictions(product, conditions);
    },
    updateRules: async (newRegulations: Regulation[]) => {
      await ruleEngine.updateRules(newRegulations);
    }
  };
}
```

## Revenue Generation Flows

```typescript
interface Subscription {
  id: string;
  customerId: string;
  plan: 'grower' | 'professional' | 'enterprise';
  acres: number;
  pricePerAcre: number;
  billingCycle: 'seasonal' | 'annual';
  status: 'active' | 'suspended' | 'cancelled';
  features: string[];
  renewalDate: Date;
}

interface Usage {
  customerId: string;
  period: { start: Date; end: Date };
  acres: number;
  programs: number;
  alerts: number;
  integrations: number;
  apiCalls: number;
}

export async function processSeasonalBilling(
  subscriptions: Subscription[]
): Promise<BillingResult[]> {
  const results: BillingResult[] = [];
  
  for (const subscription of subscriptions) {
    try {
      const usage = await calculateUsage(subscription.customerId);
      const invoice = await generateInvoice(subscription, usage);
      const payment = await processPayment(invoice);
      
      results.push({
        subscriptionId: subscription.id,
        status: 'success',
        amount: payment.amount,
        invoiceId: invoice.id
      });
      
      await updateSubscriptionStatus(subscription.id, 'active');
    } catch (error) {
      results.push({
        subscriptionId: subscription.id,
        status: 'failed',
        error: error.message
      });
      
      await handlePaymentFailure(subscription, error);
    }
  }
  
  return results;
}

export async function calculateRevenue(
  period: { start: Date; end: Date }
): Promise<RevenueReport> {
  const subscriptions = await getActiveSubscriptions(period);
  const usage = await getUsageData(period);
  const addOns = await getAddOnRevenue(period);
  
  const subscriptionRevenue = subscriptions.reduce((total, sub) => {
    return total + (sub.acres * sub.pricePerAcre);
  }, 0);
  
  const usageRevenue = calculateUsageRevenue(usage);
  const addOnRevenue = addOns.reduce((total, addon) => total + addon.amount, 0);
  
  return {
    period,
    subscriptionRevenue,
    usageRevenue,
    addOnRevenue,
    totalRevenue: subscriptionRevenue + usageRevenue + addOnRevenue,
    metrics: {
      averageRevenuePerAcre: subscriptionRevenue / getTotalAcres(subscriptions),
      customerCount: subscriptions.length,
      churnRate: await calculateChurnRate(period)
    }
  };
}

export async function optimizePricing(
  marketData: MarketData,
  competitorPricing: CompetitorPricing[],
  customerFeedback: CustomerFeedback[]
): Promise<PricingStrategy> {
  const elasticityAnalysis = await analyzePriceElasticity(marketData);
  const competitivePosition = await analyzeCompetitivePosition(competitorPricing);
  const valuePerception = await analyzeValuePerception(customerFeedback);
  
  const optimalPricing = await calculateOptimalPricing({
    elasticity: elasticityAnalysis,
    competition: competitivePosition,
    value: valuePerception
  });
  
  return {
    recommendedPrices: optimalPricing,
    rationale: generatePricingRationale(elasticityAnalysis, competitivePosition),
    testingPlan: designPricingTests(optimalPricing),
    implementation: createImplementationPlan(optimalPricing)
  };
}
```

## Operational Procedures

```typescript
interface SprayWindow {
  id: string;
  fieldId: string;
  startTime: Date;
  endTime: Date;
  confidence: number;
  conditions: WeatherConditions;
  restrictions: string[];
  priority: 'high' | 'medium' | 'low';
}

interface WorkOrder {
  id: string;
  customerId: string;
  fieldId: string;
  application: Application;
  sprayWindow: SprayWindow;
  assignedTo?: string;
  status: 'pending' | 'assigned' | 'in-progress' | 'completed' | 'cancelled';
  equipment: Equipment[];
}

export async function optimizeSprayWindows(
  fields: Field[],
  forecast: WeatherForecast,
  constraints: OperationalConstraints
): Promise<SprayWindow[]> {
  const windows: SprayWindow[] = [];
  
  for (const field of fields) {
    const fieldWindows = await calculateFieldWindows(field, forecast);
    const filteredWindows = await applyConstraints(fieldWindows, constraints);
    const scoredWindows = await scoreWindows(filteredWindows, field);
    
    windows.push(...scoredWindows);
  }
  
  return await prioritizeWindows(windows);
}

export async function scheduleApplications(
  sprayWindows: SprayWindow[],
  applicators: Applicator[],
  equipment: Equipment[]
): Promise<WorkOrder[]> {
  const workOrders: WorkOrder[] = [];
  const schedule = await initializeSchedule();
  
  for (const window of sprayWindows) {
    const availableApplicators = await findAvailableApplicators(
      applicators,
      window.startTime,
      window.endTime
    );
    
    const suitableEquipment = await findSuitableEquipment(
      equipment,
      window.fieldId,
      window.application
    );
    
    if (availableApplicators.length > 0 && suitableEquipment.length > 0) {
      const workOrder = await createWorkOrder(
        window,
        availableApplicators[0],
        suitableEquipment[0]
      );
      
      workOrders.push(workOrder);
      await schedule.addWorkOrder(workOrder);
    } else {
      await handleSchedulingConflict(window, availableApplicators, suitableEquipment);
    }
  }
  
  return await optimizeSchedule(workOrders);
}

export async function monitorApplications(
  workOrders: WorkOrder[]
): Promise<ApplicationReport[]> {
  const reports: ApplicationReport[] = [];
  
  for (const workOrder of workOrders) {
    const telemetry = await collectTelemetryData(workOrder);
    const weatherData = await getActualWeather(workOrder.sprayWindow);
    const complianceCheck = await verifyCompliance(workOrder, weatherData);
    
    const report = await generateApplicationReport({
      workOrder,
      telemetry,
      weather: weatherData,
      compliance: complianceCheck
    });
    
    reports.push(report);
    
    if (!complianceCheck.passed) {
      await handleComplianceViolation(workOrder, complianceCheck);
    }
  }
  
  return reports;
}
```

## Decision-Making Workflows

```typescript
interface DecisionContext {
  customerId: string;
  fieldId: string;
  currentConditions: FieldConditions;
  forecast: WeatherForecast;
  resistanceProfile: ResistanceData;
  constraints: OperationalConstraints;
  objectives: CustomerObjectives;
}

interface DecisionRecommendation {
  action: 'spray' | 'wait' | 'modify_program' | 'scout';
  confidence: number;
  rationale: string[];
  alternatives: Alternative[];
  risks: Risk[];
  timeline: Date;
}

export async function makeSprayDecision(
  context: DecisionContext
): Promise<DecisionRecommendation> {
  const weatherAnalysis = await analyzeWeatherConditions(context.forecast);
  const resistanceRisk = await assessResistanceRisk(context.resistanceProfile);
  const operationalFeasibility = await checkOperationalFeasibility(context.constraints);
  const economicAnalysis = await analyzeEconomics(context);
  
  const decisionMatrix = await buildDecisionMatrix({
    weather: weatherAnalysis,
    resistance: resistanceRisk,
    operations: operationalFeasibility,
    economics: economicAnalysis
  });
  
  const recommendation = await generateRecommendation(decisionMatrix, context.objectives);
  
  return await validateRecommendation(recommendation, context);
}

export async function evaluateProgramPerformance(
  applications: CompletedApplication[],
  outcomes: FieldOutcome[]
): Promise<PerformanceEvaluation> {
  const efficacyAnalysis = await analyzeEfficacy(applications, outcomes);
  const costAnalysis = await analyzeCosts(applications);
  const resistanceImpact = await assessResistanceImpact(applications, outcomes);
  const complianceRecord = await evaluateCompliance(applications);
  
  const benchmarks = await loadBenchmarks();
  const comparison = await compareToBenchmarks(efficacyAnalysis, benchmarks);
  
  const recommendations = await generateImprovementRecommendations({
    efficacy: efficacyAnalysis,
    costs: costAnalysis,
    resistance: resistanceImpact,
    compliance: complianceRecord,
    benchmarks: comparison
  });
  
  return {
    overall: calculateOverallScore(efficacyAnalysis, costAnalysis, complianceRecord),
    efficacy: efficacyAnalysis,
    economics: costAnalysis,
    resistance: resistanceImpact,
    compliance: complianceRecord,
    recommendations,
    nextActions: prioritizeNextActions(recommendations)
  };
}

export async function adaptToResistanceEvolution(
  newResistanceData: ResistanceData[],
  affectedCustomers: Customer[]
): Promise<AdaptationPlan> {
  const impactAnalysis = await analyzeResistanceImpact(newResistanceData);
  const programAdjustments = await calculateProgramAdjustments(impactAnalysis);
  
  const adaptationPlan: AdaptationPlan = {
    urgency: determineUrgency(impactAnalysis),
    affectedCustomers: affectedCustomers.length,
    programChanges: programAdjustments,
    timeline: generateAdaptationTimeline(impactAnalysis.urgency),
    communicationPlan: createCommunicationPlan(affectedCustomers, impactAnalysis)
  };
  
  for (const customer of affectedCustomers) {
    await updateCustomerPrograms(customer, programAdjustments);
    await notifyCustomer(customer, adaptationPlan);
  }
  
  return adaptationPlan;
}
```

export default function Page() {
  return (
    <>
      <Hero
        title="AI-Driven Weed Control That Adapts to Resistance"
        subtitle="Resistance-aware spray programs, weather-optimized timing, and compliance automation—integrated with your existing farm platforms."
        ctaText="Start 90-Day Pilot"
        ctaHref="/pilot"
      />
      <Problem bullets={[
        "Herbicide resistance spreads faster than programs adapt",
        "Narrow spray windows and complex label rules create decision paralysis",
        "Manual scheduling leads to missed applications and drift incidents",
        "Generic programs result in escapes and costly resprays"
      ]} />
      <Solution bullets={[
        "Local resistance data fused with field history for precise programs",
        "Weather-aware spray window optimization with confidence scores",
        "Automated compliance checking and label validation",
        "Equipment integrations and applicator coordination"
      ]} />
      <Features items={[
        "Resistance-aware program design",
        "Spray window optimization",
        "Label compliance automation",
        "Equipment integrations",
        "Outcome tracking and analytics"
      ]} />
      <Steps steps={[
        "Upload field boundaries and traits",
        "Receive resistance-aware programs",
        "Get spray window alerts",
        "Execute with confidence",
        "Track outcomes and adapt"
      ]} />
    </>
  )
}
