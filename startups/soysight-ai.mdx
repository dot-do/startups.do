---
name: SoySight AI
slug: soysight-ai
naics:
  primary: '111110'
  occupations: []
leanCanvas:
  problem:
    - Yield variability across zones of the same field (often 20–40 bu/ac swing) is poorly predicted with generic tools, leading to over/under-application of seed, P, K, and fungicide.
    - Early disease pressure (SDS, white mold, frogeye leaf spot, brown stem rot, SCN) is detected too late; losses of 5–20 bu/ac are common in high-pressure years.
    - Herbicide resistance (waterhemp, Palmer amaranth, marestail) drives over-application and tank-mix costs; mis-IDs and timing errors reduce control and increase spend by $10–25/ac.
    - Fragmented data (equipment, imagery, scouting notes, soil tests, weather, grain settlement) makes in-season decisions slow; growers spend 3–5 hours/week on data wrangling during peak season.
    - Inefficient variable-rate prescriptions: many growers either don't use VR or use generic templates, leaving 5–10% seed and 10–20% input savings unrealized.
    - Labor constraints and limited agronomist bandwidth lead to missed scouting windows; drone/imagery data goes underutilized without automated insights.
    - Increasing demand for sustainability and carbon reporting creates administrative burden; growers lack easy MRV to access premiums or comply with programs.
    - Price volatility and basis risk are managed manually; few tools link agronomic outlook (yield probability) to marketing/hedging decisions.
  solution:
    - Soybean-specific ML models for yield probability, disease risk (SDS, white mold, frogeye), and weed species detection with zone-level prescriptions.
    - Automated variable-rate seeding and P/K/lime prescriptions using multi-year yield maps, soil grids, elevation, and imagery-derived vigor indices.
    - In-season fungicide timing and product-selection advisor, integrating disease pressure forecasts, canopy conditions, and economics.
    - Edge AI for sprayers and planters: on-device weed/disease detection to reduce over-application; supports ISOBUS/ADAPT and JD, CNH, AGCO ecosystems.
    - Drone/satellite scouting automation with prioritization maps and task lists; mobile app for quick ground-truthing and note capture.
    - Sustainability and carbon MRV: per-field kg CO2e/bu estimates, practice tracking, and program-ready reports.
    - Grain marketing assist: links field-level yield distributions to hedge suggestions and alerts (advisory only; integrate with partner platforms for execution).
    - Seamless integrations to John Deere Operations Center, Climate FieldView, Ag Leader SMS, soil labs, and weather APIs for frictionless onboarding.
  uniqueValueProp: AI-native soybean platform that turns raw field data into precise, in-season actions. Deliver 3–7 bu/ac yield uplift and 10–20% input savings with a season-long ROI guarantee (3x subscription or refund), integrated directly with existing equipment and workflows.
  unfairAdvantage: A soybean-specialized AI stack trained on multi-state, multi-year labeled datasets with on-machine inference and closed-loop validation from retailer-run trials; coupled with distribution MOUs with key co-ops, and a season-long ROI guarantee that incumbents do not match.
  customerSegments:
    - Primary: US soybean growers managing 1,000–25,000+ acres, especially in IA, IL, MN, IN, NE, SD, ND, OH, MO.
    - Agronomy retailers and co-ops (e.g., Nutrien, CHS, Growmark) seeking differentiated digital services and stickier customer relationships.
    - Independent crop consultants/CCAs who want scalable, AI-driven scouting and prescription tools.
    - OEMs and precision ag providers (John Deere, CNH, AGCO; Trimble; Raven) needing on-device AI advisories and prescription generation.
    - Seed and chemical companies seeking plot analytics and product placement optimization in soybean-dominant geographies.
    - Carbon/sustainability program operators (Truterra, Indigo, Nori) needing low-cost MRV for row crops.
  channels:
    - Direct sales to large growers (≥5,000 acres) with enterprise pricing and dedicated agronomy support.
    - Retailers/co-ops as value-added service: white-label or co-branded with training for agronomists; revenue share per acre.
    - OEM integrations and app marketplaces (JD Operations Center, CNH, AGCO) to access existing equipment user bases.
    - Independent CCA network referrals with per-acre commissions and enablement kits (demo fields, trial playbooks).
    - State soybean associations, extension field days, winter agronomy meetings, and plot trials to build trust and local proof.
    - Digital demand gen: webinars, yield contest case studies, ROI calculators, and in-season alert teasers; retarget via ag media outlets.
    - Pilot programs with seed/chem reps bundling trials on side-by-side plots; discount for first 2,000 acres per grower.
    - Geospatial partners (Planet, Sentinel resellers, drone service providers) co-selling imagery + insights bundles.
  revenueStreams:
    - Per-acre subscription: Standard $3/ac/year (imagery + analytics + basic prescriptions); Pro $6/ac/year (disease advisor, VR seeding, edge AI support).
    - Add-ons: In-season drone AI scouting $2/ac/pass; fungicide timing module $1/ac; carbon MRV $1/ac; harvest optimization $0.50/ac.
    - Per-operation detection fee for edge-enabled sprayers: $0.20/ac per pass; volume discounts for >100k pass acres.
    - Enterprise/retailer licensing: $50k–$500k/year depending on acreage tiers, users, and white-label requirements.
    - Success fee: 10% of verified input savings above baseline for VR prescriptions and precision spraying.
    - Data products (aggregated, anonymized): plot analytics and benchmarking for seed/chem R&D; $100k–$1M/yr contracts (with strict privacy controls).
    - Professional services: on-farm onboarding, custom model tuning, and API integrations; $150–$250/hr or per-project SOW.
    - Hardware margin (optional) on edge kits or camera retrofits when bundled with Pro (target 20–30% gross margin).
  costStructure:
    - COGS per managed acre: cloud compute and storage $0.15–$0.30; imagery/licensing $0.15–$0.50; model inference $0.05–$0.15; support $0.10–$0.20.
    - R&D: ML engineers, agronomists, data engineers; $3–5M/year in first 2 years for model development and field validation.
    - Sales and marketing: field reps, demo plots, travel, events, channel commissions (10–20% of ACV).
    - Field trials and data labeling: $500–$1,000 per trial location per season; multi-state protocol budget $500k–$1M/year.
    - Partnership and integration costs: OEM certification fees, marketplace rev share (5–15%), integration engineering.
    - General and administrative: compliance, data privacy, legal for data-sharing agreements; E&O insurance for agronomic recommendations.
    - Edge hardware program (optional): camera kits and compute modules for pilot fleets; $1,000–$2,500 per machine (capex or pass-through).
  keyMetrics:
    - Acres under management: Y1 500k, Y2 2M, Y3 5M; mix ≥50% Pro by Y3.
    - ARR per acre: blended $4.50/ac by Y2; net revenue retention ≥115%.
    - Model performance: disease detection precision/recall ≥0.85; yield RMSE ≤5 bu/ac by R3; weed species classification accuracy ≥90%.
    - Agronomic outcomes: seed savings 5–10%; P/K savings 10–20%; yield uplift 3–7 bu/ac in high-pressure zones; chemical savings $8–20/ac.
    - Payback and ROI: grower-level ROI ≥3x subscription; CAC payback ≤9 months; sales cycle ≤120 days for >5k-acre prospects.
    - Adoption and engagement: ≥70% of fields with active VR prescriptions; ≥2 in-season recommendations executed per field; weekly active users ≥60% in season.
    - Churn: gross logo churn ≤8% annually; reason-coded save workflows with ≥30% win-back on at-risk accounts.
    - Data coverage and reliability: ≥95% of acres with successful data ingestion; ≥99.5% API uptime during season; <24h turnaround for support tickets.
---

# SoySight AI

AI-native soybean platform that turns raw field data into precise, in-season actions.

## Business Process Functions

### Core Types

```typescript
interface Lead {
  id: string;
  growerName: string;
  farmName: string;
  acres: number;
  location: {
    state: string;
    county: string;
    coordinates: [number, number];
  };
  contactInfo: {
    email: string;
    phone: string;
  };
  currentTools: string[];
  painPoints: string[];
  source: 'direct' | 'referral' | 'event' | 'digital' | 'partner';
  createdAt: Date;
}

interface Customer {
  id: string;
  growerInfo: Lead;
  subscription: {
    tier: 'standard' | 'pro';
    pricePerAcre: number;
    totalAcres: number;
    annualValue: number;
    startDate: Date;
    renewalDate: Date;
  };
  fields: Field[];
  integrations: Integration[];
  onboardingStatus: 'pending' | 'in-progress' | 'complete';
  healthScore: number;
}

interface Field {
  id: string;
  name: string;
  acres: number;
  boundaries: GeoJSON;
  soilData: SoilAnalysis;
  plantingDate: Date;
  maturityGroup: string;
  historicalYield: YieldData[];
}

interface Prescription {
  id: string;
  fieldId: string;
  type: 'seeding' | 'fertilizer' | 'fungicide' | 'herbicide';
  zones: PrescriptionZone[];
  recommendations: Recommendation[];
  status: 'draft' | 'approved' | 'applied';
  createdAt: Date;
}

interface Alert {
  id: string;
  fieldId: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  type: 'disease' | 'pest' | 'nutrient' | 'weather' | 'weed';
  description: string;
  actionRequired: boolean;
  estimatedLoss: number;
  createdAt: Date;
}
```

### Customer Acquisition Workflows

```typescript
export async function acquireCustomer(lead: Lead): Promise<Customer> {
  try {
    const qualifiedLead = await qualifyLead(lead);
    const proposal = await generateProposal(qualifiedLead);
    const contract = await negotiateContract(proposal);
    const customer = await onboardCustomer(contract);
    
    await trackConversion(lead.source, customer.subscription.annualValue);
    return customer;
  } catch (error) {
    await logAcquisitionError(lead.id, error);
    throw new Error(`Customer acquisition failed: ${error.message}`);
  }
}

export async function qualifyLead(lead: Lead): Promise<Lead> {
  if (lead.acres < 1000) {
    throw new Error('Lead does not meet minimum acreage requirement');
  }
  
  const soybeanAcres = await estimateSoybeanAcres(lead.location);
  if (soybeanAcres < lead.acres * 0.3) {
    throw new Error('Insufficient soybean acreage for target market');
  }
  
  const competitorAnalysis = await analyzeCompetitorPresence(lead.location);
  const fitScore = calculateFitScore(lead, competitorAnalysis);
  
  return {
    ...lead,
    fitScore,
    qualificationDate: new Date()
  };
}

export async function generateProposal(lead: Lead): Promise<Proposal> {
  const yieldPotential = await calculateYieldUpliftPotential(lead.location, lead.acres);
  const inputSavings = await estimateInputSavings(lead.acres);
  const roiProjection = calculateROI(yieldPotential, inputSavings, lead.acres);
  
  const pricing = determinePricing(lead.acres, lead.location.state);
  
  return {
    leadId: lead.id,
    yieldUplift: yieldPotential,
    inputSavings,
    roiProjection,
    pricing,
    guaranteedROI: Math.max(roiProjection * 0.8, 3.0),
    validUntil: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
  };
}

export async function negotiateContract(proposal: Proposal): Promise<Contract> {
  const terms = await generateContractTerms(proposal);
  const approvedTerms = await reviewAndApproveTerms(terms);
  
  return {
    proposalId: proposal.id,
    terms: approvedTerms,
    roiGuarantee: proposal.guaranteedROI,
    signedAt: new Date(),
    effectiveDate: new Date(),
    expirationDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000)
  };
}

export async function onboardCustomer(contract: Contract): Promise<Customer> {
  const customer = await createCustomerRecord(contract);
  
  await setupFieldBoundaries(customer);
  await configureIntegrations(customer);
  await initializeBaselines(customer);
  await scheduleTraining(customer);
  
  customer.onboardingStatus = 'complete';
  await updateCustomerRecord(customer);
  
  return customer;
}
```

### Product Development Processes

```typescript
export async function developMLModel(modelType: 'yield' | 'disease' | 'weed'): Promise<MLModel> {
  try {
    const trainingData = await collectTrainingData(modelType);
    const processedData = await preprocessData(trainingData);
    const model = await trainModel(processedData, modelType);
    const validatedModel = await validateModel(model, modelType);
    
    await deployModel(validatedModel);
    return validatedModel;
  } catch (error) {
    await logDevelopmentError(modelType, error);
    throw new Error(`Model development failed: ${error.message}`);
  }
}

export async function collectTrainingData(modelType: string): Promise<TrainingDataset> {
  const fieldTrials = await getFieldTrialData(modelType);
  const satelliteImagery = await getSatelliteImagery(fieldTrials.locations);
  const weatherData = await getWeatherData(fieldTrials.locations, fieldTrials.timeRange);
  const soilData = await getSoilData(fieldTrials.locations);
  
  return {
    trials: fieldTrials,
    imagery: satelliteImagery,
    weather: weatherData,
    soil: soilData,
    labels: await generateLabels(fieldTrials, modelType)
  };
}

export async function validateModel(model: MLModel, modelType: string): Promise<MLModel> {
  const testData = await getTestDataset(modelType);
  const predictions = await runInference(model, testData);
  const metrics = calculateMetrics(predictions, testData.labels);
  
  const thresholds = {
    yield: { rmse: 5.0, r2: 0.85 },
    disease: { precision: 0.85, recall: 0.85 },
    weed: { accuracy: 0.90 }
  };
  
  if (!meetsThreshold(metrics, thresholds[modelType])) {
    throw new Error(`Model validation failed: ${JSON.stringify(metrics)}`);
  }
  
  model.validationMetrics = metrics;
  model.validatedAt = new Date();
  return model;
}

export async function releaseFeature(feature: Feature): Promise<void> {
  await runQualityAssurance(feature);
  await performSecurityReview(feature);
  await updateDocumentation(feature);
  
  const rolloutPlan = await createRolloutPlan(feature);
  await executeRollout(rolloutPlan);
  
  await monitorFeaturePerformance(feature);
}
```

### Revenue Generation Flows

```typescript
export async function processSubscriptionRenewal(customer: Customer): Promise<RenewalResult> {
  try {
    const healthScore = await calculateCustomerHealth(customer);
    const usageMetrics = await getUsageMetrics(customer.id);
    const roiActual = await calculateActualROI(customer);
    
    if (healthScore < 70 || roiActual < 2.0) {
      return await handleAtRiskRenewal(customer, healthScore, roiActual);
    }
    
    const renewalOffer = await generateRenewalOffer(customer, usageMetrics);
    const renewedContract = await processRenewal(renewalOffer);
    
    await updateCustomerSubscription(customer, renewedContract);
    return { status: 'renewed', contract: renewedContract };
  } catch (error) {
    await logRenewalError(customer.id, error);
    throw new Error(`Renewal processing failed: ${error.message}`);
  }
}

export async function generateVariableRatePrescription(field: Field): Promise<Prescription> {
  const soilAnalysis = await analyzeSoilVariability(field);
  const yieldHistory = await getYieldHistory(field);
  const satelliteData = await getCurrentSatelliteData(field);
  
  const zones = await createManagementZones(soilAnalysis, yieldHistory, satelliteData);
  const recommendations = await generateZoneRecommendations(zones);
  
  const prescription: Prescription = {
    id: generateId(),
    fieldId: field.id,
    type: 'seeding',
    zones,
    recommendations,
    status: 'draft',
    createdAt: new Date()
  };
  
  await validatePrescription(prescription);
  return prescription;
}

export async function processSuccessFee(customer: Customer, season: string): Promise<number> {
  const baseline = await getBaselineMetrics(customer, season);
  const actual = await getActualMetrics(customer, season);
  
  const inputSavings = calculateInputSavings(baseline, actual);
  const yieldGains = calculateYieldGains(baseline, actual);
  
  const totalSavings = inputSavings + yieldGains;
  const successFee = totalSavings * 0.10;
  
  if (successFee > 0) {
    await generateSuccessFeeInvoice(customer, successFee, {
      inputSavings,
      yieldGains,
      totalSavings
    });
  }
  
  return successFee;
}
```

### Operational Procedures

```typescript
export async function processFieldAlert(alert: Alert): Promise<void> {
  try {
    const field = await getField(alert.fieldId);
    const customer = await getCustomerByField(alert.fieldId);
    
    const priorityScore = calculateAlertPriority(alert, field);
    const actionPlan = await generateActionPlan(alert, field);
    
    await notifyCustomer(customer, alert, actionPlan);
    await createScoutingTask(alert, field, actionPlan);
    
    if (alert.severity === 'critical') {
      await escalateToAgronomist(alert, customer);
    }
    
    await trackAlertResponse(alert.id);
  } catch (error) {
    await logOperationalError('alert_processing', alert.id, error);
    throw new Error(`Alert processing failed: ${error.message}`);
  }
}

export async function runDailyOperations(): Promise<OperationsSummary> {
  const tasks = [
    processSatelliteImagery(),
    updateWeatherData(),
    runDiseaseModels(),
    generateAlerts(),
    updateCustomerDashboards(),
    processDataIngestion(),
    runSystemHealthChecks()
  ];
  
  const results = await Promise.allSettled(tasks);
  const summary = generateOperationsSummary(results);
  
  if (summary.criticalErrors > 0) {
    await notifyOperationsTeam(summary);
  }
  
  return summary;
}

export async function manageDataIngestion(customer: Customer): Promise<void> {
  for (const integration of customer.integrations) {
    try {
      const data = await fetchIntegrationData(integration);
      const processedData = await processIncomingData(data, integration.type);
      await storeCustomerData(customer.id, processedData);
      
      integration.lastSync = new Date();
      integration.status = 'active';
    } catch (error) {
      integration.status = 'error';
      integration.lastError = error.message;
      await notifyCustomerOfSyncIssue(customer, integration, error);
    }
  }
  
  await updateCustomerIntegrations(customer);
}
```

### Decision-Making Workflows

```typescript
export async function makeSprayDecision(field: Field, diseaseType: string): Promise<SprayDecision> {
  try {
    const diseaseRisk = await assessDiseaseRisk(field, diseaseType);
    const weatherForecast = await getWeatherForecast(field.location, 7);
    const economicThreshold = await calculateEconomicThreshold(field, diseaseType);
    const sprayWindow = await identifySprayWindow(weatherForecast);
    
    const decision = evaluateSprayDecision({
      diseaseRisk,
      economicThreshold,
      sprayWindow,
      fieldConditions: await getFieldConditions(field)
    });
    
    if (decision.recommend) {
      const products = await recommendFungicides(diseaseType, field);
      const timing = await optimizeSprayTiming(sprayWindow, field);
      
      return {
        recommend: true,
        products,
        timing,
        expectedROI: decision.expectedROI,
        confidence: decision.confidence
      };
    }
    
    return {
      recommend: false,
      reason: decision.reason,
      nextEvaluation: decision.nextEvaluation
    };
  } catch (error) {
    await logDecisionError('spray_decision', field.id, error);
    throw new Error(`Spray decision failed: ${error.message}`);
  }
}

export async function optimizeResourceAllocation(): Promise<AllocationPlan> {
  const customers = await getActiveCustomers();
  const resources = await getAvailableResources();
  const priorities = await calculateCustomerPriorities(customers);
  
  const allocationPlan = await solveResourceOptimization({
    customers,
    resources,
    priorities,
    constraints: await getResourceConstraints()
  });
  
  await validateAllocationPlan(allocationPlan);
  return allocationPlan;
}

export async function evaluateExpansionOpportunity(region: Region): Promise<ExpansionDecision> {
  const marketAnalysis = await analyzeMarket(region);
  const competitorAnalysis = await analyzeCompetitors(region);
  const regulatoryAnalysis = await analyzeRegulations(region);
  
  const opportunity = calculateOpportunityScore({
    market: marketAnalysis,
    competition: competitorAnalysis,
    regulatory: regulatoryAnalysis
  });
  
  const investmentRequired = await estimateInvestment(region);
  const projectedReturns = await projectReturns(region, opportunity);
  
  return {
    recommend: projectedReturns.roi > 3.0 && opportunity.score > 70,
    opportunityScore: opportunity.score,
    investmentRequired,
    projectedReturns,
    timeline: await createExpansionTimeline(region),
    risks: await identifyExpansionRisks(region)
  };
}
```

Generated from NAICS 111110 — Soybean Farming.
