---
name: DetourKit (Planned Detour Builder + GTFS Package)
slug: detourkit
naics:
  primary: '485113'
  occupations: []
service:
  title: Planned Detour Builder + GTFS Package
  description: >-
    Turns planned roadwork/events into vetted detours, temp stops, signage, and
    GTFS updates.
  targetUsers:
    - Planning
    - Operations
    - Customer communications
  triggers:
    - Construction/event notice received
    - Seasonal service plan updates
  inputs:
    - 'Event/construction scope (dates, links)'
    - Route shapes/stop list
    - Bus constraints
    - Historic ridership/dwell
  steps:
    - Generate alternate path(s) and score by time/dwell
    - Place/remove stops; ADA compliance checks
    - Create service exceptions and stop closures
    - Draft rider comms and signage package
    - Export GTFS patches and publishing schedule
  tools:
    - Mapbox/OSRM routing
    - ArcGIS/QGIS
    - GTFS editor (Remix/TransLoc or in‑house)
    - Docs/PDF generator
  outputs:
    - GeoJSON/KML detour map
    - GTFS stop/route/calendar patches
    - Signage PDFs and rider web copy
  pricingModel:
    - Per detour package
    - or Monthly (up to N detours)
  humanInLoop: true
  feasibility:
    remoteOnLaptop: 9
    modelCapability: 7
    overall: 8
  risks:
    - Missing local constraints or construction phasing changes
    - ADA/temporary stop compliance
    - Stakeholder coordination delays
  dependencies:
    - Access to base GTFS and publishing pipeline
    - Bus design constraints
    - Construction/event calendars
leanCanvas:
  problem:
    - >-
      Manual detour design is slow (often 8–24 hours per detour), error-prone,
      and requires scarce planner time.
    - >-
      Information fragmentation: roadwork/event notices live in PDFs, emails,
      permitting portals, and GIS; mapping data and service data live elsewhere
      (Esri, CAD/AVL, GTFS editors).
    - >-
      High risk of non-compliant temporary stops (ADA slope/landing clearance),
      illegal maneuvers, and bus-infeasible streets (weight/turn
      radius/clearance).
    - >-
      Inconsistent rider communications and signage; delays push changes after
      service has already started, eroding trust and increasing call center
      volume.
    - >-
      GTFS/GTFS-RT updates and operator bulletins are often manually assembled
      and out-of-sync with what is actually operated.
    - >-
      Coordination overhead with DOTs, public works, police, event organizers,
      and contractors; no shared workflow or audit trail.
    - >-
      Measuring detour impact (OTP, boardings retained, safety incidents) is
      difficult; no feedback loop to improve future detours.
  solution:
    - >-
      Automated ingestion of planned roadwork/event notices from emails, PDFs,
      permitting portals, and GIS feeds; NLP parses dates, extents, and
      restrictions.
    - >-
      Impact detection: identifies affected routes/trips, stop closures, and
      service windows; simulates OTP risk using historic speeds and constraints.
    - >-
      Constraint-based detour builder: proposes multiple feasible detour paths
      considering bus restrictions (turn radii, grades, clearances, weight, lane
      widths), traffic controls, and layover constraints.
    - >-
      ADA-aware temporary stop siting: evaluates sidewalks, crosswalk proximity,
      slope/curb/landing clearance, lighting, and safe dwell; flags compliance
      issues and alternatives.
    - >-
      Signage package generator: printable PDFs with QR codes, multilingual
      templates, operator bulletins, and work orders; digital assets for
      DMS/e-ink signs.
    - >-
      GTFS/GTFS-RT package: edits shapes/stops/calendar_dates, temp_stop flags,
      route/stop alerts, and feeds to trip planners; automatic validation
      (MobilityData rules).
    - >-
      Approval workflow: roles/permissions, versioning, internal and external
      review (DOT/police), and timeboxed publishing; audit log for compliance.
    - >-
      Publishing and notifications: pushes to CAD/AVL, rider apps, websites,
      SMS/email lists, social, and Waze CCP; synchronized
      activation/deactivation windows.
    - >-
      Performance tracking: monitors OTP delta, ridership retention within 400m,
      complaints, and operator incident reports; stores outcomes to improve
      suggestions.
    - >-
      APIs and connectors: Esri, Swiftly, Trapeze/Vontas, Clever Devices, GMV,
      Optibus, Transit App, Google Transit, one.network/INRIX/HERE/TomTom
      closures where available.
  uniqueValueProp: >-
    Turn roadwork and events into safe, ADA-aware, operator-vetted detours with
    auto-generated temp stops, signage, and one-click GTFS/GTFS-RT updates—in
    minutes, not days.
  unfairAdvantage: >-
    A continuously improving detour knowledge graph (closures → detours →
    outcomes) combined with bus-aware constraint routing and ADA siting models,
    plus deep integrations that publish synchronized GTFS and signage in
    minutes. This historical feedback loop and integration footprint are
    difficult and time-consuming for competitors to replicate.
  customerSegments:
    - >-
      Primary: Public transit agencies operating fixed-route bus (50–1,000+
      buses).
    - >-
      Secondary: Small agencies and contract operators (10–50 buses),
      universities, airports, hospitals, resort/corporate shuttles.
    - >-
      Adjacent stakeholders: City/DOT work-zone teams, event organizers, MPOs,
      CAD/AVL vendors, rider app providers needing alerts/detour geometry.
  channels:
    - >-
      Direct sales to mid-to-large agencies via demos and pilots; target
      agencies with frequent construction or BRT corridors.
    - >-
      Partner co-sell with Esri partners and CAD/AVL vendors; integrations
      listed on vendor marketplaces (Esri Marketplace, AWS Marketplace).
    - >-
      Participation in APTA, CTAA, TRB, regional transit tech forums; present
      case studies on OTP and complaint reductions.
    - >-
      State and cooperative procurement: Sourcewell, NASPO ValuePoint, Cal-ITP
      Mobility Marketplace to reduce purchasing friction.
    - >-
      Content-led growth: detour best-practice guides, open-source GTFS detour
      tools, webinars with MPO/DOT work-zone teams.
    - >-
      Inbound from event organizers and DOT work-zone portals via connectors
      that trigger agency outreach for pilots.
  revenueStreams:
    - >-
      Annual SaaS subscription priced by active detours and fleet size: Small
      (<50 buses): $10k–$25k ARR; Mid (50–300): $40k–$90k ARR; Large (>300):
      $120k–$250k ARR.
    - >-
      Add-on connectors (per data source/API): $3k–$15k ARR each (e.g., DOT
      permit portal, one.network, HERE/TomTom/INRIX).
    - >-
      Per-detour pay-as-you-go for small operators: $500 per approved detour
      package (includes GTFS + signage).
    - >-
      Professional services: onboarding/integration ($10k–$50k), signage
      print/installation management (cost+15%), historical detour
      backfill/clean-up projects.
    - >-
      Premium modules: ADA Deep Siting (imagery-rich), advanced simulation
      (OTP/ridership impact), SOC 2/FedRAMP hosting options.
  costStructure:
    - >-
      Team: product, ML/optimization engineers, GIS analysts, solutions
      engineers, sales/CS; fully loaded annual cost typical for SaaS.
    - >-
      Cloud infra: map tiles, routing graph computation, geocoding, LLM/NLP
      usage, storage, CI/CD, observability.
    - >-
      Third-party data: imagery, curb/sidewalk datasets, road restrictions,
      traffic speeds (HERE/INRIX/TomTom), Waze CCP operations.
    - >-
      Partner fees/marketplaces, conference/event sponsorships (APTA/TRB), pilot
      support travel.
    - >-
      Compliance/security: SOC 2 audits, pen tests, legal, insurance; privacy
      and accessibility reviews.
    - >-
      Customer success: training, 24/7 detour window support for major events,
      field audit contractors.
  keyMetrics:
    - >-
      Median Time-to-Detour (notice to approved package): target <45 minutes;
      80th percentile <2 hours.
    - >-
      Detour Accuracy Rate (no illegal turns, bus-infeasible links, disconnected
      shapes): >98% at publish; <1% rollback rate.
    - >-
      ADA Compliance Pass Rate for temporary stops: >95% pass; 100% of
      exceptions documented with mitigations.
    - >-
      GTFS Publish Latency (approval to feeds live): <10 minutes for RT; <30
      minutes for static bundles and site/app updates.
    - >-
      Rider Coverage Retained: % of affected riders within 400m of a temp or
      permanent stop during detour: >90%.
    - >-
      OTP Delta on Detoured Trips: absolute deterioration <5% vs baseline; mean
      added in-vehicle time <4 minutes.
    - >-
      Operator Readiness: % of operators confirming receipt of bulletin before
      first run: >95%.
    - >-
      Complaints per 10k trips during detours: -30% vs prior comparable detours
      after 3 months of use.
    - >-
      Adoption: monthly active planners >5 per agency for mid/large; >20
      detours/month managed by system for large agencies.
    - >-
      Business metrics: ACV $60k median; sales cycle 4–8 months; gross margin
      >75%; net revenue retention >110%; payback <14 months.
storyBrand:
  character: >-
    Transit operations managers, planners, and dispatchers at bus, shuttle, and
    BRT agencies who must keep routes reliable during planned closures and
    events.
  problem: >-
    External: closures force manual detours, ad-hoc temp stops, and error-prone
    GTFS edits; Internal: teams are stretched and worry about rider confusion;
    Philosophical: riders deserve clear, safe, predictable service even when
    streets change; Villain: detour chaos from fragmented notices and late
    updates.
  guide: >-
    Planned Detour Builder + GTFS Package understands the pressure of
    coordinating ops, safety, and rider comms; we bring standards-aligned GTFS
    expertise, risk checks, and integrations with common scheduling, CAD/AVL,
    and work-zone data sources.
  plan: >-
    1) Connect closure sources or upload details. 2) AI proposes policy-aware
    detours, temporary stops, and signage. 3) You review and approve. 4)
    One-click publish GTFS updates, operator bulletins, print kits, and rider
    alerts. 5) Monitor with audit trail and rollback.
  callToAction: >-
    Direct: Book a demo or start a pilot on your next planned closure.
    Transitional: Download the Detour Playbook and implementation checklist.
  success: >-
    Approved detours in hours instead of weeks; accurate GTFS in minutes; clear
    operator instructions and ADA-conscious signage; fewer call-center spikes;
    predictable service and higher rider trust; clean audits and fewer
    surprises.
  failure: >-
    Without it: last-minute scrambles, spreadsheet detour maps, wrong turns,
    missing or non-compliant signage, late GTFS pushes, missed trips, overtime
    costs, and public frustration.
landingPage:
  hero:
    title: Planned Detour Builder + GTFS Package
    subtitle: >-
      Turn roadwork and events into safe, operator-ready detours, temporary
      stops, signage, and GTFS updates—in minutes. Built for Bus and Other Motor
      Vehicle Transit Systems (NAICS 485113).
    ctaText: Get a demo
    ctaHref: /request-demo
  problem:
    - 'Detour design is slow, inconsistent, and hard to audit.'
    - Operators get vague maps and late changes—missed trips follow.
    - 'Riders see conflicting info across signs, web, and apps.'
    - 'GTFS and alerts lag, breaking planners and accessibility info.'
    - >-
      Compliance risks: turn bans, weight/height limits, school zones, stop
      spacing.
    - Cross‑agency coordination and approvals take days.
    - Temporary stop signage is ad‑hoc and off‑brand.
  solution:
    - 'AI generates compliant detours from closures, permits, and events.'
    - Auto‑sited temp stops with ADA checks and safety rules.
    - One‑click GTFS Static + GTFS‑Realtime alerts with shapes and stop updates.
    - 'Print‑ready signage with QR codes to live status, multilingual support.'
    - 'Operator packets: turn‑by‑turns, run cards, layovers, AVL updates.'
    - 'Approval workflow and audit trail for planning, ops, and comms.'
    - 'Seamless integrations with GIS, scheduling, CAD/AVL, and rider comms.'
  features:
    - >-
      Constraint‑aware routing: turn bans, low bridges, weight limits, bus
      length, time‑of‑day rules.
    - >-
      Map‑first editor with snap‑to‑network, stop validation, and conflict
      detection.
    - Travel time and schedule impact modeling using historical and live speeds.
    - >-
      Automatic temp stop siting with ADA curb/grade heuristics and safety
      flags.
    - >-
      GTFS package builder: Routes, Trips, StopTimes, Shapes, Calendars,
      Transfers, accessibility fields.
    - GTFS‑Realtime Alerts generator with detour geometry and stop closures.
    - 'Signage generator: print‑ready PDFs, QR codes, short URLs; batch export.'
    - 'Rider messaging: web widget, email/SMS feed, social copy templates.'
    - 'Operator comms: one‑pagers, cab cards, audio prompts, depot briefings.'
    - 'Scenario compare with KPIs: on‑time, travel time, coverage, cost deltas.'
    - 'Multi‑route, multi‑day support; templates for recurring events.'
    - 'Approvals, versioning, and rollback with full audit history.'
    - >-
      APIs and connectors for GIS layers, work orders/permits, scheduling,
      CAD/AVL.
    - >-
      Reporting: reliability impact, coverage, accessibility, and board/NTD
      summaries.
  steps:
    - Import or draw the closure area and time window.
    - 'Select affected routes, directions, and service days.'
    - Generate AI detours and temp stops; review safety and ADA checks.
    - Edit on the map; compare options; choose the best plan.
    - 'Publish: auto‑build GTFS + GTFS‑Realtime, signs, and operator packets.'
    - 'Notify riders via alerts, web widgets, and integrations.'
    - Monitor live performance; adjust and republish in one click.
---

```typescript
// Customer Acquisition Workflows

interface Lead {
  agencyName: string;
  fleetSize: number;
  contactInfo: ContactInfo;
  currentDetourVolume: number;
  painPoints: string[];
  budget?: number;
}

interface ContactInfo {
  name: string;
  title: string;
  email: string;
  phone: string;
}

interface Customer {
  id: string;
  agencyName: string;
  fleetSize: number;
  subscriptionTier: 'Small' | 'Mid' | 'Large';
  contractValue: number;
  onboardingStatus: 'pending' | 'in-progress' | 'complete';
}

interface Proposal {
  leadId: string;
  subscriptionTier: string;
  annualValue: number;
  features: string[];
  implementation: ImplementationPlan;
  roi: ROIProjection;
}

interface ImplementationPlan {
  duration: number;
  phases: string[];
  integrations: string[];
  training: TrainingPlan;
}

interface ROIProjection {
  timeToDetourReduction: number;
  costSavings: number;
  efficiencyGains: number;
}

interface TrainingPlan {
  sessions: number;
  duration: number;
  participants: string[];
}

export async function acquireCustomer(lead: Lead): Promise<Customer> {
  const qualifiedLead = await qualifyLead(lead);
  const proposal = await generateProposal(qualifiedLead);
  const contract = await negotiateContract(proposal);
  return await onboardCustomer(contract);
}

export async function qualifyLead(lead: Lead): Promise<Lead> {
  // Qualify based on fleet size, detour volume, and budget
  if (lead.fleetSize < 10) {
    throw new Error('Fleet size below minimum threshold');
  }
  
  const qualificationScore = calculateQualificationScore(lead);
  if (qualificationScore < 70) {
    throw new Error('Lead does not meet qualification criteria');
  }
  
  return {
    ...lead,
    painPoints: await analyzePainPoints(lead.painPoints),
  };
}

export async function generateProposal(lead: Lead): Promise<Proposal> {
  const tier = determineSubscriptionTier(lead.fleetSize);
  const features = await selectFeatures(tier, lead.painPoints);
  const implementation = await planImplementation(lead);
  const roi = await calculateROI(lead, tier);
  
  return {
    leadId: lead.agencyName,
    subscriptionTier: tier,
    annualValue: calculateAnnualValue(tier, lead.fleetSize),
    features,
    implementation,
    roi,
  };
}

export async function negotiateContract(proposal: Proposal): Promise<any> {
  // Contract negotiation workflow
  const terms = await generateContractTerms(proposal);
  const approvals = await getInternalApprovals(terms);
  return await finalizeContract(terms, approvals);
}

export async function onboardCustomer(contract: any): Promise<Customer> {
  const customer = await createCustomerAccount(contract);
  await setupIntegrations(customer);
  await scheduleTraining(customer);
  await configureSystem(customer);
  
  return {
    ...customer,
    onboardingStatus: 'complete',
  };
}

// Product Development Processes

interface ClosureNotice {
  id: string;
  source: 'email' | 'pdf' | 'portal' | 'gis';
  location: GeoLocation;
  dateRange: DateRange;
  restrictions: string[];
  rawData: any;
}

interface GeoLocation {
  coordinates: [number, number][];
  address: string;
  affectedRoutes: string[];
}

interface DateRange {
  start: Date;
  end: Date;
  timeWindows?: TimeWindow[];
}

interface TimeWindow {
  startTime: string;
  endTime: string;
  days: string[];
}

interface DetourRoute {
  id: string;
  originalRoute: string;
  alternativePath: GeoLocation;
  constraints: BusConstraints;
  temporaryStops: TemporaryStop[];
  compliance: ComplianceCheck;
}

interface BusConstraints {
  turnRadius: number;
  weight: number;
  height: number;
  width: number;
  grades: number[];
}

interface TemporaryStop {
  id: string;
  location: GeoLocation;
  adaCompliant: boolean;
  safetyScore: number;
  amenities: string[];
}

interface ComplianceCheck {
  ada: boolean;
  traffic: boolean;
  safety: boolean;
  issues: string[];
}

export async function ingestClosureNotice(notice: ClosureNotice): Promise<ClosureNotice> {
  const parsedNotice = await parseNoticeContent(notice);
  const validatedNotice = await validateNoticeData(parsedNotice);
  const enrichedNotice = await enrichWithGISData(validatedNotice);
  
  return await storeClosureNotice(enrichedNotice);
}

export async function detectImpact(notice: ClosureNotice): Promise<string[]> {
  const affectedRoutes = await identifyAffectedRoutes(notice.location);
  const serviceWindows = await calculateServiceWindows(notice.dateRange);
  const otpRisk = await simulateOTPRisk(affectedRoutes, notice.restrictions);
  
  return affectedRoutes;
}

export async function generateDetourOptions(
  closureNotice: ClosureNotice,
  constraints: BusConstraints
): Promise<DetourRoute[]> {
  const routingOptions = await calculateAlternativePaths(
    closureNotice.location,
    constraints
  );
  
  const detourRoutes = await Promise.all(
    routingOptions.map(async (path) => {
      const temporaryStops = await siteTemporaryStops(path);
      const compliance = await checkCompliance(path, temporaryStops);
      
      return {
        id: generateDetourId(),
        originalRoute: closureNotice.location.affectedRoutes[0],
        alternativePath: path,
        constraints,
        temporaryStops,
        compliance,
      };
    })
  );
  
  return await scoreAndRankDetours(detourRoutes);
}

export async function createSignagePackage(detour: DetourRoute): Promise<any> {
  const signageAssets = await generateSignageAssets(detour);
  const qrCodes = await generateQRCodes(detour);
  const multilingualContent = await translateContent(signageAssets);
  
  return {
    printablePDFs: signageAssets,
    qrCodes,
    multilingualContent,
    workOrders: await generateWorkOrders(detour),
  };
}

// Revenue Generation Flows

interface Subscription {
  customerId: string;
  tier: 'Small' | 'Mid' | 'Large';
  annualValue: number;
  features: string[];
  addOns: AddOn[];
  billingCycle: 'monthly' | 'annual';
}

interface AddOn {
  name: string;
  price: number;
  type: 'connector' | 'module' | 'service';
}

interface Usage {
  customerId: string;
  period: string;
  detoursCreated: number;
  gtfsUpdates: number;
  apiCalls: number;
}

export async function calculateSubscriptionRevenue(
  customer: Customer,
  usage: Usage
): Promise<number> {
  const baseSubscription = await getSubscriptionDetails(customer.id);
  const usageCharges = await calculateUsageCharges(usage);
  const addOnCharges = await calculateAddOnCharges(baseSubscription.addOns);
  
  return baseSubscription.annualValue + usageCharges + addOnCharges;
}

export async function processPayment(
  customerId: string,
  amount: number
): Promise<boolean> {
  const paymentMethod = await getPaymentMethod(customerId);
  const invoice = await generateInvoice(customerId, amount);
  const payment = await chargePaymentMethod(paymentMethod, amount);
  
  if (payment.success) {
    await updateSubscriptionStatus(customerId, 'active');
    await sendPaymentConfirmation(customerId, invoice);
    return true;
  }
  
  await handlePaymentFailure(customerId, payment.error);
  return false;
}

export async function upsellCustomer(
  customerId: string,
  targetTier: string
): Promise<boolean> {
  const currentSubscription = await getSubscriptionDetails(customerId);
  const upsellProposal = await generateUpsellProposal(currentSubscription, targetTier);
  const approval = await presentUpsellProposal(customerId, upsellProposal);
  
  if (approval) {
    await upgradeSubscription(customerId, targetTier);
    await updateBilling(customerId, upsellProposal.newAmount);
    return true;
  }
  
  return false;
}

// Operational Procedures

interface GTFSPackage {
  routes: any[];
  stops: any[];
  trips: any[];
  shapes: any[];
  calendar: any[];
  alerts: any[];
}

interface PublishingSchedule {
  staticGTFS: Date;
  realtimeGTFS: Date;
  riderApps: Date;
  operatorBulletins: Date;
  signage: Date;
}

export async function createDetourWorkflow(
  closureNotice: ClosureNotice
): Promise<string> {
  const workflowId = generateWorkflowId();
  
  // Step 1: Impact Detection
  const affectedRoutes = await detectImpact(closureNotice);
  
  // Step 2: Generate Detour Options
  const constraints = await getBusConstraints(affectedRoutes);
  const detourOptions = await generateDetourOptions(closureNotice, constraints);
  
  // Step 3: Create Signage Package
  const selectedDetour = detourOptions[0]; // Highest scored
  const signagePackage = await createSignagePackage(selectedDetour);
  
  // Step 4: Generate GTFS Package
  const gtfsPackage = await generateGTFSPackage(selectedDetour);
  
  // Step 5: Create Publishing Schedule
  const publishingSchedule = await createPublishingSchedule(closureNotice.dateRange);
  
  await storeWorkflow(workflowId, {
    closureNotice,
    detourOptions,
    signagePackage,
    gtfsPackage,
    publishingSchedule,
    status: 'pending_approval',
  });
  
  return workflowId;
}

export async function generateGTFSPackage(detour: DetourRoute): Promise<GTFSPackage> {
  const routes = await updateRouteShapes(detour);
  const stops = await createTemporaryStops(detour.temporaryStops);
  const trips = await updateTripPatterns(detour);
  const shapes = await generateShapeFiles(detour.alternativePath);
  const calendar = await updateServiceCalendar(detour);
  const alerts = await generateServiceAlerts(detour);
  
  return {
    routes,
    stops,
    trips,
    shapes,
    calendar,
    alerts,
  };
}

export async function publishDetour(workflowId: string): Promise<boolean> {
  const workflow = await getWorkflow(workflowId);
  
  if (workflow.status !== 'approved') {
    throw new Error('Workflow must be approved before publishing');
  }
  
  // Publish in sequence according to schedule
  await publishStaticGTFS(workflow.gtfsPackage);
  await publishRealtimeGTFS(workflow.gtfsPackage.alerts);
  await updateRiderApps(workflow.gtfsPackage);
  await distributeOperatorBulletins(workflow);
  await activateSignage(workflow.signagePackage);
  
  // Update workflow status
  await updateWorkflowStatus(workflowId, 'published');
  
  // Start monitoring
  await startPerformanceMonitoring(workflowId);
  
  return true;
}

export async function monitorDetourPerformance(workflowId: string): Promise<any> {
  const metrics = await collectPerformanceMetrics(workflowId);
  const otpDelta = await calculateOTPDelta(metrics);
  const ridershipRetention = await calculateRidershipRetention(metrics);
  const complaints = await countComplaints(workflowId);
  
  const performance = {
    otpDelta,
    ridershipRetention,
    complaints,
    timestamp: new Date(),
  };
  
  await storePerformanceData(workflowId, performance);
  
  // Check if intervention needed
  if (otpDelta > 0.05 || complaints > 10) {
    await triggerPerformanceAlert(workflowId, performance);
  }
  
  return performance;
}

// Decision-Making Workflows

interface ApprovalWorkflow {
  workflowId: string;
  approvers: Approver[];
  currentStage: string;
  decisions: Decision[];
  deadline: Date;
}

interface Approver {
  role: 'planner' | 'operations' | 'safety' | 'external';
  name: string;
  email: string;
  required: boolean;
}

interface Decision {
  approverId: string;
  decision: 'approved' | 'rejected' | 'needs_changes';
  comments: string;
  timestamp: Date;
}

export async function initiateApprovalWorkflow(
  workflowId: string,
  approvers: Approver[]
): Promise<string> {
  const approvalWorkflow: ApprovalWorkflow = {
    workflowId,
    approvers,
    currentStage: 'internal_review',
    decisions: [],
    deadline: new Date(Date.now() + 48 * 60 * 60 * 1000), // 48 hours
  };
  
  await storeApprovalWorkflow(approvalWorkflow);
  await notifyApprovers(approvers, workflowId);
  
  return approvalWorkflow.workflowId;
}

export async function processApprovalDecision(
  workflowId: string,
  approverId: string,
  decision: 'approved' | 'rejected' | 'needs_changes',
  comments: string
): Promise<boolean> {
  const approvalWorkflow = await getApprovalWorkflow(workflowId);
  
  const newDecision: Decision = {
    approverId,
    decision,
    comments,
    timestamp: new Date(),
  };
  
  approvalWorkflow.decisions.push(newDecision);
  
  if (decision === 'rejected') {
    await updateWorkflowStatus(workflowId, 'rejected');
    await notifyRejection(workflowId, comments);
    return false;
  }
  
  if (decision === 'needs_changes') {
    await updateWorkflowStatus(workflowId, 'needs_revision');
    await requestRevisions(workflowId, comments);
    return false;
  }
  
  // Check if all required approvals received
  const allApproved = await checkAllApprovalsReceived(approvalWorkflow);
  
  if (allApproved) {
    await updateWorkflowStatus(workflowId, 'approved');
    await schedulePublication(workflowId);
    return true;
  }
  
  await updateApprovalWorkflow(approvalWorkflow);
  return false;
}

export async function escalateApproval(
  workflowId: string,
  reason: string
): Promise<void> {
  const approvalWorkflow = await getApprovalWorkflow(workflowId);
  
  if (new Date() > approvalWorkflow.deadline) {
    const escalationApprovers = await getEscalationApprovers();
    await addApprovers(workflowId, escalationApprovers);
    await notifyEscalation(workflowId, reason);
  }
}

export async function auditDetourDecision(workflowId: string): Promise<any> {
  const workflow = await getWorkflow(workflowId);
  const approvalWorkflow = await getApprovalWorkflow(workflowId);
  const performance = await getPerformanceData(workflowId);
  
  return {
    workflowId,
    decisions: approvalWorkflow.decisions,
    outcome: workflow.status,
    performance,
    compliance: await checkComplianceAudit(workflow),
    timestamp: new Date(),
  };
}

// Helper functions (implementation details would be filled in)
async function calculateQualificationScore(lead: Lead): Promise<number> { return 85; }
async function analyzePainPoints(painPoints: string[]): Promise<string[]> { return painPoints; }
async function determineSubscriptionTier(fleetSize: number): string { 
  if (fleetSize < 50) return 'Small';
  if (fleetSize < 300) return 'Mid';
  return 'Large';
}
async function selectFeatures(tier: string, painPoints: string[]): Promise<string[]> { return []; }
async function planImplementation(lead: Lead): Promise<ImplementationPlan> { 
  return { duration: 12, phases: [], integrations: [], training: { sessions: 3, duration: 2, participants: [] } };
}
async function calculateROI(lead: Lead, tier: string): Promise<ROIProjection> { 
  return { timeToDetourReduction: 45, costSavings: 100000, efficiencyGains: 0.3 };
}
async function calculateAnnualValue(tier: string, fleetSize: number): number { return 60000; }
async function generateContractTerms(proposal: Proposal): Promise<any> { return {}; }
async function getInternalApprovals(terms: any): Promise<any> { return {}; }
async function finalizeContract(terms: any, approvals: any): Promise<any> { return {}; }
async function createCustomerAccount(contract: any): Promise<Customer> { 
  return { id: '1', agencyName: 'Test', fleetSize: 100, subscriptionTier: 'Mid', contractValue: 60000, onboardingStatus: 'pending' };
}
async function setupIntegrations(customer: Customer): Promise<void> {}
async function scheduleTraining(customer: Customer): Promise<void> {}
async function configureSystem(customer: Customer): Promise<void> {}
async function parseNoticeContent(notice: ClosureNotice): Promise<ClosureNotice> { return notice; }
async function validateNoticeData(notice: ClosureNotice): Promise<ClosureNotice> { return notice; }
async function enrichWithGISData(notice: ClosureNotice): Promise<ClosureNotice> { return notice; }
async function storeClosureNotice(notice: ClosureNotice): Promise<ClosureNotice> { return notice; }
async function identifyAffectedRoutes(location: GeoLocation): Promise<string[]> { return []; }
async function calculateServiceWindows(dateRange: DateRange): Promise<any> { return {}; }
async function simulateOTPRisk(routes: string[], restrictions: string[]): Promise<number> { return 0.05; }
async function calculateAlternativePaths(location: GeoLocation, constraints: BusConstraints): Promise<GeoLocation[]> { return []; }
async function siteTemporaryStops(path: GeoLocation): Promise<TemporaryStop[]> { return []; }
async function checkCompliance(path: GeoLocation, stops: TemporaryStop[]): Promise<ComplianceCheck> { 
  return { ada: true, traffic: true, safety: true, issues: [] };
}
async function generateDetourId(): string { return 'detour-' + Date.now(); }
async function scoreAndRankDetours(detours: DetourRoute[]): Promise<DetourRoute[]> { return detours; }
async function generateSignageAssets(detour: DetourRoute): Promise<any> { return {}; }
async function generateQRCodes(detour: DetourRoute): Promise<any> { return {}; }
async function translateContent(assets: any): Promise<any> { return {}; }
async function generateWorkOrders(detour: DetourRoute): Promise<any> { return {}; }
async function getSubscriptionDetails(customerId: string): Promise<Subscription> { 
  return { customerId, tier: 'Mid', annualValue: 60000, features: [], addOns: [], billingCycle: 'annual' };
}
async function calculateUsageCharges(usage: Usage): Promise<number> { return 0; }
async function calculateAddOnCharges(addOns: AddOn[]): Promise<number> { return 0; }
async function getPaymentMethod(customerId: string): Promise<any> { return {}; }
async function generateInvoice(customerId: string, amount: number): Promise<any> { return {}; }
async function chargePaymentMethod(method: any, amount: number): Promise<any> { return { success: true }; }
async function updateSubscriptionStatus(customerId: string, status: string): Promise<void> {}
async function sendPaymentConfirmation(customerId: string, invoice: any): Promise<void> {}
async function handlePaymentFailure(customerId: string, error: any): Promise<void> {}
async function generateUpsellProposal(subscription: Subscription, targetTier: string): Promise<any> { return {}; }
async function presentUpsellProposal(customerId: string, proposal: any): Promise<boolean> { return true; }
async function upgradeSubscription(customerId: string, tier: string): Promise<void> {}
async function updateBilling(customerId: string, amount: number): Promise<void> {}
async function generateWorkflowId(): string { return 'workflow-' + Date.now(); }
async function getBusConstraints(routes: string[]): Promise<BusConstraints> { 
  return { turnRadius: 12, weight: 40000, height: 12, width: 8, grades: [0.08] };
}
async function createPublishingSchedule(dateRange: DateRange): Promise<PublishingSchedule> { 
  return { staticGTFS: new Date(), realtimeGTFS: new Date(), riderApps: new Date(), operatorBulletins: new Date(), signage: new Date() };
}
async function storeWorkflow(id: string, data: any): Promise<void> {}
async function updateRouteShapes(detour: DetourRoute): Promise<any[]> { return []; }
async function createTemporaryStops(stops: TemporaryStop[]): Promise<any[]> { return []; }
async function updateTripPatterns(detour: DetourRoute): Promise<any[]> { return []; }
async function generateShapeFiles(path: GeoLocation): Promise<any[]> { return []; }
async function updateServiceCalendar(detour: DetourRoute): Promise<any[]> { return []; }
async function generateServiceAlerts(detour: DetourRoute): Promise<any[]> { return []; }
async function getWorkflow(id: string): Promise<any> { return { status: 'approved' }; }
async function publishStaticGTFS(gtfs: GTFSPackage): Promise<void> {}
async function publishRealtimeGTFS(alerts: any[]): Promise<void> {}
async function updateRiderApps(gtfs: GTFSPackage): Promise<void> {}
async function distributeOperatorBulletins(workflow: any): Promise<void> {}
async function activateSignage(signage: any): Promise<void> {}
async function updateWorkflowStatus(id: string, status: string): Promise<void> {}
async function startPerformanceMonitoring(id: string): Promise<void> {}
async function collectPerformanceMetrics(id: string): Promise<any> { return {}; }
async function calculateOTPDelta(metrics: any): Promise<number> { return 0.02; }
async function calculateRidershipRetention(metrics: any): Promise<number> { return 0.92; }
async function countComplaints(id: string): Promise<number> { return 2; }
async function storePerformanceData(id: string, data: any): Promise<void> {}
async function triggerPerformanceAlert(id: string, performance: any): Promise<void> {}
async function storeApprovalWorkflow(workflow: ApprovalWorkflow): Promise<void> {}
async function notifyApprovers(approvers: Approver[], workflowId: string): Promise<void> {}
async function getApprovalWorkflow(id: string): Promise<ApprovalWorkflow> { 
  return { workflowId: id, approvers: [], currentStage: 'internal_review', decisions: [], deadline: new Date() };
}
async function notifyRejection(id: string, comments: string): Promise<void> {}
async function requestRevisions(id: string, comments: string): Promise<void> {}
async function checkAllApprovalsReceived(workflow: ApprovalWorkflow): Promise<boolean> { return true; }
async function schedulePublication(id: string): Promise<void> {}
async function updateApprovalWorkflow(workflow: ApprovalWorkflow): Promise<void> {}
async function getEscalationApprovers(): Promise<Approver[]> { return []; }
async function addApprovers(id: string, approvers: Approver[]): Promise<void> {}
async function notifyEscalation(id: string, reason: string): Promise<void> {}
async function getPerformanceData(id: string): Promise<any> { return {}; }
async function checkComplianceAudit(workflow: any): Promise<any> { return {}; }
```

# DetourKit (Planned Detour Builder + GTFS Package)

Generated for NAICS 485113 — Bus and Other Motor Vehicle Transit Systems.
Service: Planned Detour Builder + GTFS Package
