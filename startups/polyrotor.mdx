---
name: PolyRotor Predictive
slug: polyrotor
naics:
  primary: '325212'
  occupations: []
service:
  title: PdM for Compressors/Pumps/Gearboxes
  description: >-
    Anomaly detection and Remaining Useful Life predictions for rotating
    equipment serving polymerization and finishing units.
  targetUsers:
    - Maintenance/reliability engineers
    - CMMS planners
  triggers:
    - New vibration/motor current batch every hour
    - High temperature or pressure event
    - Post-maintenance baseline change
  inputs:
    - 'Vibration, acoustic, temperature, current, pressure signals'
    - 'CMMS history (failures, repairs)'
    - 'Operating context (load, speed, product)'
  steps:
    - Ingest and cleanse condition-monitoring data
    - Detect anomalies vs contextual baselines
    - Estimate RUL and failure mode likelihood
    - Draft inspection/work order with parts list and priority
    - Feedback loop with maintenance outcomes to retrain
  tools:
    - PI/Condition monitoring system API
    - Azure ML/Databricks or local Python
    - SAP PM/Maximo API (read/write)
    - XGBoost/LSTM (optional)
  outputs:
    - Asset health scores and alerts
    - RUL estimates with confidence
    - Pre-filled CMMS notifications
  pricingModel:
    - Per-site setup
    - Per-asset monthly fee tiers
    - Optional per-avoidance bonus
  humanInLoop: true
  feasibility:
    remoteOnLaptop: 5
    modelCapability: 4
    overall: 4
  risks:
    - Sensor drift/placement issues
    - False positives causing alarm fatigue
    - Limited failure labels for some assets
  dependencies:
    - Access to CMMS and historian
    - Asset registry with BOMs
    - Maintenance workflow integration
leanCanvas:
  problem:
    - >-
      Unplanned failures of pumps, compressors, and gearboxes in
      polymerization/finishing cause high-cost outages ($30k–$150k per hour lost
      contribution margin, depending on unit).
    - >-
      Polymer service is harsh: variable viscosity, fouling, solids, and
      batch/transient operation increase false alarms in generic PdM and mask
      early-stage faults (seal wear, cavitation, bearing spall, gearbox tooth
      damage).
    - >-
      Existing condition monitoring is fragmented (route-based vibration, OEM
      tools, historian trends) and not fused into actionable, prioritized work
      orders with RUL estimates.
    - >-
      Reliability teams are stretched; senior analysts are scarce. Plants
      struggle to maintain PdM program coverage across 200–600 rotating assets
      per site.
    - >-
      Safety and compliance risk: mechanical seal failures in monomers
      (butadiene, styrene, acrylonitrile) can trigger flaring, emissions, or PSM
      events.
    - >-
      ROI uncertainty: leadership hesitates without clear KPIs, baselines, and
      guaranteed payback from pilots.
  solution:
    - >-
      Ingest multi-signal data (vibration, process, electrical) from historian
      and online monitors; augment with Class I Div 2/Zone 2 wireless sensors
      where gaps exist.
    - >-
      Hybrid physics + ML models tailored for polymer service
      (cavitation/fouling-aware pump models, compressor surge/valve wear,
      gearbox load variability) with operating-mode segmentation for
      batch/transient cycles.
    - >-
      Asset health scoring and RUL predictions with confidence intervals;
      root-cause suggestions and recommended corrective actions tied to spare
      parts and job plans.
    - >-
      CMMS integration (SAP PM/Maximo) to auto-generate prioritized
      notifications/work orders with lead time aligned to RUL and maintenance
      windows.
    - >-
      Criticality mapping to focus on the top 20–40% high-impact assets; dynamic
      prioritization by production plan and safety criticality.
    - >-
      Operational workflow: 90-day proof-of-value on 20–40 assets → scale to
      150–250 assets/site in 12 months, including change management and skills
      transfer to in-house teams.
  uniqueValueProp: >-
    Domain-specific predictive maintenance for polymerization and finishing
    units that reduces unplanned rotating-equipment downtime by 30–40%, detects
    faults 7–30 days earlier, and delivers calibrated Remaining Useful Life
    (RUL) with <20% mean absolute error—seamlessly integrated with plant
    historian and CMMS to trigger the right work at the right time.
  unfairAdvantage: >-
    Validated polymer-service failure library and operating-mode-aware models
    that materially reduce false alarms in batch/transient conditions; deep
    integrations to historian/CMMS enabling automated, prioritized work orders;
    and early reference sites in synthetic rubber creating a data moat and
    domain credibility.
  customerSegments:
    - >-
      Primary economic buyers: Plant Managers and Reliability/Maintenance
      Directors at synthetic rubber plants (SBR, BR, NBR, EPDM) in North America
      (NAICS 325212).
    - >-
      Primary users: Reliability engineers, rotating equipment specialists,
      vibration analysts, maintenance planners, and control room supervisors.
    - >-
      Influencers: EHS/PSM managers (spill/emissions avoidance), Operations
      Managers (runtime stability), Procurement/IT/OT Security.
    - >-
      Early adopters profile: Plants with OSIsoft/AVEVA PI or Honeywell PHD
      historian, SAP PM/Maximo CMMS, at least 20–80 critical rotating assets,
      and recent unplanned downtime events (>1 major event in past 12 months).
  channels:
    - >-
      Direct enterprise sales to Reliability/Maintenance leadership at NA
      synthetic rubber plants.
    - >-
      Channel partners: rotating equipment OEMs (Flowserve, Sulzer, Howden),
      vibration vendors (SKF, Emerson, Wilcoxon), and industrial SIs with
      ISA/IEC certifications.
    - >-
      Industry associations/events: IISRP meetings, Rubber Division ACS, AIChE
      Spring Meeting, Reliability conferences (SMRP).
    - >-
      Content marketing: polymer-service PdM whitepapers, failure-mode guides,
      and case studies; webinars co-hosted with OEMs and SIs.
    - >-
      Pilot-led motions: 90-day proof-of-value with success-based pricing and
      executive readout tied to ROI.
    - >-
      Land-and-expand: start in polymerization/finishing, then extend to
      utilities (cooling water, vacuum systems) and adjacent units.
  revenueStreams:
    - >-
      Annual SaaS subscription per monitored asset (tiered):
      $1,000–$3,000/asset/year depending on criticality and data depth.
    - >-
      Enterprise/site license discounts beyond 200 assets; multi-site agreements
      for corporate procurement.
    - >-
      Implementation and integration fee: $50,000–$200,000 per site (data
      connectors, model tuning, CMMS integration, onboarding).
    - >-
      Optional managed services: remote vibration/ PdM analyst support
      $5,000–$20,000/month/site.
    - >-
      Hardware pass-through or lease: Class I Div 2 sensors and gateways where
      needed ($300–$800/asset, $2,000–$5,000/gateway).
    - >-
      Performance-linked upside: bonus tied to verified avoided downtime or
      maintenance cost reduction beyond threshold (e.g., 10% of verified savings
      above baseline).
  costStructure:
    - >-
      COGS per asset (steady state): cloud/compute $3–$10/asset/month; data
      egress/ingest $1–$3/asset/month; support $2–$5/asset/month.
    - >-
      Initial hardware (where needed): $300–$800/asset sensors; $2,000–$5,000
      per gateway; installation $150–$300/asset.
    - >-
      Personnel: ML engineers, data engineers, reliability SMEs (rotating),
      field engineers, customer success; fully loaded cost $180k–$240k per
      senior FTE/year.
    - >-
      Sales and marketing: enterprise sales cycles 6–12 months; CAC target
      <$150k/site with multi-year payback.
    - >-
      Compliance and security: ISA/IEC 62443 assessments, SOC 2 Type II, vendor
      qualification costs.
    - >-
      R&D: physics-informed models, operating-mode segmentation, and false-alarm
      reduction; ongoing model validation/resources ~15–20% of revenue.
  keyMetrics:
    - >-
      Business impact: unplanned downtime reduction (%) with target 30–40% on
      monitored critical assets; avoided downtime $ per quarter; maintenance
      cost reduction 10–20%.
    - >-
      Reliability KPIs: MTBF increase 15–25%; mean time to detect (MTTD) <24
      hours from onset; mean time to act (MTTA) aligned to planned window.
    - >-
      Model performance: RUL MAE <20%; early warning lead time median ≥14 days
      for bearing/seal faults; precision ≥85%, recall ≥75% on labeled events;
      false positive rate <2% per asset-month.
    - >-
      Adoption: % of critical assets onboarded (>80% in 12 months/site); weekly
      active users; % alerts converted to CMMS work orders (>70%).
    - >-
      Change management: time-to-first-value <45 days; training completion
      rates; NPS ≥50 from reliability users.
    - >-
      Sales metrics: pilot win rate >40%; pilot-to-scale conversion >60%; ARR
      per site $250k–$750k at scale.
storyBrand:
  character: >-
    Reliability and production leaders at synthetic rubber plants (NAICS 325212)
    responsible for compressors, pumps, and gearboxes in polymerization and
    finishing units.
  problem: >-
    Hidden degradation and surprise failures halt lines, create scrap, risk
    safety, and spike costs; without early anomaly detection and RUL,
    maintenance stays reactive and stressful.
  guide: >-
    We understand how a single compressor trip cascades through polymerization
    and finishing. Our AI PdM service combines process and vibration analytics
    to detect anomalies and predict RUL for rotating equipment in synthetic
    rubber operations.
  plan: >-
    Connect data sources (historians, CMMS, sensors); calibrate models with
    run-states and failure history; deliver prioritized alerts and RUL into your
    planning workflow. Prove value on a pilot asset train in weeks, then scale
    plant-wide.
  callToAction: >-
    Schedule a 30-minute demo and select a pilot asset, or request the readiness
    checklist.
  success: >-
    Fewer unplanned outages, optimized maintenance windows, extended asset life,
    stable throughput and quality, lower OPEX, and audit-ready risk reduction.
  failure: >-
    Ongoing firefighting: emergency shutdowns, missed shipments, costly
    overhauls, safety or environmental incidents, and strained maintenance
    bandwidth.
landingPage:
  hero:
    title: 'PdM for Compressors, Pumps and Gearboxes'
    subtitle: >-
      AI anomaly detection and Remaining Useful Life for rotating equipment in
      synthetic rubber polymerization and finishing units.
    ctaText: Request a demo
    ctaHref: '#demo'
  problem:
    - Unplanned trips stall polymerization trains and cause off-spec batches.
    - Time-based overhauls waste budget and miss hidden failures.
    - >-
      Early signs of cavitation, seal wear, and gearbox fatigue get lost in
      historian noise.
    - 'Data is siloed across PI/DCS, vibration, and maintenance systems.'
    - Reactive spares and crew scheduling drive up downtime and cost.
    - Compliance and process safety demand traceable asset health evidence.
  solution:
    - >-
      Continuously monitor compressors, pumps, and gearboxes with multivariate
      models.
    - Detect anomalies early and prioritize by risk and production impact.
    - Forecast Remaining Useful Life with confidence bands for outage planning.
    - >-
      Explainable alerts pinpoint root drivers like suction instability or
      bearing wear.
    - Sync recommendations to SAP PM/Maximo to plan and verify work.
    - 'Deploy at the edge or cloud; secure, low-latency, and scalable.'
  features:
    - >-
      Asset templates for reciprocating/screw compressors, centrifugal pumps,
      and gearboxes.
    - >-
      Physics-guided features: pressure ratio, flow coefficient, NPSH margin,
      vibration RMS/envelope/kurtosis, temperature deltas.
    - Self-learning models that adapt to grade changes and duty cycles.
    - Drift monitoring and governed retraining with approvals.
    - Explainable AI with contribution charts and what-changed views.
    - RUL estimates with lead-time awareness for spares and crews.
    - Startup/grade-switch suppression to avoid nuisance alarms.
    - 'Connectors for PI, IP.21, PHD; OPC UA/MQTT edge ingestion.'
    - 'CMMS integration: SAP PM and IBM Maximo for work orders and closures.'
    - 'Role-based access, SSO, audit logs; offline and air-gapped options.'
    - 'Dashboards for avoided downtime, MTBF, and energy per ton.'
    - Deploy fast and scale from pilot line to site-wide coverage.
  steps:
    - '1) Connect data: historian (PI/IP.21/PHD), DCS/PLC, vibration, and CMMS.'
    - '2) Baseline: 30–60 days of normal operation; set health thresholds.'
    - '3) Go live: anomaly alerts and RUL in app, email, or Teams/Slack.'
    - '4) Integrate maintenance: auto-create work orders and spares reservations.'
    - '5) Scale and refine: add assets, review KPIs, and iterate models.'
---

# PolyRotor Predictive

Generated for NAICS 325212 — Synthetic Rubber Manufacturing.
Service: PdM for Compressors/Pumps/Gearboxes

## Business Workflow Functions

```typescript
// Core business process types and interfaces
interface Lead {
  id: string;
  companyName: string;
  plantLocation: string;
  contactInfo: ContactInfo;
  assetCount: number;
  recentDowntimeEvents: DowntimeEvent[];
  existingSystems: ExistingSystems;
  qualificationScore?: number;
}

interface Customer {
  id: string;
  lead: Lead;
  contract: Contract;
  onboardingStatus: OnboardingStatus;
  assets: Asset[];
  healthScores: AssetHealthScore[];
}

interface Asset {
  id: string;
  type: 'pump' | 'compressor' | 'gearbox';
  criticality: 'high' | 'medium' | 'low';
  location: string;
  specifications: AssetSpecs;
  sensors: Sensor[];
  maintenanceHistory: MaintenanceRecord[];
}

interface PredictiveMaintenanceAlert {
  assetId: string;
  severity: 'critical' | 'warning' | 'info';
  remainingUsefulLife: number;
  confidenceInterval: [number, number];
  rootCause: string;
  recommendedActions: string[];
  workOrderPriority: number;
}

// Customer Acquisition Workflows
export async function acquireCustomer(lead: Lead): Promise<Customer> {
  // Step 1: Qualify the lead based on plant characteristics
  const qualifiedLead = await qualifyLead(lead);
  
  if (qualifiedLead.qualificationScore < 70) {
    throw new Error('Lead does not meet qualification criteria');
  }

  // Step 2: Conduct technical assessment and generate proposal
  const technicalAssessment = await conductTechnicalAssessment(qualifiedLead);
  const proposal = await generateProposal(qualifiedLead, technicalAssessment);
  
  // Step 3: Negotiate contract terms and pricing
  const contract = await negotiateContract(proposal);
  
  // Step 4: Onboard the new customer
  const customer = await onboardCustomer(qualifiedLead, contract);
  
  return customer;
}

export async function qualifyLead(lead: Lead): Promise<Lead> {
  let score = 0;
  
  // Check for required systems (historian, CMMS)
  if (lead.existingSystems.historian && lead.existingSystems.cmms) {
    score += 30;
  }
  
  // Evaluate asset count (20-80 critical assets preferred)
  if (lead.assetCount >= 20 && lead.assetCount <= 80) {
    score += 25;
  }
  
  // Recent downtime events indicate pain point
  if (lead.recentDowntimeEvents.length > 0) {
    score += 25;
  }
  
  // NAICS 325212 synthetic rubber plants get priority
  if (lead.companyName.includes('rubber') || lead.companyName.includes('polymer')) {
    score += 20;
  }
  
  return { ...lead, qualificationScore: score };
}

// Product Development Processes
export async function developPredictiveModel(
  assetType: Asset['type'],
  trainingData: SensorData[],
  operatingConditions: OperatingConditions[]
): Promise<PredictiveModel> {
  // Step 1: Data preprocessing and feature engineering
  const processedData = await preprocessSensorData(trainingData);
  const features = await extractPolymerServiceFeatures(processedData, operatingConditions);
  
  // Step 2: Train hybrid physics + ML model
  const physicsModel = await buildPhysicsInformedModel(assetType);
  const mlModel = await trainMachineLearningModel(features);
  const hybridModel = await combineModels(physicsModel, mlModel);
  
  // Step 3: Validate model performance
  const validation = await validateModel(hybridModel, testData);
  
  if (validation.meanAbsoluteError > 0.20) {
    throw new Error('Model does not meet <20% MAE requirement');
  }
  
  return hybridModel;
}

export async function segmentOperatingModes(
  sensorData: SensorData[],
  processConditions: ProcessConditions[]
): Promise<OperatingMode[]> {
  // Handle batch/transient operation cycles specific to polymer service
  const modes = await identifyOperatingModes(sensorData, processConditions);
  
  // Filter out transient periods to reduce false alarms
  const stableModes = modes.filter(mode => mode.duration > 300); // 5+ minutes
  
  return stableModes;
}

// Revenue Generation Flows
export async function generateRevenue(customer: Customer): Promise<RevenueStream[]> {
  const revenueStreams: RevenueStream[] = [];
  
  // SaaS subscription revenue per asset
  const subscriptionRevenue = await calculateSubscriptionRevenue(customer);
  revenueStreams.push(subscriptionRevenue);
  
  // Implementation and integration fees
  if (customer.onboardingStatus === 'new') {
    const implementationFee = await calculateImplementationFee(customer);
    revenueStreams.push(implementationFee);
  }
  
  // Optional managed services
  if (customer.contract.managedServices) {
    const managedServicesRevenue = await calculateManagedServicesRevenue(customer);
    revenueStreams.push(managedServicesRevenue);
  }
  
  // Performance-linked upside based on verified savings
  const performanceBonus = await calculatePerformanceBonus(customer);
  if (performanceBonus.amount > 0) {
    revenueStreams.push(performanceBonus);
  }
  
  return revenueStreams;
}

export async function calculateSubscriptionRevenue(customer: Customer): Promise<RevenueStream> {
  const assetTiers = customer.assets.map(asset => {
    const basePrice = asset.criticality === 'high' ? 3000 : 
                     asset.criticality === 'medium' ? 2000 : 1000;
    
    return {
      assetId: asset.id,
      annualPrice: basePrice,
      monthlyPrice: basePrice / 12
    };
  });
  
  const totalAnnual = assetTiers.reduce((sum, tier) => sum + tier.annualPrice, 0);
  
  return {
    type: 'subscription',
    amount: totalAnnual,
    frequency: 'annual',
    description: `SaaS subscription for ${customer.assets.length} monitored assets`
  };
}

// Operational Procedures
export async function monitorAssetHealth(assets: Asset[]): Promise<PredictiveMaintenanceAlert[]> {
  const alerts: PredictiveMaintenanceAlert[] = [];
  
  for (const asset of assets) {
    try {
      // Ingest multi-signal data from historian and sensors
      const sensorData = await ingestSensorData(asset);
      const processData = await ingestProcessData(asset);
      
      // Detect anomalies vs contextual baselines
      const anomalies = await detectAnomalies(sensorData, processData, asset);
      
      if (anomalies.length > 0) {
        // Estimate RUL and failure mode likelihood
        const rulEstimate = await estimateRemainingUsefulLife(asset, anomalies);
        const failureModes = await identifyFailureModes(anomalies, asset.type);
        
        // Generate alert with recommended actions
        const alert: PredictiveMaintenanceAlert = {
          assetId: asset.id,
          severity: rulEstimate.days < 7 ? 'critical' : 
                   rulEstimate.days < 30 ? 'warning' : 'info',
          remainingUsefulLife: rulEstimate.days,
          confidenceInterval: rulEstimate.confidenceInterval,
          rootCause: failureModes[0]?.description || 'Unknown',
          recommendedActions: await generateRecommendedActions(failureModes, asset),
          workOrderPriority: calculateWorkOrderPriority(rulEstimate, asset.criticality)
        };
        
        alerts.push(alert);
      }
    } catch (error) {
      console.error(`Error monitoring asset ${asset.id}:`, error);
      // Continue monitoring other assets
    }
  }
  
  return alerts;
}

export async function integrateWithCMMS(
  alerts: PredictiveMaintenanceAlert[],
  cmmsSystem: 'SAP_PM' | 'Maximo'
): Promise<WorkOrder[]> {
  const workOrders: WorkOrder[] = [];
  
  for (const alert of alerts) {
    try {
      // Draft inspection/work order with parts list and priority
      const workOrder = await createWorkOrder(alert, cmmsSystem);
      
      // Auto-generate prioritized notifications aligned to RUL and maintenance windows
      await scheduleWorkOrder(workOrder, alert.remainingUsefulLife);
      
      workOrders.push(workOrder);
    } catch (error) {
      console.error(`Failed to create work order for alert ${alert.assetId}:`, error);
    }
  }
  
  return workOrders;
}

// Decision-Making Workflows
export async function prioritizeAssets(
  assets: Asset[],
  productionPlan: ProductionPlan,
  safetyRisks: SafetyRisk[]
): Promise<Asset[]> {
  // Focus on top 20-40% high-impact assets
  const scoredAssets = assets.map(asset => ({
    ...asset,
    impactScore: calculateImpactScore(asset, productionPlan, safetyRisks)
  }));
  
  // Sort by impact score and take top 40%
  const sortedAssets = scoredAssets.sort((a, b) => b.impactScore - a.impactScore);
  const topAssets = sortedAssets.slice(0, Math.ceil(assets.length * 0.4));
  
  return topAssets;
}

export async function makeMaintenanceDecision(
  alert: PredictiveMaintenanceAlert,
  maintenanceWindows: MaintenanceWindow[],
  spareParts: SparePart[]
): Promise<MaintenanceDecision> {
  // Evaluate maintenance timing options
  const urgency = alert.severity === 'critical' ? 'immediate' :
                 alert.remainingUsefulLife < 14 ? 'urgent' : 'planned';
  
  // Check spare parts availability
  const requiredParts = await identifyRequiredParts(alert);
  const partsAvailable = requiredParts.every(part => 
    spareParts.some(spare => spare.partNumber === part.partNumber && spare.quantity > 0)
  );
  
  // Find optimal maintenance window
  const optimalWindow = await findOptimalMaintenanceWindow(
    alert.remainingUsefulLife,
    maintenanceWindows,
    urgency
  );
  
  return {
    alertId: alert.assetId,
    decision: urgency === 'immediate' ? 'emergency_maintenance' : 'scheduled_maintenance',
    scheduledDate: optimalWindow?.startDate,
    requiredParts,
    estimatedDuration: await estimateMaintenanceDuration(alert.rootCause),
    riskAssessment: await assessMaintenanceRisk(alert, optimalWindow)
  };
}

export async function optimizeMaintenanceStrategy(
  customer: Customer,
  performanceMetrics: PerformanceMetrics
): Promise<MaintenanceStrategy> {
  // Analyze historical performance and adjust thresholds
  const analysis = await analyzeMaintenancePerformance(performanceMetrics);
  
  // Optimize alert thresholds to reduce false positives
  if (analysis.falsePositiveRate > 0.02) {
    await adjustAlertThresholds(customer.assets, analysis);
  }
  
  // Recommend changes to maintenance intervals
  const intervalRecommendations = await optimizeMaintenanceIntervals(
    customer.assets,
    analysis.mtbfData
  );
  
  return {
    customerId: customer.id,
    optimizedThresholds: analysis.recommendedThresholds,
    intervalAdjustments: intervalRecommendations,
    expectedImprovements: {
      downtimeReduction: analysis.projectedDowntimeReduction,
      costSavings: analysis.projectedCostSavings,
      falsePositiveReduction: analysis.projectedFalsePositiveReduction
    }
  };
}

// Utility functions (would be implemented separately)
async function conductTechnicalAssessment(lead: Lead): Promise<TechnicalAssessment> {
  // Implementation would assess plant infrastructure, data availability, etc.
  throw new Error('Not implemented');
}

async function generateProposal(lead: Lead, assessment: TechnicalAssessment): Promise<Proposal> {
  // Implementation would create customized proposal based on assessment
  throw new Error('Not implemented');
}

async function negotiateContract(proposal: Proposal): Promise<Contract> {
  // Implementation would handle contract negotiation workflow
  throw new Error('Not implemented');
}

async function onboardCustomer(lead: Lead, contract: Contract): Promise<Customer> {
  // Implementation would handle customer onboarding process
  throw new Error('Not implemented');
}

// Additional type definitions would be defined in separate files
interface ContactInfo {
  name: string;
  email: string;
  phone: string;
  title: string;
}

interface DowntimeEvent {
  date: Date;
  duration: number;
  cause: string;
  cost: number;
}

interface ExistingSystems {
  historian: boolean;
  cmms: boolean;
  vibrationMonitoring: boolean;
}

interface Contract {
  id: string;
  startDate: Date;
  duration: number;
  value: number;
  managedServices: boolean;
}

interface OnboardingStatus {
  status: 'new' | 'in_progress' | 'complete';
  completionPercentage: number;
}

interface AssetSpecs {
  manufacturer: string;
  model: string;
  capacity: number;
  operatingConditions: OperatingConditions;
}

interface Sensor {
  id: string;
  type: 'vibration' | 'temperature' | 'pressure' | 'current';
  location: string;
  calibrationDate: Date;
}

interface MaintenanceRecord {
  date: Date;
  type: string;
  description: string;
  cost: number;
  partsReplaced: string[];
}

interface SensorData {
  timestamp: Date;
  sensorId: string;
  value: number;
  unit: string;
}

interface OperatingConditions {
  temperature: number;
  pressure: number;
  flowRate: number;
  viscosity: number;
}

interface PredictiveModel {
  id: string;
  assetType: Asset['type'];
  accuracy: number;
  lastTrained: Date;
}

interface ProcessConditions {
  batchId: string;
  recipe: string;
  startTime: Date;
  endTime: Date;
}

interface OperatingMode {
  id: string;
  name: string;
  duration: number;
  characteristics: Record<string, number>;
}

interface RevenueStream {
  type: string;
  amount: number;
  frequency: string;
  description: string;
}

interface WorkOrder {
  id: string;
  assetId: string;
  priority: number;
  description: string;
  scheduledDate: Date;
  estimatedDuration: number;
}

interface ProductionPlan {
  schedules: ProductionSchedule[];
  priorities: string[];
}

interface ProductionSchedule {
  assetId: string;
  startTime: Date;
  endTime: Date;
  product: string;
}

interface SafetyRisk {
  assetId: string;
  riskLevel: 'high' | 'medium' | 'low';
  description: string;
}

interface MaintenanceWindow {
  startDate: Date;
  endDate: Date;
  availability: 'available' | 'reserved' | 'unavailable';
}

interface SparePart {
  partNumber: string;
  description: string;
  quantity: number;
  leadTime: number;
}

interface MaintenanceDecision {
  alertId: string;
  decision: string;
  scheduledDate?: Date;
  requiredParts: SparePart[];
  estimatedDuration: number;
  riskAssessment: RiskAssessment;
}

interface RiskAssessment {
  level: 'low' | 'medium' | 'high';
  factors: string[];
  mitigation: string[];
}

interface PerformanceMetrics {
  downtimeReduction: number;
  falsePositiveRate: number;
  mtbfData: MTBFData[];
  costSavings: number;
}

interface MTBFData {
  assetId: string;
  meanTimeBetweenFailures: number;
  trend: 'improving' | 'stable' | 'declining';
}

interface MaintenanceStrategy {
  customerId: string;
  optimizedThresholds: Record<string, number>;
  intervalAdjustments: IntervalAdjustment[];
  expectedImprovements: ExpectedImprovements;
}

interface IntervalAdjustment {
  assetId: string;
  currentInterval: number;
  recommendedInterval: number;
  rationale: string;
}

interface ExpectedImprovements {
  downtimeReduction: number;
  costSavings: number;
  falsePositiveReduction: number;
}

interface TechnicalAssessment {
  infrastructureScore: number;
  dataQuality: number;
  integrationComplexity: number;
  recommendations: string[];
}

interface Proposal {
  id: string;
  customerId: string;
  scope: string[];
  pricing: PricingStructure;
  timeline: ProjectTimeline;
}

interface PricingStructure {
  setupFee: number;
  monthlyFee: number;
  performanceBonus: number;
}

interface ProjectTimeline {
  phases: ProjectPhase[];
  totalDuration: number;
}

interface ProjectPhase {
  name: string;
  duration: number;
  deliverables: string[];
}
```
