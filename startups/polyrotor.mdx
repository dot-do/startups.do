---
name: Polyrotor
slug: polyrotor
naics:
  primary: "325212"
  occupations: []
service:
  title: Polymer-Specific Predictive Maintenance for Rotating Equipment
  description: >-
    Domain-specific predictive maintenance for polymerization and finishing units that reduces unplanned rotating-equipment downtime by 30–40%, detects faults 7–30 days earlier, and delivers calibrated Remaining Useful Life (RUL) with <20% mean absolute error.
  targetUsers:
    - Reliability Engineers
    - Rotating Equipment Specialists
    - Vibration Analysts
    - Maintenance Planners
    - Control Room Supervisors
  triggers:
    - Daily automated health scoring
    - Process condition changes in batch/transient cycles
    - Vibration anomaly detection
    - User-initiated asset health checks
  inputs:
    - Multi-signal data (vibration, process, electrical) from historian
    - Online monitor data and Class I Div 2/Zone 2 wireless sensors
    - Operating mode context for batch/transient cycles
    - Historical failure and maintenance records
  steps:
    - Ingest and validate multi-signal telemetry data
    - Apply operating-mode segmentation for batch/transient conditions
    - Execute hybrid physics + ML models tailored for polymer service
    - Generate asset health scores and RUL predictions with confidence intervals
    - Provide root-cause suggestions and corrective action recommendations
    - Auto-generate prioritized CMMS notifications/work orders
  tools:
    - OSIsoft/AVEVA PI or Honeywell PHD historian
    - SAP PM/Maximo CMMS integration
    - Class I Div 2/Zone 2 wireless sensor networks
    - Physics-informed ML models
    - Criticality mapping and dynamic prioritization
  outputs:
    - Per-asset health scores and failure mode predictions
    - Remaining Useful Life estimates with confidence intervals
    - Prioritized work orders aligned to maintenance windows
    - Root-cause analysis and recommended corrective actions
    - KPI dashboards for reliability performance tracking
  pricingModel:
    - Annual SaaS subscription per monitored asset ($1,000–$3,000/asset/year)
    - Implementation and integration fee ($50,000–$200,000 per site)
    - Optional managed services ($5,000–$20,000/month/site)
    - Performance-linked upside tied to verified avoided downtime
  humanInLoop: true
  feasibility:
    remoteOnLaptop: 4
    modelCapability: 4
    overall: 4
  risks:
    - Polymer service conditions increase false alarm rates
    - Integration complexity with legacy historian/CMMS systems
    - Change management resistance from reliability teams
    - Model drift due to varying operating conditions
  dependencies:
    - Historian data access and quality
    - CMMS integration capabilities
    - Wireless sensor deployment permissions
    - Reliability team training and adoption
leanCanvas:
  problem:
    - "Unplanned failures of pumps, compressors, and gearboxes in polymerization/finishing cause high-cost outages ($30k–$150k per hour lost contribution margin, depending on unit)."
    - "Polymer service is harsh: variable viscosity, fouling, solids, and batch/transient operation increase false alarms in generic PdM and mask early-stage faults (seal wear, cavitation, bearing spall, gearbox tooth damage)."
    - "Existing condition monitoring is fragmented (route-based vibration, OEM tools, historian trends) and not fused into actionable, prioritized work orders with RUL estimates."
    - "Reliability teams are stretched; senior analysts are scarce. Plants struggle to maintain PdM program coverage across 200–600 rotating assets per site."
    - "Safety and compliance risk: mechanical seal failures in monomers (butadiene, styrene, acrylonitrile) can trigger flaring, emissions, or PSM events."
    - "ROI uncertainty: leadership hesitates without clear KPIs, baselines, and guaranteed payback from pilots."
  solution:
    - "Ingest multi-signal data (vibration, process, electrical) from historian and online monitors; augment with Class I Div 2/Zone 2 wireless sensors where gaps exist."
    - "Hybrid physics + ML models tailored for polymer service (cavitation/fouling-aware pump models, compressor surge/valve wear, gearbox load variability) with operating-mode segmentation for batch/transient cycles."
    - "Asset health scoring and RUL predictions with confidence intervals; root-cause suggestions and recommended corrective actions tied to spare parts and job plans."
    - "CMMS integration (SAP PM/Maximo) to auto-generate prioritized notifications/work orders with lead time aligned to RUL and maintenance windows."
    - "Criticality mapping to focus on the top 20–40% high-impact assets; dynamic prioritization by production plan and safety criticality."
    - "Operational workflow: 90-day proof-of-value on 20–40 assets → scale to 150–250 assets/site in 12 months, including change management and skills transfer to in-house teams."
  uniqueValueProp: "Domain-specific predictive maintenance for polymerization and finishing units that reduces unplanned rotating-equipment downtime by 30–40%, detects faults 7–30 days earlier, and delivers calibrated Remaining Useful Life (RUL) with <20% mean absolute error—seamlessly integrated with plant historian and CMMS to trigger the right work at the right time."
  unfairAdvantage: "Validated polymer-service failure library and operating-mode-aware models that materially reduce false alarms in batch/transient conditions; deep integrations to historian/CMMS enabling automated, prioritized work orders; and early reference sites in synthetic rubber creating a data moat and domain credibility."
  customerSegments:
    - "Primary economic buyers: Plant Managers and Reliability/Maintenance Directors at synthetic rubber plants (SBR, BR, NBR, EPDM) in North America (NAICS 325212)."
    - "Primary users: Reliability engineers, rotating equipment specialists, vibration analysts, maintenance planners, and control room supervisors."
    - "Influencers: EHS/PSM managers (spill/emissions avoidance), Operations Managers (runtime stability), Procurement/IT/OT Security."
    - "Early adopters profile: Plants with OSIsoft/AVEVA PI or Honeywell PHD historian, SAP PM/Maximo CMMS, at least 20–80 critical rotating assets, and recent unplanned downtime events (>1 major event in past 12 months)."
  channels:
    - "Direct enterprise sales to Reliability/Maintenance leadership at NA synthetic rubber plants."
    - "Channel partners: rotating equipment OEMs (Flowserve, Sulzer, Howden), vibration vendors (SKF, Emerson, Wilcoxon), and industrial SIs with ISA/IEC certifications."
    - "Industry associations/events: IISRP meetings, Rubber Division ACS, AIChE Spring Meeting, Reliability conferences (SMRP)."
    - "Content marketing: polymer-service PdM whitepapers, failure-mode guides, and case studies; webinars co-hosted with OEMs and SIs."
    - "Pilot-led motions: 90-day proof-of-value with success-based pricing and executive readout tied to ROI."
    - "Land-and-expand: start in polymerization/finishing, then extend to utilities (cooling water, vacuum systems) and adjacent units."
  revenueStreams:
    - "Annual SaaS subscription per monitored asset (tiered): $1,000–$3,000/asset/year depending on criticality and data depth."
    - "Enterprise/site license discounts beyond 200 assets; multi-site agreements for corporate procurement."
    - "Implementation and integration fee: $50,000–$200,000 per site (data connectors, model tuning, CMMS integration, onboarding)."
    - "Optional managed services: remote vibration/ PdM analyst support $5,000–$20,000/month/site."
    - "Hardware pass-through or lease: Class I Div 2 sensors and gateways where needed ($300–$800/asset, $2,000–$5,000/gateway)."
    - "Performance-linked upside: bonus tied to verified avoided downtime or maintenance cost reduction beyond threshold (e.g., 10% of verified savings above baseline)."
  costStructure:
    - "COGS per asset (steady state): cloud/compute $3–$10/asset/month; data egress/ingest $1–$3/asset/month; support $2–$5/asset/month."
    - "Initial hardware (where needed): $300–$800/asset sensors; $2,000–$5,000 per gateway; installation $150–$300/asset."
    - "Personnel: ML engineers, data engineers, reliability SMEs (rotating), field engineers, customer success; fully loaded cost $180k–$240k per senior FTE/year."
    - "Sales and marketing: enterprise sales cycles 6–12 months; CAC target <$150k/site with multi-year payback."
    - "Compliance and security: ISA/IEC 62443 assessments, SOC 2 Type II, vendor qualification costs."
    - "R&D: physics-informed models, operating-mode segmentation, and false-alarm reduction; ongoing model validation/resources ~15–20% of revenue."
  keyMetrics:
    - "Business impact: unplanned downtime reduction (%) with target 30–40% on monitored critical assets; avoided downtime $ per quarter; maintenance cost reduction 10–20%."
    - "Reliability KPIs: MTBF increase 15–25%; mean time to detect (MTTD) <24 hours from onset; mean time to act (MTTA) aligned to planned window."
    - "Model performance: RUL MAE <20%; early warning lead time median ≥14 days for bearing/seal faults; precision ≥85%, recall ≥75% on labeled events; false positive rate <2% per asset-month."
    - "Adoption: % of critical assets onboarded (>80% in 12 months/site); weekly active users; % alerts converted to CMMS work orders (>70%)."
    - "Change management: time-to-first-value <45 days; training completion rates; NPS ≥50 from reliability users."
    - "Sales metrics: pilot win rate >40%; pilot-to-scale conversion >60%; ARR per site $250k–$750k at scale."
storyBrand:
  character: "Reliability and Maintenance Directors at synthetic rubber plants"
  problem: "Unplanned rotating equipment failures causing costly outages and safety risks"
  guide: "Domain-specific predictive maintenance AI tailored for polymer service conditions"
  plan: "Pilot → Integrate → Scale across critical rotating assets"
  callToAction: "Start 90-day proof-of-value pilot"
  success: "30-40% downtime reduction with early fault detection"
  failure: "Continued reactive maintenance and costly emergency repairs"
---

# Polyrotor Business Processes

## Customer Acquisition Workflows

```typescript
interface Lead {
  company: string;
  plantLocation: string;
  contactRole: 'Plant Manager' | 'Reliability Director' | 'Maintenance Manager';
  assetCount: number;
  historian: 'OSIsoft PI' | 'Honeywell PHD' | 'Other' | 'None';
  cmms: 'SAP PM' | 'Maximo' | 'Other' | 'None';
  recentDowntime: boolean;
  source: 'Direct' | 'Partner' | 'Event' | 'Content' | 'Referral';
}

interface QualifiedLead extends Lead {
  qualificationScore: number;
  painPoints: string[];
  budget: number;
  timeline: string;
  decisionMakers: string[];
}

interface Customer {
  id: string;
  contractValue: number;
  assetCount: number;
  pilotAssets: number;
  goLiveDate: Date;
  successMetrics: string[];
}

export async function acquireCustomer(lead: Lead): Promise<Customer> {
  const qualifiedLead = await qualifyLead(lead);
  const proposal = await generateProposal(qualifiedLead);
  const pilot = await conductPilot(proposal);
  const contract = await negotiateContract(pilot);
  return await onboardCustomer(contract);
}

async function qualifyLead(lead: Lead): Promise<QualifiedLead> {
  const qualificationScore = calculateQualificationScore(lead);
  
  if (qualificationScore < 70) {
    throw new Error('Lead does not meet qualification criteria');
  }
  
  const painPoints = await identifyPainPoints(lead);
  const budget = await estimateBudget(lead);
  const timeline = await assessTimeline(lead);
  const decisionMakers = await mapDecisionMakers(lead);
  
  return {
    ...lead,
    qualificationScore,
    painPoints,
    budget,
    timeline,
    decisionMakers
  };
}

async function generateProposal(qualifiedLead: QualifiedLead): Promise<Proposal> {
  const assetPrioritization = await prioritizeCriticalAssets(qualifiedLead);
  const pilotScope = await definePilotScope(assetPrioritization);
  const roi = await calculateROI(qualifiedLead, pilotScope);
  const timeline = await createImplementationTimeline(pilotScope);
  
  return {
    pilotScope,
    roi,
    timeline,
    pricing: calculatePricing(pilotScope),
    successMetrics: defineSuccessMetrics(qualifiedLead)
  };
}

async function conductPilot(proposal: Proposal): Promise<PilotResults> {
  await deployDataConnectors(proposal.pilotScope);
  await installSensors(proposal.pilotScope);
  await trainModels(proposal.pilotScope);
  await integrateWithCMMS(proposal.pilotScope);
  
  const results = await measurePilotResults(proposal.pilotScope, 90);
  await generateExecutiveReadout(results);
  
  return results;
}
```

## Product Development Processes

```typescript
interface FailureMode {
  type: 'Seal Wear' | 'Cavitation' | 'Bearing Spall' | 'Gearbox Tooth Damage' | 'Fouling';
  equipment: 'Pump' | 'Compressor' | 'Gearbox';
  polymerService: boolean;
  signatures: string[];
  leadTime: number;
}

interface Model {
  id: string;
  type: 'Physics' | 'ML' | 'Hybrid';
  failureMode: FailureMode;
  accuracy: number;
  falsePositiveRate: number;
  trainingData: string[];
}

export async function developPolymerSpecificModel(failureMode: FailureMode): Promise<Model> {
  const trainingData = await collectPolymerServiceData(failureMode);
  const physicsModel = await buildPhysicsInformedModel(failureMode);
  const mlModel = await trainMLModel(trainingData, failureMode);
  const hybridModel = await combineModels(physicsModel, mlModel);
  
  const validatedModel = await validateModel(hybridModel, failureMode);
  await deployModel(validatedModel);
  
  return validatedModel;
}

async function collectPolymerServiceData(failureMode: FailureMode): Promise<string[]> {
  const historicalFailures = await queryFailureDatabase(failureMode);
  const operatingModes = await identifyBatchTransientCycles();
  const processConditions = await extractProcessContext(historicalFailures);
  
  return await augmentWithPolymerServiceContext(
    historicalFailures,
    operatingModes,
    processConditions
  );
}

async function buildPhysicsInformedModel(failureMode: FailureMode): Promise<PhysicsModel> {
  switch (failureMode.type) {
    case 'Cavitation':
      return await buildCavitationModel(failureMode);
    case 'Fouling':
      return await buildFoulingModel(failureMode);
    case 'Seal Wear':
      return await buildSealWearModel(failureMode);
    default:
      return await buildGenericPhysicsModel(failureMode);
  }
}

export async function reducePolymerServiceFalseAlarms(): Promise<void> {
  const operatingModes = await segmentOperatingModes();
  const batchCycles = await identifyBatchCycles();
  const transientConditions = await detectTransientConditions();
  
  await updateModelFilters(operatingModes, batchCycles, transientConditions);
  await retrainModelsWithContext();
  await validateFalseAlarmReduction();
}
```

## Revenue Generation Flows

```typescript
interface Asset {
  id: string;
  type: 'Pump' | 'Compressor' | 'Gearbox';
  criticality: 'High' | 'Medium' | 'Low';
  productionImpact: number;
  subscriptionTier: 'Basic' | 'Premium' | 'Enterprise';
}

interface Site {
  id: string;
  assets: Asset[];
  contractType: 'Pilot' | 'Scale' | 'Enterprise';
  arr: number;
  implementationFee: number;
  managedServices: boolean;
}

export async function generateRevenue(site: Site): Promise<number> {
  const subscriptionRevenue = await calculateSubscriptionRevenue(site);
  const implementationRevenue = await calculateImplementationRevenue(site);
  const managedServicesRevenue = await calculateManagedServicesRevenue(site);
  const performanceBonus = await calculatePerformanceBonus(site);
  
  return subscriptionRevenue + implementationRevenue + managedServicesRevenue + performanceBonus;
}

async function calculateSubscriptionRevenue(site: Site): Promise<number> {
  let totalRevenue = 0;
  
  for (const asset of site.assets) {
    const basePrice = getAssetBasePrice(asset);
    const criticalityMultiplier = getCriticalityMultiplier(asset.criticality);
    const tierMultiplier = getTierMultiplier(asset.subscriptionTier);
    
    totalRevenue += basePrice * criticalityMultiplier * tierMultiplier;
  }
  
  const volumeDiscount = calculateVolumeDiscount(site.assets.length);
  return totalRevenue * (1 - volumeDiscount);
}

async function calculatePerformanceBonus(site: Site): Promise<number> {
  const baselineDowntime = await getBaselineDowntime(site);
  const actualDowntime = await getCurrentDowntime(site);
  const downtimeReduction = baselineDowntime - actualDowntime;
  
  if (downtimeReduction > 0.1) { // 10% threshold
    const verifiedSavings = await calculateVerifiedSavings(downtimeReduction, site);
    return verifiedSavings * 0.1; // 10% of verified savings
  }
  
  return 0;
}

export async function expandRevenue(customer: Customer): Promise<void> {
  const additionalAssets = await identifyExpansionOpportunities(customer);
  const utilitiesAssets = await assessUtilitiesExpansion(customer);
  const adjacentUnits = await evaluateAdjacentUnits(customer);
  
  await proposeExpansion(additionalAssets, utilitiesAssets, adjacentUnits);
}
```

## Operational Procedures

```typescript
interface Alert {
  assetId: string;
  failureMode: string;
  riskScore: number;
  rul: number;
  confidence: number;
  rootCause: string;
  recommendations: string[];
}

interface WorkOrder {
  id: string;
  assetId: string;
  priority: 'Critical' | 'High' | 'Medium' | 'Low';
  plannedDate: Date;
  estimatedDuration: number;
  spareParts: string[];
  skills: string[];
}

export async function processAlert(alert: Alert): Promise<WorkOrder | null> {
  const validated = await validateAlert(alert);
  if (!validated) return null;
  
  const prioritized = await prioritizeAlert(alert);
  const workOrder = await generateWorkOrder(prioritized);
  const scheduled = await scheduleWorkOrder(workOrder);
  
  await notifyStakeholders(scheduled);
  return scheduled;
}

async function validateAlert(alert: Alert): Promise<boolean> {
  const historicalContext = await getHistoricalContext(alert.assetId);
  const operatingMode = await getCurrentOperatingMode(alert.assetId);
  const processConditions = await getCurrentProcessConditions(alert.assetId);
  
  return await applyValidationRules(alert, historicalContext, operatingMode, processConditions);
}

async function prioritizeAlert(alert: Alert): Promise<Alert> {
  const productionImpact = await calculateProductionImpact(alert.assetId);
  const safetyRisk = await assessSafetyRisk(alert.assetId, alert.failureMode);
  const maintenanceWindow = await getNextMaintenanceWindow(alert.assetId);
  
  const adjustedPriority = calculateDynamicPriority(
    alert.riskScore,
    productionImpact,
    safetyRisk,
    alert.rul,
    maintenanceWindow
  );
  
  return { ...alert, riskScore: adjustedPriority };
}

export async function executeMaintenanceWorkflow(workOrder: WorkOrder): Promise<void> {
  await reserveSpareParts(workOrder.spareParts);
  await scheduleSkills(workOrder.skills);
  await coordinateShutdown(workOrder.assetId);
  
  const maintenanceResults = await executeWork(workOrder);
  await updateAssetHistory(workOrder.assetId, maintenanceResults);
  await measureOutcome(workOrder, maintenanceResults);
  
  await updateModels(workOrder.assetId, maintenanceResults);
}
```

## Decision-Making Workflows

```typescript
interface Decision {
  type: 'Asset Priority' | 'Model Deployment' | 'Alert Threshold' | 'Expansion';
  context: any;
  options: any[];
  criteria: string[];
  stakeholders: string[];
}

interface DecisionResult {
  selectedOption: any;
  rationale: string;
  confidence: number;
  reviewDate: Date;
}

export async function makeAssetPrioritizationDecision(
  assets: Asset[],
  constraints: any
): Promise<DecisionResult> {
  const criteria = [
    'Production Impact',
    'Safety Risk',
    'Maintenance Cost',
    'Data Quality',
    'ROI Potential'
  ];
  
  const scoredAssets = await scoreAssets(assets, criteria);
  const optimizedSelection = await optimizeAssetSelection(scoredAssets, constraints);
  
  return {
    selectedOption: optimizedSelection,
    rationale: generateRationale(optimizedSelection, criteria),
    confidence: calculateConfidence(optimizedSelection),
    reviewDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000) // 90 days
  };
}

export async function makeModelDeploymentDecision(
  model: Model,
  site: Site
): Promise<DecisionResult> {
  const performanceMetrics = await evaluateModelPerformance(model);
  const businessImpact = await estimateBusinessImpact(model, site);
  const riskAssessment = await assessDeploymentRisk(model, site);
  
  const shouldDeploy = await evaluateDeploymentCriteria(
    performanceMetrics,
    businessImpact,
    riskAssessment
  );
  
  if (shouldDeploy) {
    await deployModelToProduction(model, site);
  }
  
  return {
    selectedOption: shouldDeploy ? 'Deploy' : 'Hold',
    rationale: generateDeploymentRationale(performanceMetrics, businessImpact, riskAssessment),
    confidence: calculateDeploymentConfidence(performanceMetrics),
    reviewDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days
  };
}

export async function makeExpansionDecision(
  customer: Customer,
  opportunities: any[]
): Promise<DecisionResult> {
  const customerHealth = await assessCustomerHealth(customer);
  const expansionReadiness = await evaluateExpansionReadiness(customer);
  const marketTiming = await assessMarketTiming();
  
  const prioritizedOpportunities = await prioritizeExpansionOpportunities(
    opportunities,
    customerHealth,
    expansionReadiness,
    marketTiming
  );
  
  return {
    selectedOption: prioritizedOpportunities[0],
    rationale: generateExpansionRationale(prioritizedOpportunities),
    confidence: calculateExpansionConfidence(customerHealth, expansionReadiness),
    reviewDate: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000) // 60 days
  };
}
```

export default function Page() {
  return (
    <>
      <Hero
        title="Predict polymer equipment failures before they happen"
        subtitle="Domain-specific predictive maintenance for polymerization and finishing units that reduces unplanned downtime by 30–40% with early fault detection."
        ctaText="Start 90-day pilot"
        ctaHref="/contact"
      />
      <Problem bullets={[
        "Unplanned pump, compressor, and gearbox failures cause $30k–$150k per hour in lost production",
        "Polymer service conditions create false alarms and mask early-stage faults",
        "Fragmented monitoring systems don't provide actionable, prioritized work orders",
        "Reliability teams struggle to cover 200–600 rotating assets per site",
        "Mechanical seal failures in monomers can trigger safety and compliance events"
      ]} />
      <Solution bullets={[
        "Hybrid physics + ML models tailored for polymer service conditions",
        "Operating-mode segmentation for batch/transient cycles reduces false alarms",
        "Asset health scoring with RUL predictions and confidence intervals",
        "Automated CMMS integration for prioritized work orders",
        "Focus on top 20–40% high-impact assets with dynamic prioritization"
      ]} />
      <Features items={[
        "Multi-signal data ingestion from historian and wireless sensors",
        "Polymer-specific failure mode detection (cavitation, fouling, seal wear)",
        "7–30 day early warning with <20% RUL error",
        "Root-cause analysis and corrective action recommendations",
        "SAP PM/Maximo integration for automated work orders",
        "Criticality mapping and production-aligned prioritization"
      ]} />
      <Steps steps={[
        "90-day proof-of-value on 20–40 assets",
        "Scale to 150–250 assets per site",
        "Expand to utilities and adjacent units"
      ]} />
    </>
  )
}
