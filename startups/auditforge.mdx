---
name: AuditForge
slug: auditforge
naics:
  primary: '513210'
  occupations: []
service:
  title: 'SBOM, License & OSS Compliance Auditor'
  description: >-
    Generates SBOMs, flags risky licenses and vulnerable dependencies, and
    proposes remediations with pull requests.
  targetUsers:
    - Security
    - Legal/Compliance
    - Engineering Managers
  triggers:
    - New PR or dependency update
    - Nightly/weekly scan
    - Release candidate
  inputs:
    - Source repo(s)
    - 'Package manifests (package.json, requirements.txt, go.mod, etc.)'
    - Container images (optional)
  steps:
    - 'Generate SBOM (manifest + image, if provided)'
    - Run license detection and map to policy
    - Query vulnerability databases for CVEs
    - 'Create report with risks, severities, and deadlines'
    - Propose remediation PRs (version bumps or replacements)
  tools:
    - Syft/Anchore SBOM
    - OSV API
    - Snyk API or Grype
    - FOSSA/Licensee/FOSSology
    - GitHub Dependabot
    - OpenAI API (summary)
  outputs:
    - SBOM (SPDX/CycloneDX)
    - Compliance report (Markdown/PDF)
    - Remediation PRs and tracker tickets
  pricingModel:
    - Monthly subscription (per repo)
    - Per-scan fee
    - Remediation success fee (per merged PR)
  humanInLoop: true
  feasibility:
    remoteOnLaptop: 10
    modelCapability: 8
    overall: 9
  risks:
    - False positives/negatives on licenses
    - Version bumps breaking builds
    - Policy misinterpretation without legal review
  dependencies:
    - Repo read and PR create permissions
    - Security tool credentials (optional)
leanCanvas:
  problem:
    - >-
      Buyers (enterprise/government) increasingly require SBOMs and license
      attestations; today generating accurate SBOMs takes 2–10 days per release
      and delays deals.
    - >-
      Legal risk from misclassified or unknown licenses (e.g., copyleft
      contamination) leads to costly rework; typical license reviews consume 2–8
      hours per release/product line.
    - >-
      Dependency vulnerabilities accumulate; 30–60% of repos carry known CVEs
      and remediation backlogs, with MTTR often >60 days.
    - >-
      Existing SCA/SBOM tools create noise and lack actionability; developers
      ignore alerts without auto-fix PRs and clear policy guidance.
    - >-
      SBOM quality varies (incomplete transitive deps, missing binaries,
      inconsistent SPDX/CycloneDX fields); auditors reject low-fidelity
      artifacts.
    - >-
      Multiple ecosystems (containers, OS packages, polyglot repos) and build
      systems complicate unified policy enforcement and reporting.
    - >-
      Leadership needs audit-ready evidence for SOC2/ISO/FedRAMP; current
      evidence collection is manual and brittle.
    - >-
      Regulatory pressure (e.g., US federal procurement SBOM expectations, EU
      CRA trajectory, FDA guidance) creates urgent but unclear requirements.
  solution:
    - >-
      One-click SBOM generation in SPDX and CycloneDX across source, containers,
      and OS packages; includes transitive and binary discovery.
    - >-
      License detection with a policy engine (allow/deny/conditional), risk
      scoring, and human-in-the-loop workflows for edge cases.
    - >-
      Unified vulnerability intelligence (OSV, NVD, distro feeds) with VEX
      ingestion to reduce noise and prioritize exploitable issues.
    - >-
      AI-generated remediation PRs that safely upgrade dependencies, suggest
      license-friendly alternatives, and include test/CI hints; impact
      simulation and rollback.
    - >-
      Policy-as-code gates in CI/CD (GitHub/GitLab/Azure DevOps/Bitbucket) with
      signed attestations (Sigstore) and SLSA provenance.
    - >-
      Audit-ready dashboards and exports (PDF/JSON/CSV/API) mapped to
      SOC2/ISO/NIST SSDF/FedRAMP controls; evidence trails per release.
  uniqueValueProp: >-
    From code to compliant SBOMs and auto-remediation PRs in minutes. Cut
    license and vulnerability risk by 60–80% while preserving developer
    velocity; generate signed, audit-ready artifacts on every build.
  unfairAdvantage: >-
    High-accuracy AI remediation PRs and license interpretations trained on a
    proprietary corpus of curated diffs and adjudicated license edge cases,
    combined with policy-as-code and signed attestations that slot directly into
    developer workflows. Network effects from cross-organization policy
    templates and feedback loops improve fix quality and acceptance over time.
  customerSegments:
    - >-
      Primary ICP: Software publishers (NAICS 513210) with 50–5,000 engineers
      selling to enterprise/government; polyglot stacks (Java, JS/TS, Python,
      Go, .NET).
    - >-
      SaaS vendors and ISVs in regulated sectors (fintech, healthcare, govtech,
      industrial/IoT) with formal vendor security questionnaires.
    - >-
      Device and embedded software makers needing component SBOMs and provenance
      across firmware/containers.
    - >-
      Open Source Program Offices (OSPOs) and legal/compliance teams accountable
      for license policy enforcement.
    - >-
      Systems integrators/MSSPs delivering secure SDLC and supply chain services
      to multiple clients.
  channels:
    - >-
      Developer-first distribution: verified GitHub Action and GitLab CI
      templates; goal: 2,000 installs in 6 months with 15% converting to trials.
    - >-
      Cloud marketplaces (AWS, Azure, GCP) to streamline procurement; target:
      30% of enterprise deals via marketplace within 12 months.
    - >-
      Partnerships with legal firms and audit providers; co-host quarterly OSS
      compliance clinics to source 50 qualified leads/quarter.
    - >-
      Content and SEO: SBOM playbooks, license policy templates, and sample PRs;
      target: 20k monthly organic visits by month 9, 3% signup conversion.
    - >-
      Events: OpenSSF Day, KubeCon, RSA DevSecOps track; target: 200 booth
      scans/event, 10% POC starts.
    - >-
      Outbound to vendors answering SBOM/security questionnaires; 200
      accounts/quarter with 5% meeting rate and 30% POC conversion.
    - >-
      Open-source goodwill: free tier for public repos and maintainers; sponsor
      5 key projects to seed dataset and brand trust.
  revenueStreams:
    - >-
      SaaS subscriptions: Starter $15/user/month (min $300/mo), Pro
      $50/user/month (min $1,500/mo) with AI PRs and governance, Enterprise
      $25k–$250k/yr based on repo count/users/compliance needs.
    - >-
      Usage-based add-ons: AI remediation PRs beyond plan quotas ($0.50–$2 per
      PR creation), high-frequency scan minutes, and long-term SBOM storage
      tiers.
    - >-
      Enterprise features: on-prem/air-gapped, SSO/SCIM, custom policy packs,
      premium support (Gold/Platinum), and dedicated SRE SLAs.
    - >-
      Professional services: policy workshops, legacy inventory backfills,
      migration from incumbent SCA tools (typical $10k–$75k per engagement).
    - Marketplace reseller channels with revenue share (10–20%).
    - Training and certification for OSS compliance champions ($499/person).
  costStructure:
    - >-
      Cloud compute and storage for scanning and SBOM retention (target COGS
      <20% of ARR; per-SBOM marginal cost <$0.05, AI PR <$0.30).
    - >-
      Model inference (GPU/accelerator) and vector search infra; cache to reduce
      token/compute spend by >40%.
    - >-
      Engineering and security research (dependency/OSINT analysts); initial
      team 10–15 FTE, scaling with ARR.
    - >-
      Sales & marketing (content, events, partner MDF); CAC target: $25k
      enterprise, $2k SMB.
    - >-
      Compliance and trust: SOC2/ISO audits, pen tests, bug bounty
      ($150k–$300k/yr).
    - >-
      Third-party data/licensing (optional commercial vuln intel, license text
      archives).
    - >-
      Customer support and success (ratios: 1 CSM per $2–3M ARR; 1 support
      engineer per 300 active customers).
  keyMetrics:
    - >-
      Time-to-value: first SBOM within 15 minutes; 80% of POCs producing signed
      SBOMs in week 1.
    - >-
      Coverage: % of org repos onboarded (target 70% in 90 days) and dependency
      coverage across ecosystems (>95% of top 20 ecosystems).
    - >-
      SBOM fidelity: completeness >98% of declared deps; false positive license
      rate <1%; average SBOM generation time <120s/repo.
    - >-
      Risk reduction: 60% reduction in critical/high vulns and license
      violations within 60 days; MTTR for criticals <14 days.
    - >-
      Actionability: AI remediation PR merge rate 30–50%; alert-to-fix ratio
      >0.6 within 30 days; policy-violating merges blocked to <1% of releases.
    - >-
      Reliability & cost: 99.9% API uptime; per-scan cost and per-PR cost
      trending down 10%/quarter.
    - >-
      Commercial: ARR, logo churn <5% annually, NRR >120%, sales cycle <90 days
      (enterprise) and <21 days (SMB).
    - >-
      Engagement: weekly active developers (WAD), SBOMs generated/week per
      account, NPS >40.
storyBrand:
  character: >-
    Software publishers (NAICS 513210): CTOs, engineering leaders, and
    security/compliance owners who must ship secure, license-compliant software
    without slowing releases.
  problem: >-
    External: Exploding OSS dependencies, risky/unclear licenses, CVEs, customer
    audits, and SBOM mandates.

    Internal: Manual reviews drain engineering time and create release anxiety.

    Philosophical: You shouldn’t have to choose between speed and compliance.
  guide: >-
    Empathy: We know release trains stall when security questionnaires and
    license reviews pile up.

    Authority: AI-driven analysis, native SPDX/CycloneDX SBOMs,
    OpenChain-aligned workflows, and deep VCS/CI integrations to make compliance
    continuous.
  plan: >-
    1) Connect: Link repos/CI and container registries.

    2) Assess: Auto-generate SBOMs, flag risky licenses/CVEs, map obligations.

    3) Remediate: Auto-propose fixes with pull requests, enforce policy gates,
    and export attestations/reports.
  callToAction: >-
    Direct: Start a trial or book a demo.

    Transitional: Get the OSS Compliance Checklist and a sample SBOM risk
    report.
  success: >-
    Continuous, audit-ready SBOMs for every build; faster releases with
    policy-backed guardrails; reduced legal exposure; shorter time-to-remediate;
    cleaner dependency trees; smoother security reviews and enterprise deals.
  failure: >-
    Missed license obligations, stalled releases, failed audits, breach exposure
    from unresolved CVEs, costly rework and legal disputes, and lost revenue due
    to blocked deals.
landingPage:
  hero:
    title: 'AI SBOM, License & OSS Compliance Auditor'
    subtitle: >-
      Generate SBOMs, flag risky licenses and vulnerabilities, and ship PR-based
      fixes—built for Software Publishers (NAICS 513210).
    ctaText: Start Free Scan
    ctaHref: /start
  problem:
    - 'Manual SBOM creation is slow, inconsistent, and quickly out of date.'
    - >-
      Risky licenses slip into releases and trigger legal exposure late in the
      cycle.
    - Vulnerability alerts are noisy and lack context or prioritization.
    - Fixing dependency issues across repos is tedious and error-prone.
    - >-
      Customers and auditors demand SBOMs and evidence you can’t produce
      instantly.
    - Release gates fail late due to hidden transitive dependencies.
    - Engineering time is lost chasing CVEs instead of shipping features.
  solution:
    - Automated SBOMs per commit and release in SPDX and CycloneDX formats.
    - License detection with policy enforcement and clear remediation guidance.
    - Exploitability-aware vulnerability triage with contextual prioritization.
    - >-
      One-click, AI-generated pull requests to upgrade, replace, or patch risky
      packages.
    - Continuous monitoring with CI/CD gates to prevent risky releases.
    - >-
      Audit-ready reports and change history for customers and compliance
      reviews.
    - >-
      Native integrations with GitHub, GitLab, Bitbucket, Azure DevOps, Jira,
      and Slack.
  features:
    - >-
      Instant SBOM generation (SPDX/CycloneDX) from source, lockfiles, and
      containers.
    - >-
      License policy enforcement (allow/deny), obligations, and compatibility
      checks.
    - >-
      AI PRs for safe upgrades, version pinning, and package replacements with
      summaries.
    - 'Prioritized alerts using severity, reachability, and exploit signals.'
    - Signed SBOMs and attestations for supply chain trust.
    - CI/CD quality gates with break/notify modes and per-project thresholds.
    - 'Policy-as-code with exceptions, approvals, and expiry windows.'
    - >-
      Language coverage: npm, PyPI, Maven/Gradle, Go, RubyGems, NuGet, Cargo,
      and more.
    - 'Repo, monorepo, and multi-repo workspace support.'
    - Private registries and vendored dependencies scanning.
    - 'Exportable, audit-ready reports (JSON, PDF) with evidence and timelines.'
    - SaaS or private cloud deployment options.
  steps:
    - >-
      Connect your repos and registries (GitHub, GitLab, Bitbucket, Azure
      DevOps).
    - Import or define your license and vulnerability policies.
    - 'Auto-generate SBOMs on every commit, PR, and release.'
    - Review prioritized issues with clear license obligations and CVE impact.
    - Approve AI-generated PRs to upgrade or replace risky dependencies.
    - Enforce gates in CI/CD and publish SBOMs to customers as needed.
    - Export audit-ready reports and maintain evidence automatically.
    - Monitor continuously—auto-close resolved items and track drift.
---

export interface Lead {
  id: string;
  company: string;
  email: string;
  source: 'github' | 'website' | 'event' | 'referral';
  repoCount?: number;
  techStack?: string[];
  complianceNeeds?: string[];
  createdAt: Date;
}

export interface Customer {
  id: string;
  company: string;
  plan: 'starter' | 'pro' | 'enterprise';
  repositories: Repository[];
  policies: PolicyConfig[];
  onboardedAt: Date;
  lastScanAt?: Date;
}

export interface Repository {
  id: string;
  name: string;
  url: string;
  language: string;
  lastSbomGenerated?: Date;
  vulnerabilityCount: number;
  licenseRiskScore: number;
}

export interface PolicyConfig {
  id: string;
  name: string;
  allowedLicenses: string[];
  blockedLicenses: string[];
  maxVulnerabilityScore: number;
  autoRemediation: boolean;
}

export interface SbomGenerationResult {
  sbomId: string;
  format: 'spdx' | 'cyclonedx';
  componentCount: number;
  vulnerabilities: Vulnerability[];
  licenseIssues: LicenseIssue[];
  generatedAt: Date;
  signedAttestation?: string;
}

export interface Vulnerability {
  id: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  component: string;
  fixAvailable: boolean;
  aiRemediationSuggested?: boolean;
}

export interface LicenseIssue {
  component: string;
  license: string;
  riskLevel: 'high' | 'medium' | 'low';
  recommendation: string;
}

export interface RemediationPR {
  id: string;
  repositoryId: string;
  title: string;
  description: string;
  changes: string[];
  testsPassing: boolean;
  mergeStatus: 'pending' | 'merged' | 'rejected';
  createdAt: Date;
}

// Customer Acquisition Workflows
export async function acquireCustomer(lead: Lead): Promise<Customer> {
  const qualifiedLead = await qualifyLead(lead);
  const demo = await scheduleDemoCall(qualifiedLead);
  const poc = await setupProofOfConcept(demo);
  const proposal = await generateProposal(poc);
  const contract = await negotiateContract(proposal);
  return await onboardCustomer(contract);
}

export async function qualifyLead(lead: Lead): Promise<Lead> {
  // Score lead based on company size, tech stack, compliance needs
  const complianceScore = await assessComplianceNeeds(lead);
  const techStackScore = await evaluateTechStack(lead.techStack || []);
  const repoComplexity = await estimateRepoComplexity(lead.repoCount || 0);
  
  if (complianceScore > 0.7 && techStackScore > 0.6) {
    await addToNurtureSequence(lead, 'qualified');
    return { ...lead, qualified: true };
  }
  
  await addToNurtureSequence(lead, 'unqualified');
  return lead;
}

export async function scheduleDemoCall(lead: Lead): Promise<{ lead: Lead; demoDate: Date }> {
  const availableSlots = await getAvailableDemoSlots();
  const demoLink = await generatePersonalizedDemo(lead);
  await sendDemoInvitation(lead, demoLink, availableSlots);
  
  return {
    lead,
    demoDate: availableSlots[0]
  };
}

export async function setupProofOfConcept(demo: { lead: Lead; demoDate: Date }): Promise<{ customer: Customer; pocRepos: Repository[] }> {
  const trialAccount = await createTrialAccount(demo.lead);
  const selectedRepos = await identifyPocRepositories(demo.lead, 3);
  const initialScan = await performInitialScan(selectedRepos);
  
  await sendPocWelcomeEmail(demo.lead, trialAccount, initialScan);
  
  return {
    customer: trialAccount,
    pocRepos: selectedRepos
  };
}

// Product Development Processes
export async function generateSbom(repository: Repository, format: 'spdx' | 'cyclonedx' = 'spdx'): Promise<SbomGenerationResult> {
  const dependencies = await scanDependencies(repository);
  const transitiveDeps = await resolveTransitiveDependencies(dependencies);
  const binaryComponents = await detectBinaryComponents(repository);
  
  const sbom = await buildSbom({
    repository,
    dependencies: [...dependencies, ...transitiveDeps, ...binaryComponents],
    format
  });
  
  const vulnerabilities = await scanVulnerabilities(sbom.components);
  const licenseIssues = await detectLicenseIssues(sbom.components);
  const attestation = await signSbom(sbom);
  
  return {
    sbomId: sbom.id,
    format,
    componentCount: sbom.components.length,
    vulnerabilities,
    licenseIssues,
    generatedAt: new Date(),
    signedAttestation: attestation
  };
}

export async function createRemediationPR(vulnerability: Vulnerability, repository: Repository): Promise<RemediationPR> {
  const fixStrategy = await analyzeFixStrategy(vulnerability);
  const codeChanges = await generateCodeChanges(fixStrategy);
  const testUpdates = await generateTestUpdates(codeChanges);
  
  const prBranch = await createBranch(repository, `fix/${vulnerability.id}`);
  await applyChanges(prBranch, [...codeChanges, ...testUpdates]);
  
  const ciResults = await runCiPipeline(prBranch);
  const prDescription = await generatePrDescription(vulnerability, fixStrategy, ciResults);
  
  const pr = await createPullRequest({
    repository,
    branch: prBranch,
    title: `Fix ${vulnerability.severity} vulnerability in ${vulnerability.component}`,
    description: prDescription
  });
  
  return {
    id: pr.id,
    repositoryId: repository.id,
    title: pr.title,
    description: pr.description,
    changes: codeChanges.map(c => c.summary),
    testsPassing: ciResults.success,
    mergeStatus: 'pending',
    createdAt: new Date()
  };
}

export async function enforcePolicyGates(repository: Repository, policies: PolicyConfig[]): Promise<{ passed: boolean; violations: string[] }> {
  const sbom = await generateSbom(repository);
  const violations: string[] = [];
  
  for (const policy of policies) {
    const licenseViolations = await checkLicensePolicy(sbom, policy);
    const vulnerabilityViolations = await checkVulnerabilityPolicy(sbom, policy);
    
    violations.push(...licenseViolations, ...vulnerabilityViolations);
  }
  
  if (violations.length > 0 && policies.some(p => p.autoRemediation)) {
    await triggerAutoRemediation(repository, violations);
  }
  
  return {
    passed: violations.length === 0,
    violations
  };
}

// Revenue Generation Flows
export async function convertTrialToSubscription(customer: Customer): Promise<{ success: boolean; subscription?: any }> {
  const usageMetrics = await calculateTrialUsage(customer);
  const recommendedPlan = await recommendSubscriptionPlan(usageMetrics);
  const pricing = await generateCustomPricing(customer, recommendedPlan);
  
  const proposal = await createSubscriptionProposal({
    customer,
    plan: recommendedPlan,
    pricing,
    usageMetrics
  });
  
  await sendSubscriptionProposal(customer, proposal);
  
  const decision = await trackProposalResponse(proposal, 14); // 14 day follow-up
  
  if (decision.accepted) {
    const subscription = await createSubscription(customer, proposal);
    await upgradeAccountLimits(customer, subscription.plan);
    return { success: true, subscription };
  }
  
  await addToNurtureSequence(customer, 'trial-expired');
  return { success: false };
}

export async function processUsageBilling(customer: Customer, month: Date): Promise<{ baseAmount: number; usageCharges: number; total: number }> {
  const baseSubscription = await getSubscriptionDetails(customer);
  const usageMetrics = await calculateMonthlyUsage(customer, month);
  
  const aiPrCharges = Math.max(0, usageMetrics.aiPrsCreated - baseSubscription.includedPrs) * 1.50;
  const scanMinuteCharges = Math.max(0, usageMetrics.scanMinutes - baseSubscription.includedMinutes) * 0.10;
  const storageCharges = Math.max(0, usageMetrics.sbomStorageGb - baseSubscription.includedStorage) * 0.05;
  
  const usageCharges = aiPrCharges + scanMinuteCharges + storageCharges;
  const total = baseSubscription.monthlyAmount + usageCharges;
  
  await generateInvoice(customer, {
    baseAmount: baseSubscription.monthlyAmount,
    usageCharges,
    total,
    period: month
  });
  
  return {
    baseAmount: baseSubscription.monthlyAmount,
    usageCharges,
    total
  };
}

// Operational Procedures
export async function onboardRepository(customer: Customer, repoUrl: string): Promise<Repository> {
  const repoMetadata = await analyzeRepository(repoUrl);
  const initialScan = await performComprehensiveScan(repoUrl);
  const policies = await getCustomerPolicies(customer);
  
  const repository: Repository = {
    id: generateId(),
    name: repoMetadata.name,
    url: repoUrl,
    language: repoMetadata.primaryLanguage,
    vulnerabilityCount: initialScan.vulnerabilities.length,
    licenseRiskScore: calculateLicenseRiskScore(initialScan.licenses)
  };
  
  await setupCiIntegration(repository, customer);
  await applyPolicyGates(repository, policies);
  await scheduleRecurringScan(repository, customer.plan);
  
  await notifyTeam(customer, `Repository ${repository.name} successfully onboarded`);
  
  return repository;
}

export async function generateComplianceReport(customer: Customer, framework: 'soc2' | 'iso27001' | 'fedramp'): Promise<{ reportId: string; downloadUrl: string }> {
  const repositories = await getCustomerRepositories(customer);
  const sboms = await getAllSboms(repositories);
  const vulnerabilityData = await aggregateVulnerabilityData(repositories);
  const policyCompliance = await assessPolicyCompliance(repositories);
  
  const reportData = {
    customer,
    framework,
    repositories: repositories.length,
    totalComponents: sboms.reduce((sum, sbom) => sum + sbom.componentCount, 0),
    criticalVulnerabilities: vulnerabilityData.critical,
    policyViolations: policyCompliance.violations,
    lastScanDate: Math.max(...repositories.map(r => r.lastScanAt?.getTime() || 0)),
    generatedAt: new Date()
  };
  
  const report = await generatePdfReport(reportData, framework);
  const downloadUrl = await uploadReportToSecureStorage(report);
  
  return {
    reportId: report.id,
    downloadUrl
  };
}

// Decision-Making Workflows
export async function prioritizeVulnerabilities(vulnerabilities: Vulnerability[]): Promise<Vulnerability[]> {
  const scoredVulnerabilities = await Promise.all(
    vulnerabilities.map(async (vuln) => {
      const exploitabilityScore = await assessExploitability(vuln);
      const businessImpactScore = await assessBusinessImpact(vuln);
      const fixComplexityScore = await assessFixComplexity(vuln);
      
      return {
        ...vuln,
        priorityScore: (exploitabilityScore * 0.4) + (businessImpactScore * 0.4) + (fixComplexityScore * 0.2)
      };
    })
  );
  
  return scoredVulnerabilities.sort((a, b) => b.priorityScore - a.priorityScore);
}

export async function evaluateLicenseRisk(component: string, license: string, policies: PolicyConfig[]): Promise<{ risk: 'high' | 'medium' | 'low'; recommendation: string }> {
  const licenseCompatibility = await checkLicenseCompatibility(license, policies);
  const copyleftRisk = await assessCopyleftRisk(license);
  const commercialUsageRisk = await assessCommercialUsageRisk(license);
  
  if (licenseCompatibility.blocked || copyleftRisk.high) {
    return {
      risk: 'high',
      recommendation: `Replace ${component} with alternative or obtain commercial license`
    };
  }
  
  if (copyleftRisk.medium || commercialUsageRisk.restrictions) {
    return {
      risk: 'medium',
      recommendation: `Review license obligations for ${component} before distribution`
    };
  }
  
  return {
    risk: 'low',
    recommendation: `${component} license ${license} is compatible with current policies`
  };
}

// Helper functions (pseudocode - would be implemented separately)
async function assessComplianceNeeds(lead: Lead): Promise<number> { return 0.8; }
async function evaluateTechStack(stack: string[]): Promise<number> { return 0.7; }
async function estimateRepoComplexity(count: number): Promise<number> { return Math.min(count / 100, 1); }
async function addToNurtureSequence(lead: Lead, sequence: string): Promise<void> {}
async function getAvailableDemoSlots(): Promise<Date[]> { return [new Date()]; }
async function generatePersonalizedDemo(lead: Lead): Promise<string> { return 'demo-link'; }
async function sendDemoInvitation(lead: Lead, link: string, slots: Date[]): Promise<void> {}
async function createTrialAccount(lead: Lead): Promise<Customer> { return {} as Customer; }
async function identifyPocRepositories(lead: Lead, count: number): Promise<Repository[]> { return []; }
async function performInitialScan(repos: Repository[]): Promise<any> { return {}; }
async function sendPocWelcomeEmail(lead: Lead, account: Customer, scan: any): Promise<void> {}
async function scanDependencies(repo: Repository): Promise<any[]> { return []; }
async function resolveTransitiveDependencies(deps: any[]): Promise<any[]> { return []; }
async function detectBinaryComponents(repo: Repository): Promise<any[]> { return []; }
async function buildSbom(config: any): Promise<any> { return { id: 'sbom-1', components: [] }; }
async function scanVulnerabilities(components: any[]): Promise<Vulnerability[]> { return []; }
async function detectLicenseIssues(components: any[]): Promise<LicenseIssue[]> { return []; }
async function signSbom(sbom: any): Promise<string> { return 'signed-attestation'; }
async function analyzeFixStrategy(vuln: Vulnerability): Promise<any> { return {}; }
async function generateCodeChanges(strategy: any): Promise<any[]> { return []; }
async function generateTestUpdates(changes: any[]): Promise<any[]> { return []; }
async function createBranch(repo: Repository, name: string): Promise<any> { return {}; }
async function applyChanges(branch: any, changes: any[]): Promise<void> {}
async function runCiPipeline(branch: any): Promise<{ success: boolean }> { return { success: true }; }
async function generatePrDescription(vuln: Vulnerability, strategy: any, ci: any): Promise<string> { return 'PR description'; }
async function createPullRequest(config: any): Promise<any> { return { id: 'pr-1', title: config.title, description: config.description }; }
async function checkLicensePolicy(sbom: any, policy: PolicyConfig): Promise<string[]> { return []; }
async function checkVulnerabilityPolicy(sbom: any, policy: PolicyConfig): Promise<string[]> { return []; }
async function triggerAutoRemediation(repo: Repository, violations: string[]): Promise<void> {}
async function calculateTrialUsage(customer: Customer): Promise<any> { return {}; }
async function recommendSubscriptionPlan(usage: any): Promise<string> { return 'pro'; }
async function generateCustomPricing(customer: Customer, plan: string): Promise<any> { return {}; }
async function createSubscriptionProposal(config: any): Promise<any> { return {}; }
async function sendSubscriptionProposal(customer: Customer, proposal: any): Promise<void> {}
async function trackProposalResponse(proposal: any, days: number): Promise<{ accepted: boolean }> { return { accepted: true }; }
async function createSubscription(customer: Customer, proposal: any): Promise<any> { return {}; }
async function upgradeAccountLimits(customer: Customer, plan: string): Promise<void> {}
async function getSubscriptionDetails(customer: Customer): Promise<any> { return { monthlyAmount: 1500, includedPrs: 100, includedMinutes: 1000, includedStorage: 10 }; }
async function calculateMonthlyUsage(customer: Customer, month: Date): Promise<any> { return { aiPrsCreated: 150, scanMinutes: 1200, sbomStorageGb: 15 }; }
async function generateInvoice(customer: Customer, details: any): Promise<void> {}
async function analyzeRepository(url: string): Promise<any> { return { name: 'repo', primaryLanguage: 'typescript' }; }
async function performComprehensiveScan(url: string): Promise<any> { return { vulnerabilities: [], licenses: [] }; }
async function getCustomerPolicies(customer: Customer): Promise<PolicyConfig[]> { return []; }
async function generateId(): string { return Math.random().toString(36); }
async function calculateLicenseRiskScore(licenses: any[]): number { return 0.3; }
async function setupCiIntegration(repo: Repository, customer: Customer): Promise<void> {}
async function applyPolicyGates(repo: Repository, policies: PolicyConfig[]): Promise<void> {}
async function scheduleRecurringScan(repo: Repository, plan: string): Promise<void> {}
async function notifyTeam(customer: Customer, message: string): Promise<void> {}
async function getCustomerRepositories(customer: Customer): Promise<Repository[]> { return []; }
async function getAllSboms(repos: Repository[]): Promise<any[]> { return []; }
async function aggregateVulnerabilityData(repos: Repository[]): Promise<any> { return { critical: 5 }; }
async function assessPolicyCompliance(repos: Repository[]): Promise<any> { return { violations: 2 }; }
async function generatePdfReport(data: any, framework: string): Promise<any> { return { id: 'report-1' }; }
async function uploadReportToSecureStorage(report: any): Promise<string> { return 'https://secure-storage/report-1.pdf'; }
async function assessExploitability(vuln: Vulnerability): Promise<number> { return 0.8; }
async function assessBusinessImpact(vuln: Vulnerability): Promise<number> { return 0.7; }
async function assessFixComplexity(vuln: Vulnerability): Promise<number> { return 0.6; }
async function checkLicenseCompatibility(license: string, policies: PolicyConfig[]): Promise<any> { return { blocked: false }; }
async function assessCopyleftRisk(license: string): Promise<any> { return { high: false, medium: false }; }
async function assessCommercialUsageRisk(license: string): Promise<any> { return { restrictions: false }; }

export default function Page() {
  return (
    <>
      <Hero
        title="From code to compliant SBOMs in minutes"
        subtitle="AI-powered supply chain security platform that generates audit-ready SBOMs and auto-remediation PRs while preserving developer velocity."
        ctaText="Start free trial"
        ctaHref="/trial"
      />
      <Problem bullets={[
        "SBOM generation takes 2-10 days per release, delaying deals",
        "License risks create legal exposure and costly rework",
        "30-60% of repos carry known vulnerabilities with 60+ day MTTR",
        "Existing tools create noise without actionable remediation",
        "Manual compliance evidence collection is brittle and time-consuming"
      ]} />
      <Solution bullets={[
        "One-click SBOM generation in SPDX/CycloneDX with 98% accuracy",
        "AI-powered remediation PRs with 40%+ merge rates",
        "Policy-as-code gates with signed attestations",
        "Unified vulnerability intelligence with noise reduction",
        "Audit-ready dashboards mapped to SOC2/ISO/FedRAMP controls"
      ]} />
      <Features items={[
        "Multi-ecosystem dependency scanning",
        "License detection and policy engine",
        "AI-generated remediation PRs",
        "CI/CD integration and policy gates",
        "Compliance reporting and attestations",
        "Vulnerability prioritization",
        "Supply chain risk scoring"
      ]} />
      <Steps steps={[
        "Connect repositories",
        "Generate SBOMs",
        "Deploy AI remediation",
        "Achieve compliance"
      ]} />
    </>
  )
}
