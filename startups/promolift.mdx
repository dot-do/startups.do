---
name: PromoLift
slug: promolift
naics:
  primary: '424450'
  occupations: []
leanCanvas:
  problem:
    - >-
      Trade spend lacks transparency: 20–40% of promotions underperform or
      destroy value because uplift and ROI aren't measured consistently at
      account/SKU level.
    - >-
      Wholesalers struggle to separate true incremental volume from
      forward-buying, cannibalization, and seasonality (e.g., Halloween, Easter,
      Valentine's) leading to misallocated budgets.
    - >-
      Display compliance and execution quality are opaque; discounts run without
      confirming that displays, secondary placements, or features were in place.
    - >-
      Pricing and promo depth decisions are often heuristic; no systematic
      next-best action by account/SKU based on elasticity and retailer
      behaviors.
    - >-
      Data is siloed (ERP invoices, EDI 852/867, DEX/scan, broker/audit reports)
      and slow to reconcile; post-event analysis arrives weeks later and misses
      re-buy windows.
    - >-
      Finance needs defensible ROI attribution to justify manufacturer co-op
      funds and negotiate better terms; current spreadsheet methods are not
      audit-ready.
    - >-
      Inventory and service levels during promos are volatile, causing
      out-of-stocks or costly carryover inventory after the event.
    - >-
      Sales teams need simple, retailer-ready promo sell sheets with evidence of
      expected incremental margin and category growth.
  solution:
    - >-
      Unify data: Ingest invoices/shipments (ERP), trade deals (TPM/finance),
      promotion calendars, EDI 852 (product activity), EDI 867 (POS and product
      transfer), and any audit/compliance data.
    - >-
      Causal uplift measurement: Use hierarchical Bayesian/causal inference to
      estimate incremental units vs. baseline, separating forward-buying,
      cannibalization, halo, and seasonality effects by account/SKU/week.
    - >-
      ROI and margin attribution: Tie uplift to gross-to-net waterfall (list,
      off-invoice, billbacks, scan, display fees) to compute cost per
      incremental unit and incremental gross profit ($ and %).
    - >-
      Next-best promotion: Recommend offer depth, duration, timing, and display
      type by account/SKU, given elasticity, shopper response patterns, and
      retailer calendars.
    - >-
      Budget and calendar optimizer: Constrained optimization to allocate trade
      budget across accounts/SKUs to maximize incremental gross profit subject
      to funding and execution constraints.
    - >-
      Scenario simulator: What-if analysis to test alternative depths, weeks,
      displays, and inventory plans with confidence intervals and stockout risk
      alerts.
    - >-
      Execution feedback loop: Track display compliance and on-shelf
      availability where data exists; auto-adjust expected ROI mid-promo;
      surface learnings into post-event scorecards.
    - >-
      Decision delivery: Retailer-ready sell sheets and dashboards; API/webhooks
      to push approved plans to ERP/TPM calendars and to sales enablement tools.
  uniqueValueProp: >-
    Measure the true incremental impact and ROI of discounts and displays at the
    account/SKU level and recommend the next-best promotion per account, so
    wholesalers shift trade dollars to high-yield events, defend co-op funding
    with evidence, and grow incremental gross profit within a single season.
  unfairAdvantage: >-
    A vertically specialized uplift and optimization engine for confectionery
    wholesalers that combines seasonality-aware models, EDI 852/867 ingestion at
    scale, and anonymized benchmarks of display and discount
    effectiveness—packaged with retailer-ready evidence and ERP/TPM integrations
    to operationalize decisions.
  customerSegments:
    - >-
      Primary: Mid-market to enterprise confectionery merchant wholesalers
      (revenue $50M–$3B+) serving grocery, convenience, drug, club, dollar, and
      specialty channels.
    - >-
      Key buyers: VP/Head of Sales, Director of Trade Marketing/Revenue
      Management, CFO/Finance, Category Management, DSD/Route Operations
      leadership.
    - >-
      Secondary influencers: Manufacturer broker partners, retail merchandising
      execution partners, and independent retailer groups buying through
      wholesalers.
    - >-
      Early adopters: Wholesalers with seasonal concentration and active
      displays, and those already exchanging EDI 852/867 or receiving POS feeds
      from larger retail accounts.
  channels:
    - >-
      Direct sales to top 200 US confectionery wholesalers; 3–6 month sales
      cycle targeting VP Sales/Trade Marketing and Finance.
    - >-
      Association-led demand: Sponsor and present at National Confectioners
      Association (NCA) and Convenience Distribution Association (CDA) events;
      run seasonal ROI clinics (pre-Halloween, pre-Easter).
    - >-
      Alliances: Referral/integration partnerships with ERP (Epicor, Infor,
      NetSuite, Microsoft partners), EDI VANs, and retail execution firms;
      co-market with brokers.
    - >-
      Account-based marketing: Targeted LinkedIn/email to revenue management and
      category leaders; offer a 90-day pilot focused on 3–5 accounts and 50–100
      SKUs around a seasonal event.
    - >-
      Thought leadership: Publish an annual Confectionery Trade ROI Benchmark
      (anonymized) and seasonal playbooks; webinar series with case studies.
    - >-
      Land-and-expand motion: Start with post-event ROI and next-best actions
      for a subset of accounts; expand to full budget optimization and
      multi-banner coverage within 2–3 quarters.
  revenueStreams:
    - >-
      SaaS subscription priced by scale (e.g., number of accounts x SKUs
      analyzed and data refresh frequency). Mid-market: $60k–$150k ARR;
      Enterprise: $200k–$500k ARR.
    - >-
      Implementation and data integration fee: $15k–$75k depending on connectors
      and data readiness.
    - >-
      Optional managed service (analyst support, quarterly business reviews,
      retailer sell sheet creation): $3k–$10k/month.
    - >-
      Performance accelerator: Bonus of 3–5% of incremental gross profit above
      an agreed baseline (optional, with audit).
    - >-
      Professional services: Custom dashboards, advanced optimization scenarios,
      and retailer-specific templates.
  costStructure:
    - >-
      Cloud infrastructure and MLOps (compute/storage), including model training
      and inference costs per customer.
    - >-
      Data engineering and support for ERP/EDI integrations; ongoing connector
      maintenance.
    - >-
      Data licensing where required (e.g., syndicated POS or
      execution/compliance feeds).
    - >-
      R&D: Data science, ML engineering, and domain experts for confectionery
      and wholesale.
    - 'Sales, marketing (ABM, events), and customer success headcount.'
    - 'Security, compliance (SOC 2), privacy, legal, and insurance.'
    - 'General and administrative expenses (finance, HR, overhead).'
  keyMetrics:
    - >-
      Customer outcome KPIs: incremental gross profit dollars from promotions
      (+2–5% in year 1), promo ROI improvement (+200–400 bps), reduction in
      value-destroying promos (−15–25%), cost per incremental unit (−10–20%),
      stockouts during promos (−15–30%).
    - >-
      Model performance KPIs: uplift prediction MAPE ≤ 20% at account/SKU/week;
      directional accuracy ≥ 70% on holdout; confidence interval calibration
      within ±5 pts.
    - >-
      Adoption KPIs: percent of promotions planned with recommendations (target
      ≥ 60% by Q2), sales team usage (weekly active users ≥ 65%),
      time-to-insight post-event (<24 hours).
    - >-
      Data health KPIs: match rate of UPC-to-SKU ≥ 98%, EDI 852/867 on-time
      ingestion ≥ 95%, anomaly detection false positive rate < 5%.
    - >-
      Revenue KPIs (internal): ACV per logo ($120k target), gross margin ≥ 70%,
      logo churn < 8%/yr, net revenue retention ≥ 120%, CAC payback ≤ 12 months.
shortName: PromoLift
---

# PromoLift Business Workflows

## Customer Acquisition Workflows

```typescript
interface Lead {
  id: string
  company: string
  revenue: number
  channels: string[]
  currentTPMSystem?: string
  ediCapability: boolean
  seasonalConcentration: number
  contactInfo: ContactInfo
  source: 'conference' | 'referral' | 'inbound' | 'outbound'
}

interface QualifiedLead extends Lead {
  fitScore: number
  urgency: 'high' | 'medium' | 'low'
  decisionMakers: DecisionMaker[]
  currentPainPoints: string[]
  budget: BudgetInfo
}

interface Customer {
  id: string
  lead: QualifiedLead
  contract: Contract
  onboardingStatus: OnboardingStatus
  integrations: Integration[]
}

export async function acquireCustomer(lead: Lead): Promise<Customer> {
  try {
    const qualifiedLead = await qualifyLead(lead)
    
    if (qualifiedLead.fitScore < 70) {
      throw new Error('Lead does not meet qualification criteria')
    }

    const proposal = await generateProposal(qualifiedLead)
    const contract = await negotiateContract(proposal)
    const customer = await onboardCustomer(contract)
    
    await scheduleKickoffMeeting(customer)
    await setupInitialIntegrations(customer)
    
    return customer
  } catch (error) {
    await logLeadRejection(lead, error.message)
    throw error
  }
}

export async function qualifyLead(lead: Lead): Promise<QualifiedLead> {
  const fitScore = await calculateFitScore(lead)
  const decisionMakers = await identifyDecisionMakers(lead)
  const painPoints = await assessPainPoints(lead)
  const budget = await estimateBudget(lead)
  
  return {
    ...lead,
    fitScore,
    urgency: determineUrgency(painPoints, lead.seasonalConcentration),
    decisionMakers,
    currentPainPoints: painPoints,
    budget
  }
}

export async function generateProposal(qualifiedLead: QualifiedLead): Promise<Proposal> {
  const baselineROI = await estimateCurrentROI(qualifiedLead)
  const projectedImpact = await calculateProjectedImpact(qualifiedLead)
  const pricingTier = await determinePricingTier(qualifiedLead)
  
  return await createCustomProposal({
    lead: qualifiedLead,
    baselineROI,
    projectedImpact,
    pricingTier,
    pilotScope: await definePilotScope(qualifiedLead)
  })
}

export async function negotiateContract(proposal: Proposal): Promise<Contract> {
  const negotiations = await conductNegotiations(proposal)
  const finalTerms = await finalizePricingAndTerms(negotiations)
  const contract = await generateContract(finalTerms)
  
  await sendForLegalReview(contract)
  await obtainSignatures(contract)
  
  return contract
}
```

## Product Development Processes

```typescript
interface DataSource {
  type: 'ERP' | 'EDI_852' | 'EDI_867' | 'POS' | 'TPM' | 'AUDIT'
  connection: ConnectionConfig
  schema: DataSchema
  refreshFrequency: string
}

interface UpliftModel {
  id: string
  version: string
  algorithm: 'hierarchical_bayesian' | 'causal_inference'
  features: ModelFeature[]
  performance: ModelPerformance
  lastTrained: Date
}

interface OptimizationEngine {
  constraints: OptimizationConstraint[]
  objective: 'maximize_incremental_profit' | 'minimize_cost_per_unit'
  solver: 'linear_programming' | 'genetic_algorithm'
}

export async function developUpliftMeasurement(): Promise<UpliftModel> {
  const trainingData = await prepareTrainingData()
  const features = await engineerFeatures(trainingData)
  
  const model = await trainHierarchicalBayesianModel({
    data: trainingData,
    features,
    priors: await defineSeasonalityPriors(),
    hyperparameters: await optimizeHyperparameters()
  })
  
  const validation = await validateModel(model)
  
  if (validation.mape > 0.20) {
    throw new Error('Model performance below acceptable threshold')
  }
  
  await deployModel(model)
  return model
}

export async function buildOptimizationEngine(): Promise<OptimizationEngine> {
  const constraints = await defineOptimizationConstraints()
  const objectiveFunction = await buildObjectiveFunction()
  
  const engine = await createOptimizationEngine({
    constraints,
    objective: objectiveFunction,
    solver: await selectOptimalSolver(constraints)
  })
  
  await testOptimizationEngine(engine)
  return engine
}

export async function integrateDataSources(customer: Customer): Promise<Integration[]> {
  const requiredSources = await identifyRequiredDataSources(customer)
  const integrations: Integration[] = []
  
  for (const source of requiredSources) {
    try {
      const integration = await setupDataIntegration(source, customer)
      await validateDataQuality(integration)
      integrations.push(integration)
    } catch (error) {
      await handleIntegrationFailure(source, error)
    }
  }
  
  await setupDataPipeline(integrations)
  return integrations
}

export async function enhanceModelAccuracy(): Promise<ModelUpdate> {
  const performanceMetrics = await analyzeCurrentPerformance()
  const improvementAreas = await identifyImprovementAreas(performanceMetrics)
  
  const updates = await implementModelImprovements(improvementAreas)
  const retrainedModel = await retrainWithNewData()
  
  await validateImprovedModel(retrainedModel)
  return await deployModelUpdate(retrainedModel)
}
```

## Revenue Generation Flows

```typescript
interface PricingStrategy {
  tier: 'mid_market' | 'enterprise'
  basePrice: number
  scalingFactors: ScalingFactor[]
  addOns: AddOnService[]
}

interface Upsell {
  type: 'managed_service' | 'professional_services' | 'performance_accelerator'
  value: number
  probability: number
  timeline: string
}

interface RevenueOpportunity {
  customer: Customer
  type: 'expansion' | 'upsell' | 'renewal'
  value: number
  probability: number
  actions: RevenueAction[]
}

export async function optimizePricing(customer: Customer): Promise<PricingStrategy> {
  const customerProfile = await analyzeCustomerProfile(customer)
  const competitiveAnalysis = await conductCompetitiveAnalysis(customer)
  const valueDelivered = await calculateValueDelivered(customer)
  
  const basePricing = await calculateBasePricing({
    accountCount: customerProfile.accountCount,
    skuCount: customerProfile.skuCount,
    dataVolume: customerProfile.dataVolume
  })
  
  return await createPricingStrategy({
    basePricing,
    valueMultiplier: valueDelivered.multiplier,
    competitivePosition: competitiveAnalysis.position,
    customerTier: customerProfile.tier
  })
}

export async function identifyUpsellOpportunities(customer: Customer): Promise<Upsell[]> {
  const usage = await analyzeCustomerUsage(customer)
  const satisfaction = await measureCustomerSatisfaction(customer)
  const businessGrowth = await assessBusinessGrowth(customer)
  
  const opportunities: Upsell[] = []
  
  if (usage.complexity > 0.8 && satisfaction.score > 8) {
    opportunities.push(await createManagedServiceUpsell(customer))
  }
  
  if (businessGrowth.expansion > 0.3) {
    opportunities.push(await createExpansionUpsell(customer))
  }
  
  if (customer.performanceGains > 0.05) {
    opportunities.push(await createPerformanceAcceleratorUpsell(customer))
  }
  
  return opportunities
}

export async function executeRevenueExpansion(opportunity: RevenueOpportunity): Promise<ExpansionResult> {
  const proposal = await createExpansionProposal(opportunity)
  const stakeholders = await identifyExpansionStakeholders(opportunity.customer)
  
  await presentExpansionCase(proposal, stakeholders)
  const negotiation = await negotiateExpansionTerms(proposal)
  
  if (negotiation.approved) {
    const contract = await executeExpansionContract(negotiation)
    await implementExpansion(contract)
    return { success: true, contract, revenue: contract.value }
  }
  
  return { success: false, reason: negotiation.rejectionReason }
}

export async function optimizeCustomerLifetimeValue(customer: Customer): Promise<CLVOptimization> {
  const currentCLV = await calculateCurrentCLV(customer)
  const churnRisk = await assessChurnRisk(customer)
  const expansionPotential = await assessExpansionPotential(customer)
  
  const optimizationPlan = await createCLVOptimizationPlan({
    currentCLV,
    churnRisk,
    expansionPotential,
    retentionStrategies: await identifyRetentionStrategies(customer),
    growthStrategies: await identifyGrowthStrategies(customer)
  })
  
  return await executeCLVOptimization(optimizationPlan)
}
```

## Operational Procedures

```typescript
interface ComplianceCheck {
  type: 'display' | 'pricing' | 'inventory' | 'data_quality'
  status: 'compliant' | 'non_compliant' | 'unknown'
  evidence: Evidence[]
  timestamp: Date
}

interface OperationalMetric {
  name: string
  value: number
  target: number
  trend: 'improving' | 'declining' | 'stable'
  alerts: Alert[]
}

interface QualityAssurance {
  dataQuality: DataQualityMetrics
  modelPerformance: ModelPerformanceMetrics
  systemHealth: SystemHealthMetrics
}

export async function monitorDisplayCompliance(promotion: Promotion): Promise<ComplianceCheck> {
  const auditData = await collectAuditData(promotion)
  const complianceStatus = await assessDisplayCompliance(auditData)
  
  if (complianceStatus.status === 'non_compliant') {
    await alertSalesTeam(promotion, complianceStatus)
    await adjustROIExpectations(promotion, complianceStatus.impact)
  }
  
  await logComplianceCheck(complianceStatus)
  return complianceStatus
}

export async function ensureDataQuality(): Promise<QualityAssurance> {
  const dataQuality = await runDataQualityChecks()
  const modelPerformance = await validateModelPerformance()
  const systemHealth = await checkSystemHealth()
  
  const issues = await identifyQualityIssues({
    dataQuality,
    modelPerformance,
    systemHealth
  })
  
  if (issues.length > 0) {
    await escalateQualityIssues(issues)
    await implementQualityFixes(issues)
  }
  
  return { dataQuality, modelPerformance, systemHealth }
}

export async function generatePostEventScorecard(promotion: Promotion): Promise<Scorecard> {
  const actualResults = await collectActualResults(promotion)
  const predictedResults = await retrievePredictedResults(promotion)
  const variance = await calculateVariance(actualResults, predictedResults)
  
  const scorecard = await createScorecard({
    promotion,
    actualResults,
    predictedResults,
    variance,
    learnings: await extractLearnings(variance),
    recommendations: await generateRecommendations(variance)
  })
  
  await distributeScorecard(scorecard)
  await updateModelWithLearnings(scorecard.learnings)
  
  return scorecard
}

export async function maintainSystemPerformance(): Promise<MaintenanceReport> {
  const performance = await monitorSystemPerformance()
  const capacity = await assessCapacityNeeds()
  const security = await runSecurityChecks()
  
  const maintenanceTasks = await identifyMaintenanceTasks({
    performance,
    capacity,
    security
  })
  
  await executeMaintenance(maintenanceTasks)
  
  return await generateMaintenanceReport({
    performance,
    capacity,
    security,
    completedTasks: maintenanceTasks
  })
}
```

## Decision-Making Workflows

```typescript
interface PromotionRecommendation {
  account: string
  sku: string
  recommendedDepth: number
  recommendedDuration: number
  displayType: string
  expectedUplift: number
  expectedROI: number
  confidence: number
  reasoning: string[]
}

interface BudgetAllocation {
  account: string
  allocatedBudget: number
  expectedReturn: number
  priority: number
  constraints: Constraint[]
}

interface DecisionContext {
  seasonality: SeasonalityFactor[]
  inventory: InventoryLevel[]
  competition: CompetitiveActivity[]
  retailerCalendar: RetailerEvent[]
}

export async function recommendNextBestPromotion(
  account: string,
  sku: string,
  context: DecisionContext
): Promise<PromotionRecommendation> {
  const historicalPerformance = await analyzeHistoricalPerformance(account, sku)
  const elasticity = await calculatePriceElasticity(account, sku)
  const seasonalFactors = await assessSeasonalFactors(sku, context.seasonality)
  
  const optimization = await optimizePromotionParameters({
    account,
    sku,
    historicalPerformance,
    elasticity,
    seasonalFactors,
    constraints: await getPromotionConstraints(account, sku),
    objective: 'maximize_incremental_profit'
  })
  
  const recommendation = await createRecommendation({
    optimization,
    confidence: await calculateConfidence(optimization),
    reasoning: await generateReasoning(optimization)
  })
  
  await validateRecommendation(recommendation)
  return recommendation
}

export async function allocateTradeSpendBudget(
  totalBudget: number,
  accounts: string[],
  timeHorizon: string
): Promise<BudgetAllocation[]> {
  const accountPotentials = await assessAccountPotentials(accounts)
  const constraints = await defineAllocationConstraints(totalBudget, timeHorizon)
  
  const optimization = await solveAllocationOptimization({
    totalBudget,
    accountPotentials,
    constraints,
    objective: 'maximize_total_incremental_profit'
  })
  
  const allocations = await createBudgetAllocations(optimization)
  
  await validateAllocations(allocations, constraints)
  await generateAllocationRationale(allocations)
  
  return allocations
}

export async function simulatePromotionScenarios(
  baseScenario: PromotionScenario,
  alternatives: PromotionScenario[]
): Promise<ScenarioComparison> {
  const results = await Promise.all([
    simulateScenario(baseScenario),
    ...alternatives.map(scenario => simulateScenario(scenario))
  ])
  
  const comparison = await compareScenarios(results)
  const riskAssessment = await assessScenarioRisks(results)
  
  return {
    scenarios: results,
    comparison,
    riskAssessment,
    recommendation: await selectOptimalScenario(results, riskAssessment)
  }
}

export async function makePromotionDecision(
  recommendation: PromotionRecommendation,
  businessRules: BusinessRule[]
): Promise<PromotionDecision> {
  const ruleValidation = await validateAgainstBusinessRules(recommendation, businessRules)
  
  if (!ruleValidation.passed) {
    return {
      approved: false,
      reason: 'Business rule violation',
      violations: ruleValidation.violations
    }
  }
  
  const riskAssessment = await assessPromotionRisk(recommendation)
  const approvalRequired = await determineApprovalRequirement(recommendation, riskAssessment)
  
  if (approvalRequired) {
    const approval = await requestHumanApproval(recommendation, riskAssessment)
    return await processApprovalDecision(approval)
  }
  
  return await autoApprovePromotion(recommendation)
}

export async function optimizePromotionCalendar(
  account: string,
  planningHorizon: string
): Promise<PromotionCalendar> {
  const retailerCalendar = await getRetailerCalendar(account)
  const seasonalPatterns = await analyzeSeasonalPatterns(account)
  const competitiveActivity = await forecastCompetitiveActivity(account, planningHorizon)
  
  const calendar = await createOptimalCalendar({
    account,
    planningHorizon,
    retailerCalendar,
    seasonalPatterns,
    competitiveActivity,
    budgetConstraints: await getBudgetConstraints(account),
    inventoryConstraints: await getInventoryConstraints(account)
  })
  
  await validateCalendar(calendar)
  await generateCalendarRationale(calendar)
  
  return calendar
}
```

## Event-Driven Workflows

```typescript
// Event handlers for business process automation
export async function onPromotionStart(event: PromotionStartEvent): Promise<void> {
  await trackPromotionExecution(event.promotion)
  await monitorDisplayCompliance(event.promotion)
  await alertSalesTeam(event.promotion, 'started')
  await beginPerformanceTracking(event.promotion)
}

export async function onPromotionEnd(event: PromotionEndEvent): Promise<void> {
  await finalizePromotionTracking(event.promotion)
  await generatePostEventScorecard(event.promotion)
  await updateModelWithResults(event.promotion)
  await identifyFollowUpOpportunities(event.promotion)
}

export async function onDataQualityAlert(event: DataQualityAlertEvent): Promise<void> {
  await investigateDataIssue(event.issue)
  await notifyDataTeam(event.issue)
  await implementDataFix(event.issue)
  await validateDataFix(event.issue)
}

export async function onCustomerOnboarding(event: CustomerOnboardingEvent): Promise<void> {
  await setupCustomerEnvironment(event.customer)
  await configureDataIntegrations(event.customer)
  await trainCustomerTeam(event.customer)
  await scheduleSuccessReview(event.customer)
}

// Scheduled workflows
export async function dailyDataProcessing(): Promise<void> {
  await ingestDailyData()
  await runDataQualityChecks()
  await updateUpliftModels()
  await generateDailyReports()
}

export async function weeklyPerformanceReview(): Promise<void> {
  await analyzeWeeklyPerformance()
  await updateCustomerDashboards()
  await identifyActionItems()
  await scheduleCustomerCheckIns()
}

export async function monthlyModelRetraining(): Promise<void> {
  await collectNewTrainingData()
  await retrainUpliftModels()
  await validateModelPerformance()
  await deployUpdatedModels()
}
```
