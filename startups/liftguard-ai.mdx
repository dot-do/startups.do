---
name: LiftGuard AI
slug: liftguard-ai
naics:
  primary: '211120'
  occupations: []
service:
  title: ESP/Rod Lift Failure Prediction & Advisory
  description: >-
    Predict imminent artificial lift failures and propose preventive actions to
    reduce downtime.
  targetUsers:
    - Reliability Engineers
    - Lift Specialists
    - Production Engineers
  triggers:
    - Daily schedule
    - New pump telemetry or motor current anomalies
    - User on-demand check for a well set
  inputs:
    - 'Motor current, intake/discharge pressure, temperature'
    - 'Run-time counters, starts/stops, vibration if available'
    - Fluid level/annulus pressure (rod)
    - '>30–180 days of historical labels (failures, interventions)'
  steps:
    - Ingest telemetry and maintenance history
    - 'Engineer features (loads, slips, thermal cycles, pattern changes)'
    - Train/update well-specific and fleet models
    - 'Score failure risk and lead time (e.g., 3–14 days)'
    - 'Generate playbook (inspection, setpoint tweak, chemical dose, pull plan)'
    - Push notification and draft work order if confirmed
  tools:
    - PI Web API/SiteWise
    - scikit-learn/XGBoost/LightGBM
    - MLOps (MLflow)
    - Teams/Email
    - SAP PM/Maximo
  outputs:
    - Per-well risk score and likely failure mode
    - Action recommendations with expected downtime avoided
    - Calendarized inspection list
    - 'KPI: MTBF/availability trend'
  pricingModel:
    - Setup (model training) + per-lift monthly fee
    - Optional performance fee tied to avoided downtime
  humanInLoop: true
  feasibility:
    remoteOnLaptop: 3
    modelCapability: 4
    overall: 3
  risks:
    - Sparse/labeled data scarcity
    - Changes in operating regime cause drift
    - Actionable recommendations still need site procedures
    - High-resolution data access limits
  dependencies:
    - Telemetry/historian access
    - Failure/repair history export
    - Lift configuration metadata
    - Approval workflow for work orders
leanCanvas:
  problem:
    - >-
      Unplanned ESP and rod-lift failures cause 2–10 days downtime per event,
      driving $40k–$150k in deferred revenue per well per failure (assumes
      120–400 bbl/d, $65–$85/bbl).
    - >-
      ESP runlife variability (6–24 months) and rod lift component wear (0.5–1.5
      failures/well-year) strain limited lift-engineering resources and
      spare-parts planning.
    - >-
      Operators rely on disparate OEM dashboards (VSDs, pump card systems,
      SCADA/historian) with alarm fatigue and low actionable signal-to-noise
      ratio.
    - >-
      Root causes (scale, gas interference, solids, electrical/power quality,
      wear) are often identified post-failure; preventable conditions (e.g., gas
      lock, pump-off, sanding) go unmitigated.
    - >-
      Workovers and interventions are reactive, costing $20k–$150k per job, with
      HSE exposure due to last-minute mobilization.
    - >-
      Lack of prescriptive, field-ready guidance delays corrective actions;
      setpoint changes and chemical rates are not systematically optimized.
    - >-
      Limited visibility into model performance and business impact impedes
      adoption and budget approvals.
  solution:
    - >-
      Unified data ingestion from SCADA/historians (PI, Ignition), VSDs,
      downhole gauges, power quality, pump cards, and workover logs.
    - >-
      Hybrid models combining physics-informed features (pump efficiency, intake
      pressure, pump-off metrics) with ML anomaly classification and survival
      analysis for runlife.
    - >-
      Prescriptive advisory engine that translates predictions into specific
      actions: VSD speed/torque ramping, gas-lock clearing sequences, pump-off
      control tuning, chemical dose adjustments, choke changes, and proactive
      workover scheduling.
    - >-
      Lead-time targets per failure mode (e.g., gas interference 2–5 days; scale
      deposition 7–21 days; rod-string wear 7–14 days; electrical issues hours–3
      days) with confidence scoring.
    - >-
      Operator-facing workflows: watchlists by asset, auto-generated work
      orders, spares/crew scheduling, and post-action verification with uplift
      measurement.
    - >-
      Edge and cloud deployment options; ability to push setpoint changes to
      controllers via existing control standards (with human-in-the-loop).
    - >-
      Closed-loop learning: post-mortem labeling from CMMS/workover reports,
      improving mode classification and runlife predictions over time.
  uniqueValueProp: >-
    Predict artificial lift failures 3–14 days in advance and prescribe proven
    actions (setpoint, chemical, workover timing) to cut unplanned downtime
    20–40%, increase MTBF 15–30%, and reduce lift-related LOE 8–15%, all in a
    vendor-agnostic, field-ready workflow.
  unfairAdvantage: >-
    A cross-lift, vendor-agnostic labeled failure-mode dataset and playbook
    library built with multiple operators and OEM inputs, enabling
    higher-precision predictions and actionable, field-tested advisories.
    Combined physics+ML approach plus edge human-in-the-loop control shortens
    the path from detection to impact. Pay-for-performance optionality aligned
    with operator economics accelerates adoption and trust.
  customerSegments:
    - >-
      Primary: North American E&Ps operating ESP and rod-lift wells (Permian,
      Eagle Ford, Bakken, DJ, Anadarko, Powder River, Western Canada).
    - >-
      Secondary: Global onshore E&Ps with mature artificial lift portfolios
      (LATAM, Middle East).
    - >-
      Roles: Production engineers, artificial lift engineers, optimization
      teams, field foremen, operations managers, asset managers, digital
      transformation leaders.
    - >-
      Channel-adjacent: Artificial lift OEMs and service companies (ESP,
      rod/beam), production chemical providers, SCADA/historian vendors, systems
      integrators.
  channels:
    - >-
      Direct enterprise sales to E&Ps via regional account executives focused on
      Permian, Eagle Ford, and WCSB.
    - >-
      Partnerships/co-sell with artificial lift OEMs and service firms (ESP and
      rod lift) to bundle with surveillance/field services.
    - >-
      Alliances with production chemical providers to pair predictive
      scaling/sanding advisories with dosing programs.
    - >-
      Integration partnerships with SCADA/historian vendors and systems
      integrators for rapid deployments.
    - >-
      Cloud marketplaces (AWS, Azure) for streamlined procurement and private
      offers; pilot-friendly terms.
    - >-
      Industry events and technical papers (SPE Artificial Lift Conference,
      URTeC, SWPSC) demonstrating measured results.
    - >-
      Land-and-expand pilots (50–200 wells per asset), expanding basin-wide on
      ROI proof and playbook localization.
  revenueStreams:
    - >-
      SaaS subscription per connected well per month: ESP $250–$400; rod lift
      $100–$180 (volume-tiered).
    - >-
      Professional services for integration and data onboarding: $50k–$250k per
      operator (scope-dependent).
    - >-
      Premium add-ons: Edge control integration ($0.02–$0.05 per well-hour),
      advanced chemical advisory (+$20/well-month), API access.
    - >-
      Success-fee option: 5–15% of verified savings (downtime avoided + reduced
      LOE) with jointly agreed baseline method.
    - 'Enterprise licenses with basin or company-level pricing for >5,000 wells.'
    - Training and certification for operator staff and partners.
  costStructure:
    - >-
      COGS: cloud compute/storage and data egress 8–15% of revenue; edge
      gateways where needed.
    - 'R&D: data science, MLOps, and domain experts (30–40% of OpEx).'
    - >-
      Implementation/services: integrations, data quality remediation, field
      validation (15–25% of OpEx).
    - >-
      Sales/marketing: enterprise sales, conferences, technical publications
      (15–20% of OpEx).
    - >-
      Compliance/security: SOC 2/ISO 27001, penetration testing, OT security
      reviews (3–6% of OpEx).
    - Product support and customer success (10–15% of OpEx).
    - Liability and cyber insurance; legal (including data/privacy clauses).
  keyMetrics:
    - >-
      Technical: prediction recall >70% and precision >60% by mode; median lead
      time >=5 days for scale/sanding and >=3 days for mechanical wear; <1 false
      positive per well-month.
    - >-
      Business outcomes: +15–30% MTBF uplift, 20–40% fewer unplanned failures,
      10–25% downtime reduction, 8–15% lift-related LOE reduction, 2–4% net
      production uplift from reduced NPT.
    - >-
      Financial impact: $20k–$80k/well-year savings opportunity depending on
      lift type and production rate; target 5–10x ROI within 12 months.
    - >-
      Adoption: wells connected (>5,000 in year 2), time-to-value (<6 weeks from
      contract to first advisories), weekly active users per engineer (>10).
    - >-
      Quality: advisory acceptance rate (>60%), post-action success rate (>70%),
      model drift incidents per quarter (<2) with retraining SLA (<2 weeks).
    - >-
      Sales: pilot-to-scale conversion rate (>60%), gross margin (>70% SaaS),
      net revenue retention (>120%).
storyBrand:
  character: >-
    Production and artificial-lift teams at crude oil operators who must keep
    ESP and rod-lift wells online and on target.
  problem: >-
    External: Unplanned ESP/rod-lift failures and noisy alarms drive costly
    downtime and workovers. Internal: Teams are stuck reacting under pressure
    without clear early warnings or actionable guidance. Philosophical: With the
    data already being collected, failures shouldn’t be a surprise.
  guide: >-
    We’re lift engineers and data scientists who understand the cost of deferred
    barrels and emergency rig calls. Our field-informed AI pinpoints degradation
    early, explains why risk is rising, and integrates securely with your
    existing SCADA and workflows.
  plan: >-
    1) Connect SCADA/VSD streams and well history; 2) Get risk scores, likely
    failure modes (e.g., gas lock, pump wear, rod/tubing friction,
    electrical/motor issues), and recommended actions; 3) Prioritize
    interventions, schedule work, and measure impact in your CMMS.
  callToAction: >-
    Direct: Start a pilot on a representative set of wells. Transitional:
    Request the playbook and a sample advisory report.
  success: >-
    Higher uptime and sustained production, fewer catastrophic failures, lower
    OPEX/workover spend, safer field operations, and a shift to condition-based
    maintenance with predictable, planned interventions.
  failure: >-
    More surprise pump and rod failures, lost barrels, emergency callouts and
    rig time, rising costs, and avoidable HSE exposure.
landingPage:
  hero:
    title: Predict ESP & Rod Lift Failures Before They Happen
    subtitle: >-
      AI early warning and prescriptive actions to cut downtime, deferment, and
      LOE across your field.
    ctaText: Request a Demo
    ctaHref: /demo
  problem:
    - >-
      Unplanned ESP/rod lift failures drive production deferment and costly
      workovers.
    - Reactive maintenance extends MTTR and elevates HSE exposure.
    - 'SCADA, historian, and CMMS data are siloed—insight comes too late.'
    - Alarm floods and false positives overwhelm engineers and operators.
    - Tribal knowledge isn’t scalable; playbooks vary by crew and basin.
    - 'Crew, inventory, and vendor delays prolong outages and increase LOE.'
  solution:
    - >-
      Predict imminent lift failures (days in advance) with confidence and
      failure-mode tagging.
    - >-
      Prescribe preventive actions: setpoint changes, speed ramps, chemical
      treatments, gas mitigation, flushes, or planned pull windows.
    - >-
      Prioritize wells by production at risk and time-to-failure for focused
      action.
    - >-
      Auto-orchestrate work orders, routes, and vendor notifications via CMMS
      integration.
    - >-
      Continuously learn from outcomes to improve accuracy and run life basin by
      basin.
  features:
    - Time-to-failure forecasts with confidence intervals.
    - >-
      Failure-mode classification: gas lock, vibration/wear, scale/sand,
      overheating, pump-off, gas interference, parted rod, tubing leak, stuffing
      box issues.
    - >-
      Prescriptive playbooks with step-by-step actions and expected impact on
      downtime and LOE.
    - >-
      What-if simulator for setpoint and chemical program changes before pushing
      live.
    - >-
      Real-time streaming integrations: SCADA (Modbus, OPC UA), historians
      (OSIsoft PI), edge gateways.
    - 'CMMS connectors: SAP PM, IBM Maximo—auto-create and update work orders.'
    - >-
      Mobile, email, and in-app alerts with escalation paths and
      acknowledgements.
    - 'Explainable AI: key drivers, similar-well analogs, and signal tracebacks.'
    - 'Portfolio view: rank wells by boe at risk, cost-to-fix, and urgency.'
    - >-
      Role-based dashboards for production engineers, lift specialists, and
      field supervisors.
    - >-
      Security-first: SOC 2/ISO 27001, SSO, VPC or on-prem options, read-only
      data access.
    - Edge inference for low-connectivity pads and latency-sensitive sites.
  steps:
    - >-
      Connect: Hook up SCADA/historian, well tests, failure logs, and CMMS in
      days.
    - >-
      Calibrate: Train on your run histories; validate with lift SMEs and field
      trials.
    - 'Configure: Choose playbooks, alert thresholds, and integration endpoints.'
    - 'Go Live: Start early warnings and prescriptive advisories to field teams.'
    - >-
      Orchestrate: Auto-generate work orders, schedule crews, and align
      chemicals/vendors.
    - >-
      Improve: Track outcomes and ROI; models retrain continuously as conditions
      change.
---

// Business Process Functions for LiftGuard AI

export interface Lead {
  companyName: string;
  contactInfo: ContactInfo;
  wellCount: number;
  liftTypes: ('ESP' | 'RodLift')[];
  currentFailureRate: number;
  estimatedRevenue: number;
  region: string;
}

export interface ContactInfo {
  name: string;
  title: string;
  email: string;
  phone: string;
}

export interface Customer {
  id: string;
  companyName: string;
  contractValue: number;
  wellsConnected: number;
  onboardingStatus: 'pending' | 'in-progress' | 'complete';
  integrationComplexity: 'low' | 'medium' | 'high';
}

export interface WellData {
  wellId: string;
  liftType: 'ESP' | 'RodLift';
  scadaData: ScadaMetrics;
  vsdData: VsdMetrics;
  productionData: ProductionMetrics;
  historicalFailures: FailureEvent[];
}

export interface PredictionResult {
  wellId: string;
  failureMode: string;
  probability: number;
  leadTimeDays: number;
  confidence: number;
  prescriptiveActions: Action[];
}

export interface Action {
  type: 'vsd_adjustment' | 'chemical_dosing' | 'workover_schedule' | 'maintenance';
  description: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  estimatedCost: number;
  expectedBenefit: number;
}

// Customer Acquisition Workflows
export async function acquireCustomer(lead: Lead): Promise<Customer> {
  const qualifiedLead = await qualifyLead(lead);
  const proposal = await generateProposal(qualifiedLead);
  const contract = await negotiateContract(proposal);
  const customer = await onboardCustomer(contract);
  
  await scheduleKickoffMeeting(customer);
  await assignAccountManager(customer);
  
  return customer;
}

export async function qualifyLead(lead: Lead): Promise<Lead> {
  // Validate minimum well count and revenue potential
  if (lead.wellCount < 50) {
    throw new Error('Lead does not meet minimum well count threshold');
  }
  
  const revenueScore = calculateRevenueScore(lead);
  const technicalFitScore = await assessTechnicalFit(lead);
  
  if (revenueScore < 0.6 || technicalFitScore < 0.7) {
    throw new Error('Lead does not meet qualification criteria');
  }
  
  return { ...lead, qualified: true };
}

export async function generateProposal(lead: Lead): Promise<Proposal> {
  const wellAnalysis = await analyzeWellPortfolio(lead);
  const savingsProjection = calculateSavingsProjection(wellAnalysis);
  const pricingTier = determinePricingTier(lead.wellCount, lead.liftTypes);
  
  return {
    customerId: lead.companyName,
    wellCount: lead.wellCount,
    projectedSavings: savingsProjection,
    pricing: pricingTier,
    implementationTimeline: calculateImplementationTimeline(lead),
    roi: savingsProjection.annualSavings / pricingTier.annualCost
  };
}

// Product Development Processes
export async function developPredictiveModel(trainingData: WellData[]): Promise<MLModel> {
  const preprocessedData = await preprocessWellData(trainingData);
  const physicsFeatures = extractPhysicsInformedFeatures(preprocessedData);
  const mlFeatures = await generateMLFeatures(preprocessedData);
  
  const combinedFeatures = mergeFeatureSets(physicsFeatures, mlFeatures);
  const model = await trainHybridModel(combinedFeatures);
  
  const validationResults = await validateModel(model, preprocessedData);
  if (validationResults.recall < 0.7 || validationResults.precision < 0.6) {
    throw new Error('Model does not meet performance thresholds');
  }
  
  return model;
}

export async function generatePrescriptiveActions(prediction: PredictionResult): Promise<Action[]> {
  const failureMode = prediction.failureMode;
  const wellContext = await getWellContext(prediction.wellId);
  
  const actions: Action[] = [];
  
  switch (failureMode) {
    case 'gas_interference':
      actions.push(await generateGasLockClearingSequence(wellContext));
      actions.push(await optimizeVSDSettings(wellContext, 'gas_mitigation'));
      break;
    case 'scale_deposition':
      actions.push(await adjustChemicalDosing(wellContext, 'scale_inhibitor'));
      actions.push(await schedulePreventiveMaintenance(wellContext, 7));
      break;
    case 'rod_string_wear':
      actions.push(await scheduleWorkover(wellContext, prediction.leadTimeDays - 2));
      actions.push(await orderSpareParts(wellContext, 'rod_string'));
      break;
    case 'electrical_issues':
      actions.push(await schedulePowerQualityCheck(wellContext));
      actions.push(await adjustVSDProtectionSettings(wellContext));
      break;
  }
  
  return prioritizeActions(actions, prediction.confidence);
}

// Revenue Generation Flows
export async function processSubscriptionBilling(customer: Customer): Promise<BillingResult> {
  const wellsConnected = await getConnectedWellCount(customer.id);
  const usageMetrics = await calculateUsageMetrics(customer.id);
  const baseSubscription = calculateBaseSubscription(wellsConnected, customer.liftTypes);
  
  let totalAmount = baseSubscription;
  
  // Add premium features
  if (customer.hasEdgeIntegration) {
    totalAmount += calculateEdgeIntegrationFees(usageMetrics.edgeHours);
  }
  
  if (customer.hasChemicalAdvisory) {
    totalAmount += wellsConnected * 20; // $20/well-month
  }
  
  const invoice = await generateInvoice(customer, totalAmount, usageMetrics);
  const paymentResult = await processPayment(invoice);
  
  if (customer.hasSuccessFeeOption) {
    const verifiedSavings = await calculateVerifiedSavings(customer.id);
    const successFee = verifiedSavings * customer.successFeeRate;
    await processSuccessFeePayment(customer, successFee);
  }
  
  return {
    customerId: customer.id,
    invoiceAmount: totalAmount,
    paymentStatus: paymentResult.status,
    nextBillingDate: addMonths(new Date(), 1)
  };
}

export async function trackCustomerROI(customerId: string): Promise<ROIMetrics> {
  const baseline = await getCustomerBaseline(customerId);
  const currentMetrics = await getCurrentPerformanceMetrics(customerId);
  
  const downtimeReduction = calculateDowntimeReduction(baseline, currentMetrics);
  const mtbfImprovement = calculateMTBFImprovement(baseline, currentMetrics);
  const loeReduction = calculateLOEReduction(baseline, currentMetrics);
  
  const totalSavings = downtimeReduction.savings + loeReduction.savings;
  const customerSpend = await getCustomerSpend(customerId);
  
  return {
    customerId,
    totalSavings,
    customerSpend,
    roi: totalSavings / customerSpend,
    downtimeReduction: downtimeReduction.percentage,
    mtbfImprovement: mtbfImprovement.percentage,
    loeReduction: loeReduction.percentage,
    measurementPeriod: '12_months'
  };
}

// Operational Procedures
export async function ingestWellData(wellId: string): Promise<WellData> {
  const scadaData = await fetchSCADAData(wellId);
  const vsdData = await fetchVSDData(wellId);
  const productionData = await fetchProductionData(wellId);
  const historicalFailures = await fetchFailureHistory(wellId);
  
  const validatedData = await validateDataQuality({
    wellId,
    scadaData,
    vsdData,
    productionData,
    historicalFailures
  });
  
  if (validatedData.qualityScore < 0.8) {
    await flagDataQualityIssue(wellId, validatedData.issues);
  }
  
  await storeWellData(validatedData);
  await triggerPredictionUpdate(wellId);
  
  return validatedData;
}

export async function monitorSystemHealth(): Promise<SystemHealthReport> {
  const modelPerformance = await checkModelPerformance();
  const dataIngestionHealth = await checkDataIngestionHealth();
  const predictionLatency = await checkPredictionLatency();
  const customerSatisfaction = await checkCustomerSatisfaction();
  
  const overallHealth = calculateOverallHealth([
    modelPerformance,
    dataIngestionHealth,
    predictionLatency,
    customerSatisfaction
  ]);
  
  if (overallHealth.score < 0.8) {
    await triggerHealthAlert(overallHealth);
    await scheduleSystemMaintenance();
  }
  
  return {
    timestamp: new Date(),
    overallScore: overallHealth.score,
    modelPerformance,
    dataIngestionHealth,
    predictionLatency,
    customerSatisfaction,
    recommendations: generateHealthRecommendations(overallHealth)
  };
}

// Decision-Making Workflows
export async function prioritizeCustomerRequests(requests: CustomerRequest[]): Promise<CustomerRequest[]> {
  const scoredRequests = await Promise.all(
    requests.map(async (request) => {
      const customerTier = await getCustomerTier(request.customerId);
      const businessImpact = calculateBusinessImpact(request);
      const technicalComplexity = assessTechnicalComplexity(request);
      const urgency = calculateUrgency(request);
      
      const priorityScore = (
        customerTier.weight * 0.3 +
        businessImpact * 0.4 +
        (1 - technicalComplexity) * 0.2 +
        urgency * 0.1
      );
      
      return { ...request, priorityScore };
    })
  );
  
  return scoredRequests.sort((a, b) => b.priorityScore - a.priorityScore);
}

export async function decideModelRetraining(modelId: string): Promise<RetrainingDecision> {
  const performanceMetrics = await getModelPerformanceMetrics(modelId);
  const driftDetection = await detectModelDrift(modelId);
  const newDataAvailability = await checkNewTrainingData(modelId);
  
  const shouldRetrain = (
    performanceMetrics.recall < 0.7 ||
    performanceMetrics.precision < 0.6 ||
    driftDetection.driftScore > 0.3 ||
    newDataAvailability.significantNewData
  );
  
  if (shouldRetrain) {
    const retrainingPlan = await createRetrainingPlan(modelId, {
      performanceIssues: performanceMetrics,
      driftIssues: driftDetection,
      newData: newDataAvailability
    });
    
    return {
      decision: 'retrain',
      reasoning: generateRetrainingReasoning(performanceMetrics, driftDetection),
      plan: retrainingPlan,
      estimatedDuration: retrainingPlan.estimatedHours,
      priority: calculateRetrainingPriority(performanceMetrics, driftDetection)
    };
  }
  
  return {
    decision: 'no_action',
    reasoning: 'Model performance within acceptable thresholds',
    nextEvaluationDate: addWeeks(new Date(), 2)
  };
}

export default function Page() {
  return (
    <>
      <Hero
        title="Predict ESP & Rod Lift Failures Before They Happen"
        subtitle="AI early warning and prescriptive actions to cut downtime, deferment, and LOE across your field."
        ctaText="Request a Demo"
        ctaHref="/demo"
      />
      <Problem bullets={[
        "Unplanned ESP/rod lift failures drive production deferment and costly workovers",
        "Reactive maintenance extends MTTR and elevates HSE exposure",
        "SCADA, historian, and CMMS data are siloed—insight comes too late",
        "Alarm floods and false positives overwhelm engineers and operators"
      ]} />
      <Solution bullets={[
        "Predict imminent lift failures (days in advance) with confidence and failure-mode tagging",
        "Prescribe preventive actions: setpoint changes, speed ramps, chemical treatments, gas mitigation",
        "Prioritize wells by production at risk and time-to-failure for focused action",
        "Auto-orchestrate work orders, routes, and vendor notifications via CMMS integration"
      ]} />
      <Features items={[
        "Time-to-failure forecasts with confidence intervals",
        "Failure-mode classification: gas lock, vibration/wear, scale/sand, overheating, pump-off",
        "Prescriptive playbooks with step-by-step actions and expected impact",
        "Real-time streaming integrations: SCADA, historians, edge gateways",
        "CMMS connectors: SAP PM, IBM Maximo—auto-create and update work orders"
      ]} />
      <Steps steps={[
        "Connect: Hook up SCADA/historian, well tests, failure logs, and CMMS in days",
        "Calibrate: Train on your run histories; validate with lift SMEs and field trials",
        "Configure: Choose playbooks, alert thresholds, and integration endpoints",
        "Go Live: Start early warnings and prescriptive advisories to field teams"
      ]} />
    </>
  )
}

# LiftGuard AI

Generated for NAICS 211120 — Crude Petroleum Extraction.
Service: ESP/Rod Lift Failure Prediction & Advisory
