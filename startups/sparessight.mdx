---
name: SparesSight AI
slug: sparessight
naics:
  primary: '334516'
  occupations: []
service:
  title: Predictive Spare Parts Demand & Inventory Optimizer
  description: Forecasts parts demand and sets reorder/safety stocks by region and SLA.
  targetUsers:
    - Supply Chain
    - Service Logistics
    - Finance
  triggers:
    - Monthly/weekly planning run
    - Supplier lead-time changes
    - Install-base growth or advisories
  inputs:
    - Install base by model/region
    - Service history/MTBF/MTTR
    - Part BOM hierarchy
    - Lead times and min-order qty
    - SLAs and fill-rate targets
    - Seasonality/events
  steps:
    - Clean and join datasets; create failure cohorts
    - Time-series + survival models for part demand
    - 'Simulate scenarios (lead-time shocks, advisories)'
    - Optimize reorder points and safety stock by DC
    - Generate purchase plan and exceptions list
  tools:
    - ERP (SAP/Oracle) connectors
    - Snowflake/BigQuery
    - Prophet/ARIMA + survival models
    - OR-Tools for allocation
    - Power BI dashboards
  outputs:
    - 12–18 month forecasts per part/region
    - Reorder points/safety stock levels
    - Purchase order recommendations
    - Exception-driven alerts
  pricingModel:
    - Setup
    - Monthly subscription
    - Savings share option
  humanInLoop: false
  feasibility:
    remoteOnLaptop: 8
    modelCapability: 8
    overall: 8
  risks:
    - Data sparsity for new parts
    - Sudden regulatory or recall shocks
    - Inaccurate lead-time inputs
    - Change management in planning
  dependencies:
    - ERP/warehouse data access
    - Parts catalog/BOM
    - Historical service records
    - Approval to write planning outputs
leanCanvas:
  problem:
    - >-
      Long-tail, intermittent demand for spare parts causes 15–40% forecast
      error and chronic stockouts on critical parts.
    - >-
      Excess working capital tied up in parts inventory (often 20–35% above
      required levels) due to blanket min/max rules and lack of SLA-aware
      optimization.
    - >-
      SLA penalties and customer downtime when regional depots lack the right
      parts; inconsistent 2-hr/4-hr/NBD response performance across regions.
    - >-
      Fragmented data (ERP, PLM, FSM, service tickets, IoT) prevents reliable
      installed-base and failure-rate visibility.
    - >-
      Slow phase-in/phase-out management leads to obsolescence and scrapping
      (5–12% annually for certain part classes).
    - >-
      Manual planning in spreadsheets and generic tools does not handle
      multi-echelon networks or SLA-driven service levels.
    - >-
      Unreliable supplier and logistics lead-time variability not factored into
      safety stocks, causing bullwhip effects and backorders.
  solution:
    - >-
      Data unification layer that ingests ERP, FSM, PLM/BOM, supplier, and
      logistics data; reconciles part masters, supersessions, and installed-base
      metadata.
    - >-
      AI demand forecasting purpose-built for intermittent/long-tail parts
      (Croston/TSB variants, hierarchical models, reliability/Weibull survival
      analysis, fleet-usage signals).
    - >-
      SLA-aware multi-echelon inventory optimization that sets reorder points,
      safety stock, and min/max by region and response commitment
      (2-hr/4-hr/NBD).
    - >-
      Supplier and logistics risk modeling (lead-time distributions,
      variability, expedites) embedded into safety stock and reorder quantity
      calculations.
    - >-
      Scenario planning and what-if simulations (e.g., SLA tightening, NPI ramp,
      supply disruption, consolidation of FSLs) with P&L and working-capital
      impacts.
    - >-
      Automated phase-in/phase-out and supersession handling to minimize
      obsolescence and dead stock.
    - >-
      Planner copilot with natural-language queries, exception-based workflows,
      and explainable recommendations (feature attributions, demand drivers).
    - >-
      Closed-loop execution connectors to raise POs, update min/max in ERP, and
      publish stocking lists to depots; KPI tracking and governance dashboards.
  uniqueValueProp: >-
    Reduce service parts inventory 15–30% while achieving 97–99% fill rates on
    SLA-critical items, by fusing reliability-driven failure forecasts with SLA-
    and region-aware multi-echelon optimization. Deploy integrations to
    SAP/Oracle/ServiceMax in 60–90 days with auditable decisions and guaranteed
    ROI.
  unfairAdvantage: >-
    Purpose-built for analytical instrument spares: fused reliability +
    intermittent-demand models calibrated to installed-base age/usage and SLA
    commitments; SLA-aware multi-echelon optimization out-of-the-box; audited
    recommendations with ERP/FSM write-back; domain-specific connectors and
    supersession/EOL intelligence; reference benchmarks from design partners
    enabling faster time-to-value and defensible ROI.
  customerSegments:
    - >-
      Primary: OEMs manufacturing analytical laboratory instruments (NAICS
      334516) with global service networks; examples include chromatography, MS,
      spectroscopy, elemental analysis, and materials characterization OEMs.
    - >-
      Economic buyers: VP/Head of Global Service/Aftermarket, VP Supply Chain,
      Director of Service Logistics, CFO/COO (working capital focus).
    - >-
      Users: Global and regional spare parts planners, depot managers, S&OP for
      service, service operations analysts, reliability engineers.
    - >-
      Early adopters profile: 10k–200k installed-base units; 5k–50k spare part
      SKUs; multi-echelon networks (central DC, regional DCs, FSLs); SLAs of
      2-hr/4-hr/NBD; ERP (SAP/Oracle), FSM (ServiceMax/Salesforce/IFS).
    - >-
      Secondary: Third-party service providers and regional distributors
      servicing analytical instruments.
  channels:
    - >-
      Account-based sales to top 100 OEMs; land via 90-day proof-of-value on 2–3
      critical product lines and 3–5 regions.
    - >-
      Partnerships with SI/consulting partners (e.g., Deloitte, Accenture, TCS)
      for ERP/FSM integrations and change management.
    - >-
      Co-selling with field service platforms (ServiceMax, Salesforce FSL, IFS)
      and ERP marketplaces (SAP Store, Oracle Cloud Marketplace).
    - >-
      Industry events and associations: Pittcon, Analytica, SLAS, AACC;
      workshops on SLA-to-inventory economics.
    - >-
      Thought leadership: benchmark reports on service fill rate vs. working
      capital; ROI calculators; webinars with design partners.
    - >-
      Customer references and case studies quantifying inventory reduction and
      SLA improvements.
    - >-
      Targeted outbound to VP Service/Aftermarket and Service Logistics leaders;
      SDR sequences referencing installed-base scale and SLA pain.
    - >-
      Partner-led regional rollouts and distributor channels for mid-market
      OEMs.
  revenueStreams:
    - >-
      SaaS subscription priced by active spare-part SKUs and echelons: $3–$8 per
      SKU per month (volume-tiered). Example: 10k SKUs across 3 echelons ≈
      $360k–$960k annually.
    - >-
      Enterprise tier with unlimited users and advanced modules (reliability,
      scenario, obsolescence): $150k–$400k annual add-on.
    - >-
      Implementation/integration fees: $100k–$500k depending on systems and
      geographies; typical 8–16 weeks.
    - >-
      Value-based upside: 10–20% share of verified first-year inventory carrying
      cost reduction above a jointly agreed baseline.
    - >-
      Managed Planning Service (optional): $15k–$50k per month for exception
      handling, model stewardship, and S&OP for service support.
    - >-
      Training and premium support tiers: $25k–$75k annually; dedicated TAM and
      quarterly optimization reviews.
  costStructure:
    - >-
      Cloud infrastructure and data processing (compute, storage, data egress):
      $12k–$50k per large customer annually.
    - >-
      ML/data engineering and product team salaries; domain experts in
      reliability and service logistics.
    - Partner/SI commissions (10–20% of first-year ACV) and marketplace fees.
    - 'Security, compliance, and audits (SOC 2/ISO 27001): $75k–$200k per year.'
    - >-
      Go-to-market (ABM, events, SDRs, solution consultants): $5k–$20k CAC per
      enterprise lead.
    - >-
      Customer success and support, including on-site workshops and change
      management.
    - >-
      Data licensing (where applicable) for reference catalogs, geospatial
      lead-time data, and shipping time matrices.
  keyMetrics:
    - >-
      Forecast accuracy on intermittent demand: target MAPE ≤ 25% for class C
      items, ≤ 15% for class A; or MASE < 1.0 across portfolio.
    - >-
      Service fill rate: 97–99% for SLA-critical parts; 95–97% overall within 6
      months of go-live.
    - >-
      Inventory reduction: 15–30% reduction in working capital tied to service
      parts within 12 months.
    - >-
      Obsolescence/scrap reduction: 20–40% decrease year-over-year for SKUs with
      looming EOL/supersession.
    - >-
      Stockout rate: ≤ 2% on SLA-critical items; backorder days reduced by
      30–50%.
    - 'Inventory turns: improve by 20–40% while maintaining SLA targets.'
    - >-
      Planner productivity: 30–50% reduction in time spent on manual planning
      and expediting.
    - 'Time-to-value: first policy updates in 6 weeks; ROI > 3x within 12 months.'
    - >-
      Adoption: > 80% of policy recommendations accepted after first quarter; <
      10% override without model update reason codes.
storyBrand:
  character: >-
    Aftermarket and service operations leaders at analytical lab instrument
    manufacturers who must meet SLAs globally while controlling spare-parts
    inventory and service costs.
  problem: >-
    Volatile regional demand, long lead times, and unreliable forecasts cause
    stockouts, excess inventory, and SLA risk. Downtime for labs is
    unacceptable.
  guide: >-
    An AI inventory optimizer purpose-built for lab instrument OEMs. We
    understand SLA pressure and long-life parts, and apply supply-chain data
    science with secure ERP and CMMS integrations to forecast demand and set
    optimal stocks by region and SLA.
  plan: >-
    Connect ERP, field service, and install-base data, then forecast regional
    part demand by SLA and lead time, then set reorder points, safety stock, and
    transfer rules, then monitor and tune monthly. Start with a 6-week pilot and
    clear ROI targets.
  callToAction: >-
    Direct - Book a pilot. Transitional - Request a free spare-parts volatility
    and fill-rate diagnostic.
  success: >-
    Right part, right place, right time. Higher fill rates, fewer expedites, SLA
    compliance, lower carrying costs and obsolescence, happier customers, and
    planners who trust the numbers.
  failure: >-
    Persistent stockouts and overstock, expedited freight, missed SLAs and
    downtime penalties, write-offs, frustrated customers, and burned-out
    planners.
landingPage:
  hero:
    title: Predictive Spare Parts Demand & Inventory Optimizer
    subtitle: >-
      AI for Analytical Lab Instrument Manufacturing (NAICS 334516). Forecast
      demand and set SLA-aware reorder and safety stocks by region.
    ctaText: Request demo
    ctaHref: /demo
  problem:
    - Stockouts drive SLA penalties and customer downtime
    - Excess inventory and slow turns on long-tail parts
    - Volatile regional demand and long supplier lead times
    - Obsolescence from rapid part revisions and EOL
    - 'Manual, inconsistent forecasts across depots'
    - Safety stocks not aligned to criticality or SLA tiers
    - 'Fragmented data across ERP, CMMS, and field depots'
    - Limited visibility into upcoming risk and service impact
  solution:
    - 'Forecast demand by part, region, and install base'
    - Set SLA-aware reorder points and safety stocks automatically
    - Optimize allocation across central and field depots
    - Model lead times and supplier risk to buffer intelligently
    - 'Run what-if scenarios for launches, EOL, and demand shocks'
    - Auto-generate PO and transfer recommendations with approvals
    - 'Real-time alerts for stockout, expiry, and obsolescence risk'
    - Integrate with ERP/CMMS for seamless execution
  features:
    - 'Multi-horizon forecasting (weekly/monthly, 3–18 months)'
    - Hierarchical models for intermittent and sparse parts
    - Dynamic buffers by SLA tier and part criticality
    - Regional depot and network optimization
    - Install base and usage telemetry ingestion
    - 'What-if simulator: lead time, MOQ, demand spikes'
    - Auto-PO creation and inter-depot transfer workflows
    - 'Connectors: SAP, Oracle, Infor; ServiceMax, Salesforce FSL'
    - 'Dashboards: fill rate, turns, backorders, SLA attainment'
    - 'Alerting via email, Slack, and Teams'
    - 'SSO, role-based access, audit trails, SOC 2-aligned'
    - API-first architecture for custom integrations
  steps:
    - 'Connect ERP, CMMS, depot inventory, and SLA data'
    - 'Map parts to instruments, BOM, and criticality tiers'
    - Calibrate models and validate against history
    - Review forecasts and inventory policy recommendations
    - Approve and automate replenishment and transfers
    - Monitor KPIs and refine quarterly with expert tuning
---
# SparesSight AI

Generated for NAICS 334516 — Analytical Laboratory Instrument Manufacturing.
Service: Predictive Spare Parts Demand & Inventory Optimizer

## Business Workflow Functions

```typescript
// Core business types
interface Lead {
  companyName: string;
  industry: string;
  installedBaseSize: number;
  spareParts: number;
  currentSLAs: string[];
  painPoints: string[];
  contactInfo: ContactInfo;
}

interface Customer {
  id: string;
  companyProfile: CompanyProfile;
  contract: Contract;
  integrationStatus: IntegrationStatus;
  kpis: CustomerKPIs;
}

interface ForecastModel {
  partId: string;
  region: string;
  demandHistory: number[];
  seasonalFactors: number[];
  reliabilityData: WeibullParameters;
  slaRequirements: SLAConfig;
}

interface InventoryPolicy {
  partId: string;
  region: string;
  reorderPoint: number;
  safetyStock: number;
  maxStock: number;
  leadTime: number;
  serviceLevel: number;
}

// Customer Acquisition Workflows
export async function acquireCustomer(lead: Lead): Promise<Customer> {
  const qualifiedLead = await qualifyLead(lead);
  const proposal = await generateProposal(qualifiedLead);
  const pilot = await conductPilot(proposal);
  const contract = await negotiateContract(pilot);
  return await onboardCustomer(contract);
}

export async function qualifyLead(lead: Lead): Promise<QualifiedLead> {
  // Validate minimum criteria: 10k+ installed base, 5k+ spare parts
  if (lead.installedBaseSize < 10000 || lead.spareParts < 5000) {
    throw new Error('Lead does not meet minimum criteria');
  }
  
  const fitScore = await calculateFitScore(lead);
  const painPointAnalysis = await analyzePainPoints(lead.painPoints);
  const roiEstimate = await estimateROI(lead);
  
  return {
    ...lead,
    fitScore,
    painPointAnalysis,
    roiEstimate,
    priority: fitScore > 80 ? 'high' : fitScore > 60 ? 'medium' : 'low'
  };
}

export async function generateProposal(qualifiedLead: QualifiedLead): Promise<Proposal> {
  const scopeDefinition = await definePilotScope(qualifiedLead);
  const technicalArchitecture = await designTechnicalSolution(qualifiedLead);
  const pricingModel = await calculatePricing(qualifiedLead);
  const timeline = await createImplementationTimeline(scopeDefinition);
  
  return {
    customerId: qualifiedLead.companyName,
    scope: scopeDefinition,
    architecture: technicalArchitecture,
    pricing: pricingModel,
    timeline,
    expectedROI: qualifiedLead.roiEstimate
  };
}

// Product Development Processes
export async function developForecastingModel(customerData: CustomerData): Promise<ForecastModel> {
  const cleanedData = await unifyDataSources(customerData);
  const demandPatterns = await analyzeIntermittentDemand(cleanedData);
  const reliabilityModel = await buildWeibullSurvivalModel(cleanedData);
  const hierarchicalModel = await trainHierarchicalForecast(demandPatterns);
  
  return await validateAndCalibrateForecast({
    ...hierarchicalModel,
    reliabilityFactors: reliabilityModel,
    validationMetrics: await calculateMAPE(hierarchicalModel, cleanedData)
  });
}

export async function optimizeInventoryPolicy(
  forecastModel: ForecastModel,
  slaRequirements: SLAConfig,
  supplierData: SupplierData
): Promise<InventoryPolicy> {
  const demandDistribution = await simulateDemandScenarios(forecastModel);
  const leadTimeVariability = await modelSupplierRisk(supplierData);
  const serviceLevel = await calculateRequiredServiceLevel(slaRequirements);
  
  const optimization = await solveMultiEchelonOptimization({
    demand: demandDistribution,
    leadTime: leadTimeVariability,
    serviceLevel,
    holdingCosts: await getHoldingCosts(forecastModel.partId),
    stockoutCosts: await getStockoutCosts(slaRequirements)
  });
  
  return {
    partId: forecastModel.partId,
    region: forecastModel.region,
    reorderPoint: optimization.reorderPoint,
    safetyStock: optimization.safetyStock,
    maxStock: optimization.maxStock,
    leadTime: optimization.expectedLeadTime,
    serviceLevel: optimization.achievedServiceLevel
  };
}

// Revenue Generation Flows
export async function generateRevenue(customer: Customer): Promise<RevenueEvent> {
  const subscriptionRevenue = await processSubscriptionBilling(customer);
  const implementationRevenue = await billImplementationFees(customer);
  const valueBasedRevenue = await calculateValueBasedUpside(customer);
  const supportRevenue = await billSupportServices(customer);
  
  return {
    customerId: customer.id,
    totalRevenue: subscriptionRevenue + implementationRevenue + valueBasedRevenue + supportRevenue,
    breakdown: {
      subscription: subscriptionRevenue,
      implementation: implementationRevenue,
      valueBased: valueBasedRevenue,
      support: supportRevenue
    },
    billingDate: new Date(),
    paymentTerms: customer.contract.paymentTerms
  };
}

export async function calculateSubscriptionRevenue(customer: Customer): Promise<number> {
  const activeSKUs = await getActiveSKUCount(customer);
  const echelonCount = await getEchelonCount(customer);
  const tierMultiplier = customer.contract.tier === 'enterprise' ? 1.5 : 1.0;
  
  const basePrice = activeSKUs * 5; // $5 per SKU per month average
  const echelonMultiplier = Math.sqrt(echelonCount); // Economies of scale
  
  return basePrice * echelonMultiplier * tierMultiplier;
}

// Operational Procedures
export async function executeMonthlyPlanningRun(customer: Customer): Promise<PlanningResults> {
  const latestData = await extractCustomerData(customer);
  const updatedForecasts = await refreshForecastModels(latestData);
  const optimizedPolicies = await reoptimizeInventoryPolicies(updatedForecasts);
  const purchaseRecommendations = await generatePurchaseOrders(optimizedPolicies);
  const exceptions = await identifyPlanningExceptions(optimizedPolicies);
  
  await publishResultsToERP(customer, purchaseRecommendations);
  await notifyPlanners(customer, exceptions);
  
  return {
    customerId: customer.id,
    forecastAccuracy: await measureForecastAccuracy(updatedForecasts),
    inventoryReduction: await calculateInventoryReduction(optimizedPolicies),
    fillRateImprovement: await measureFillRateImprovement(customer),
    recommendationsGenerated: purchaseRecommendations.length,
    exceptionsRaised: exceptions.length
  };
}

export async function handleSupplierLeadTimeChange(
  supplierId: string,
  newLeadTime: number,
  affectedParts: string[]
): Promise<void> {
  for (const partId of affectedParts) {
    const currentPolicy = await getInventoryPolicy(partId);
    const updatedPolicy = await recalculatePolicy(currentPolicy, { leadTime: newLeadTime });
    await updateInventoryPolicy(partId, updatedPolicy);
    await notifyPlanners({
      type: 'LEAD_TIME_CHANGE',
      partId,
      oldLeadTime: currentPolicy.leadTime,
      newLeadTime,
      policyChanges: updatedPolicy
    });
  }
}

// Decision-Making Workflows
export async function evaluateNewCustomerFit(lead: Lead): Promise<CustomerFitDecision> {
  const technicalFit = await assessTechnicalFit(lead);
  const commercialFit = await assessCommercialFit(lead);
  const strategicFit = await assessStrategicFit(lead);
  const riskAssessment = await assessImplementationRisk(lead);
  
  const overallScore = (technicalFit.score + commercialFit.score + strategicFit.score) / 3;
  const adjustedScore = overallScore * (1 - riskAssessment.riskFactor);
  
  return {
    decision: adjustedScore > 75 ? 'PURSUE' : adjustedScore > 50 ? 'EVALUATE' : 'DECLINE',
    score: adjustedScore,
    reasoning: {
      technical: technicalFit.reasoning,
      commercial: commercialFit.reasoning,
      strategic: strategicFit.reasoning,
      risks: riskAssessment.risks
    },
    recommendedActions: await generateRecommendedActions(adjustedScore, riskAssessment)
  };
}

export async function decidePricingStrategy(
  customer: Customer,
  competitiveIntel: CompetitiveIntelligence
): Promise<PricingDecision> {
  const valueDelivered = await calculateValueDelivered(customer);
  const competitivePosition = await analyzeCompetitivePosition(competitiveIntel);
  const customerWillingness = await estimateWillingnessToPay(customer);
  const costStructure = await calculateCustomerCostStructure(customer);
  
  const recommendedPrice = Math.min(
    valueDelivered * 0.3, // 30% of value delivered
    customerWillingness * 0.9, // 90% of willingness to pay
    competitivePosition.marketPrice * 1.1 // 10% premium to market
  );
  
  return {
    recommendedPrice,
    strategy: await selectPricingStrategy(recommendedPrice, costStructure),
    justification: await generatePricingJustification(valueDelivered, competitivePosition),
    negotiationRange: {
      floor: costStructure.totalCost * 1.2, // 20% margin minimum
      ceiling: valueDelivered * 0.4 // 40% of value delivered maximum
    }
  };
}

// Integration and Data Processing Workflows
export async function integrateCustomerSystems(customer: Customer): Promise<IntegrationStatus> {
  const erpIntegration = await connectERP(customer.systems.erp);
  const fsmIntegration = await connectFSM(customer.systems.fsm);
  const plmIntegration = await connectPLM(customer.systems.plm);
  const dataValidation = await validateDataQuality([erpIntegration, fsmIntegration, plmIntegration]);
  
  if (dataValidation.quality < 0.8) {
    throw new Error(`Data quality insufficient: ${dataValidation.issues.join(', ')}`);
  }
  
  return {
    customerId: customer.id,
    systems: {
      erp: erpIntegration.status,
      fsm: fsmIntegration.status,
      plm: plmIntegration.status
    },
    dataQuality: dataValidation.quality,
    readyForProduction: dataValidation.quality > 0.9,
    nextSteps: await generateIntegrationNextSteps(dataValidation)
  };
}

// Monitoring and Success Measurement
export async function measureCustomerSuccess(customer: Customer): Promise<SuccessMetrics> {
  const inventoryReduction = await measureInventoryReduction(customer);
  const fillRateImprovement = await measureFillRateImprovement(customer);
  const forecastAccuracy = await measureForecastAccuracy(customer);
  const slaCompliance = await measureSLACompliance(customer);
  const costSavings = await calculateCostSavings(customer);
  
  return {
    customerId: customer.id,
    metrics: {
      inventoryReduction: inventoryReduction.percentage,
      fillRate: fillRateImprovement.current,
      forecastAccuracy: forecastAccuracy.mape,
      slaCompliance: slaCompliance.percentage,
      annualSavings: costSavings.annual
    },
    roi: costSavings.annual / customer.contract.annualValue,
    healthScore: await calculateCustomerHealthScore({
      inventoryReduction,
      fillRateImprovement,
      forecastAccuracy,
      slaCompliance
    }),
    renewalProbability: await predictRenewalProbability(customer)
  };
}
```
