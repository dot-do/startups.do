---
name: AleraSight — Production Surveillance & Anomaly Early Warning
slug: alerasight-production-surveillance-anomaly-early-warning
naics:
  primary: '211120'
  occupations: []
service:
  title: Production Surveillance & Anomaly Early Warning
  description: >-
    Detect abnormal well/facility behavior in near-real-time and recommend
    likely causes and first actions.
  targetUsers:
    - Production Engineers
    - Control Room Operators
    - Field Supervisors
  triggers:
    - Hourly/daily schedule
    - New historian data arrival webhook
    - User request for a date range
  inputs:
    - 'Historian tags (pressures, rates, temperatures, WC)'
    - Downtime/event logs
    - 'Well metadata (lift type, reservoir, wellbore config)'
    - Daily production reports
  steps:
    - Secure connect to historian via API; load last N hours/days
    - Clean/resample; map tags to wells; handle sensor dropouts
    - 'Run anomaly detection (trend/level/variance, multivariate)'
    - Correlate with events/logs to suggest likely root causes
    - Generate ranked alerts with confidence and recommended checks
    - Notify via chat/email and optionally open a CMMS ticket
  tools:
    - OSIsoft PI Web API or AVEVA PI Web API
    - Azure Data Explorer/Kusto or TimescaleDB
    - scikit-learn/Prophet/XGBoost
    - Grafana/Power BI
    - Slack/Teams API
    - SAP PM/IBM Maximo API
  outputs:
    - Ranked anomaly list with suspected cause and impact
    - Operator checklist and plots
    - Created/updated tickets with context
    - CSV/JSON export and dashboard link
  pricingModel:
    - One-time setup + data mapping
    - Per-well or per-facility monthly subscription
    - Optional per-alert SLA add-on
  humanInLoop: true
  feasibility:
    remoteOnLaptop: 4
    modelCapability: 4
    overall: 4
  risks:
    - Poor tag mapping/data quality causing false alarms
    - Alert fatigue
    - Limited network access to on-prem historians
    - Operational changes require human approval
  dependencies:
    - VPN/API access to historian
    - Tag dictionary and well hierarchy
    - Access to event/downtime codes
    - CMMS integration credentials
leanCanvas:
  problem:
    - >-
      Unplanned downtime from artificial lift and facility upsets (ESPs, rod
      pumps, gas lift, separators, compressors) causes deferred production and
      costly workovers.
    - >-
      SCADA alarms are noisy and rule-based; true anomalies are detected late or
      buried in false positives, increasing MTTR and OPEX.
    - >-
      Field teams are stretched; they need prescriptive first actions, not just
      alerts, to reduce truck rolls and nighttime callouts.
    - >-
      Anomalies (carryover, liquid loading, separator pressure excursions) lead
      to flaring/methane events, impacting regulatory fees and ESG KPIs.
    - >-
      Data is fragmented (SCADA, PI/AF, historian, PLCs) and connectivity
      varies; operators need low-latency detection that works at the edge with
      unreliable links.
    - >-
      Traditional analytics projects are long and expensive; operators need
      weeks-to-value and measurable, contract-backed outcomes.
  solution:
    - >-
      Streaming, multivariate anomaly detection for wells and facilities (1–2
      minute latency) with probabilistic root-cause ranking and recommended
      first actions.
    - >-
      Edge+cloud architecture: run lightweight models at the pad/facility (OPC
      UA/Modbus/ MQTT/PI) with cloud training and fleet benchmarking.
    - >-
      Prescriptive playbooks mapped to failure modes (e.g., gas interference,
      pump-off, paraffin/asphaltene deposition, separator carryover,
      suction/discharge restrictions).
    - >-
      Alarm rationalization layer that suppresses nuisance alarms and escalates
      high-confidence events to the control room, mobile, and CMMS.
    - >-
      Emissions-aware anomalies (flaring spikes, tank venting, compressor seal
      leaks) with event quantification for reporting and fee avoidance.
    - >-
      Rapid deployment accelerators: prebuilt connectors (PI/AF, AVEVA,
      Ignition, Kepware), template models by lift type, and guided 8–12 week
      pilots.
  uniqueValueProp: >-
    Detect, diagnose, and act on well and facility anomalies within
    minutes—cutting false alarms by >50%, reducing MTTA/MTTR, and recovering
    barrels while lowering methane intensity—with fast integration to SCADA/PI
    and prescriptive first actions proven in field playbooks.
  unfairAdvantage: >-
    A curated, cross-basin library of labeled failure signatures and
    prescriptive playbooks tied to actual work orders and outcomes;
    edge-certified connectors for rapid, low-latency deployments in OT
    environments; and quantified, contract-backed impact reporting that
    accelerates operator buy-in and expansion.
  customerSegments:
    - >-
      Mid-size onshore E&P operators (2,000–20,000 wells) using rod pump, ESP,
      and gas-lift across North American basins.
    - >-
      Large integrated operators’ North America business units seeking scalable
      anomaly detection for centralized control rooms.
    - >-
      Saltwater disposal (SWD) and midstream gathering operators monitoring
      compressors, LACT units, and tank batteries.
    - >-
      Operations centers and production engineering teams (artificial lift,
      facility reliability, maintenance planners).
    - >-
      Digital/IT organizations responsible for historians, SCADA, and cloud data
      platforms in oil and gas.
  channels:
    - >-
      Direct enterprise sales to E&P operations and digital leaders;
      land-and-expand via BU pilots.
    - >-
      Alliances with SCADA/historian vendors and SIs (OSIsoft/AVEVA PI partners,
      Inductive Automation, Rockwell/Emerson/ABB integrators).
    - >-
      Cloud marketplaces (AWS, Azure) with private offers to streamline
      procurement.
    - >-
      OEM partnerships with artificial lift providers and compressor vendors to
      bundle early-warning analytics with equipment/service contracts.
    - >-
      Co-marketing at oil and gas events (SPE ATCE, URTeC, DUG, NAPE, ADIPEC)
      and basin-specific workshops/webinars.
    - >-
      Regulatory/ESG channel: collaborate with methane reporting platforms to
      offer anomaly-to-emissions workflows.
  revenueStreams:
    - >-
      SaaS subscription per monitored asset: wells ($150–$400 per well/month)
      and facilities ($300–$800 per facility/month), tiered by data rate and
      features.
    - >-
      Enterprise plans with volume discounts, multi-basin pricing, and 24/7
      support SLAs.
    - >-
      Add-on modules: emissions anomaly quantification/reporting (+$0.02–$0.05
      per mcfe processed events), mobile offline mode, and API access.
    - >-
      Professional services: integration, model onboarding, alarm
      rationalization workshops ($30k–$150k fixed-scope).
    - >-
      Outcome-based bonuses where permitted: share of recovered barrels/downtime
      avoided after baseline (e.g., 5–10% of validated uplift).
  costStructure:
    - 'R&D and model development (ML engineers, petroleum and facilities SMEs).'
    - >-
      Cloud compute/storage/streaming (ingest, training, edge orchestration) and
      observability costs.
    - >-
      Edge gateway software certification and limited hardware pass-through for
      sites needing new gateways.
    - 'Security and compliance (SOC 2, penetration testing, OT security reviews).'
    - >-
      Data integration/connectors licensing and maintenance (PI/AF, OPC UA
      stacks, MQTT brokers).
    - >-
      Go-to-market costs (enterprise sales, pilots, travel to field sites,
      industry events).
    - Customer success and support (24/7 coverage for control rooms).
  keyMetrics:
    - >-
      Technical: detection lead time vs. process limit breach (target: >30
      minutes for facilities, >10 minutes for wells), precision/recall (target:
      >0.8/0.7 after 60 days), false positive rate per 1,000 tag-hours (target:
      <2).
    - >-
      Operational: end-to-end alert latency (target: <2 min P95), service
      availability (target: 99.9%), model drift incidents per month (target: <1
      per 1,000 models).
    - >-
      Business impact: deferred production avoided (bbl/day), compressor uptime
      (%), truck rolls reduced (target: -20%), MTTA (target: -40%), MTTR
      (target: -25%), methane intensity reduction (kg CH4/boe; target: -10–25%).
    - >-
      Commercial: pilot conversion rate (target: >50%), time-to-value (first
      validated save <30 days), gross margin (target: 75–85%), NRR (target:
      >130%), LTV/CAC (>3).
storyBrand:
  character: >-
    Production and operations leaders at E&P companies who want stable, safe
    wells and facilities with early warning and clear first actions to keep
    barrels flowing
  problem: >-
    True anomalies hide in noisy SCADA data and teams cannot watch every tag.
    Early signals are missed, alarms are ignored, and issues snowball into
    downtime, equipment damage, and HSE exposure
  guide: >-
    We understand field realities from ESP trips to separator upsets. Our AI
    monitors wells and facilities in near real time, flags abnormal behavior,
    explains likely causes, and suggests first actions. Built by production
    engineers and data scientists and integrated securely with your SCADA and
    historians
  plan: >-
    Connect data and define assets and alert routing; calibrate on recent
    history and validate with your engineers; go live with role based alerts,
    prioritized root cause hypotheses, and playbooks; iterate with weekly ops
    reviews and clear KPIs
  callToAction: >-
    Book a 30 minute demo and launch a 60 day pilot on a subset of wells and
    facilities with agreed success criteria
  success: >-
    Catch problems hours sooner, prevent shut ins, shorten MTTR, reduce callouts
    and site visits, lower OPEX and emissions, improve safety and compliance,
    and sustain higher production with confidence
  failure: >-
    Without proactive surveillance, small deviations escalate into failures
    including lost barrels, equipment damage, flaring or spills, regulatory
    hits, and exhausted teams firefighting alarms
landingPage:
  hero:
    title: Production Surveillance & Anomaly Early Warning
    subtitle: >-
      AI for crude petroleum extraction that flags abnormal well and facility
      behavior in near‑real‑time, suggests likely causes, and recommends first
      actions before downtime and deferred barrels stack up.
    ctaText: Request a demo
    ctaHref: /demo
  problem:
    - 'Subtle drifts in pressure, flow, or power go unnoticed until failures'
    - SCADA threshold storms overwhelm teams with false alarms
    - Manual triage steals engineer time; nights and weekends go uncovered
    - >-
      Late detection leads to deferred production, equipment damage, and HSE
      risk
    - Tribal knowledge is inconsistent and hard to scale
    - 'Data is scattered across SCADA, historians, and spreadsheets'
    - Compliance and flaring risk spikes during facility upsets
  solution:
    - '24/7 multivariate monitoring across wells, pads, and facilities'
    - Adaptive baselines by lift type and operating regime
    - Early anomaly alerts with severity and confidence
    - >-
      Likely-cause hypotheses (e.g., gas lock, pump‑off, hydrate, sand,
      slugging)
    - Step‑by‑step first actions tailored to the asset
    - Smart routing to the right people via email/SMS/Teams
    - 'Impact estimation: barrels at risk, downtime and flare risk'
    - Feedback loop to continuously improve accuracy
  features:
    - >-
      Plug‑and‑play integrations: SCADA (OPC UA/Modbus), PI/CygNet/Ignition,
      AWS/Azure
    - >-
      Prebuilt models for ESP, rod lift, gas lift, plunger lift, separators,
      compressors
    - 'Streaming analytics at 1–60s cadence, edge or cloud'
    - >-
      Multivariate anomaly detection on pressure, rate, temperature, current,
      vibration
    - Regime‑aware baselines that adapt to choke and setpoint changes
    - Root‑cause ranking with explainability and evidence snapshots
    - Recommended actions with confidence and estimated time‑to‑fix
    - 'Alert policies with severity, dwell time, and suppression windows'
    - >-
      Role‑based access, audit trails, SSO/SAML; encryption in transit and at
      rest
    - Low‑bandwidth tolerant with store‑and‑forward
    - 'Fleet map, heatmaps, and KPIs like deferred bbl/d'
    - 'Ticketing and CMMS integration (ServiceNow, Jira) and work orders'
    - Mobile‑friendly alerts with trend thumbnails
    - VPC or on‑prem deployment options to fit security posture
  steps:
    - Connect SCADA and historian data in days
    - Auto‑discover assets and lift types; import and map tags
    - Train baselines from 30–90 days of history; set alert policies
    - Calibrate with SMEs; finalize playbooks for first actions
    - Go live with targeted routing and measurable outcomes
    - Continuously learn from feedback and closed tickets
    - 'Scale to additional fields, facilities, and equipment'
---
# AleraSight — Production Surveillance & Anomaly Early Warning

Generated for NAICS 211120 — Crude Petroleum Extraction.
Service: Production Surveillance & Anomaly Early Warning

## Business Process Functions

```typescript
// Core business entities
interface Lead {
  id: string;
  company: string;
  contactName: string;
  email: string;
  phone: string;
  wellCount: number;
  facilityCount: number;
  currentSCADASystem: string;
  painPoints: string[];
  budget: number;
  timeline: string;
  decisionMakers: string[];
}

interface QualifiedLead extends Lead {
  fitScore: number;
  urgencyScore: number;
  budgetConfirmed: boolean;
  technicalRequirements: TechnicalRequirements;
}

interface TechnicalRequirements {
  historianType: 'PI' | 'AVEVA' | 'Ignition' | 'CygNet' | 'Other';
  dataConnectivity: 'VPN' | 'Direct' | 'Cloud';
  edgeCapability: boolean;
  complianceRequirements: string[];
  integrationPoints: string[];
}

interface Pilot {
  id: string;
  customerId: string;
  scope: PilotScope;
  duration: number; // weeks
  successCriteria: SuccessCriteria;
  timeline: PilotTimeline;
  budget: number;
}

interface PilotScope {
  wellCount: number;
  facilityCount: number;
  liftTypes: string[];
  dataPoints: number;
  alertTypes: string[];
}

interface SuccessCriteria {
  falsePositiveReduction: number; // percentage
  detectionLeadTime: number; // minutes
  mttrReduction: number; // percentage
  deferredProductionRecovery: number; // barrels/day
}

interface Customer {
  id: string;
  company: string;
  tier: 'Startup' | 'Growth' | 'Enterprise';
  contractValue: number;
  deploymentStatus: 'Pilot' | 'Production' | 'Expansion';
  assets: MonitoredAsset[];
  subscription: Subscription;
}

interface MonitoredAsset {
  id: string;
  type: 'Well' | 'Facility';
  liftType?: 'ESP' | 'RodPump' | 'GasLift' | 'PlungerLift';
  facilityType?: 'Separator' | 'Compressor' | 'LACT' | 'TankBattery';
  dataPoints: string[];
  alertPolicies: AlertPolicy[];
}

interface AlertPolicy {
  severity: 'Low' | 'Medium' | 'High' | 'Critical';
  dwellTime: number; // minutes
  suppressionWindow: number; // minutes
  escalationRules: EscalationRule[];
}

interface EscalationRule {
  timeToEscalate: number; // minutes
  recipients: string[];
  channels: ('Email' | 'SMS' | 'Teams' | 'CMMS')[];
}

interface Subscription {
  plan: 'Pilot' | 'Standard' | 'Professional' | 'Enterprise';
  wellsIncluded: number;
  facilitiesIncluded: number;
  monthlyRecurring: number;
  addOns: AddOn[];
}

interface AddOn {
  name: string;
  description: string;
  monthlyFee: number;
}

// Customer Acquisition Workflows
export async function acquireCustomer(lead: Lead): Promise<Customer> {
  const qualifiedLead = await qualifyLead(lead);
  const proposal = await generateProposal(qualifiedLead);
  const pilot = await negotiatePilot(proposal);
  const pilotResults = await executePilot(pilot);
  const contract = await negotiateContract(pilotResults);
  return await onboardCustomer(contract);
}

export async function qualifyLead(lead: Lead): Promise<QualifiedLead> {
  // Score lead based on fit criteria
  const fitScore = await calculateFitScore(lead);
  const urgencyScore = await assessUrgency(lead);
  const budgetConfirmed = await confirmBudget(lead);
  const technicalRequirements = await assessTechnicalRequirements(lead);
  
  if (fitScore < 0.6 || !budgetConfirmed) {
    throw new Error('Lead does not meet qualification criteria');
  }
  
  return {
    ...lead,
    fitScore,
    urgencyScore,
    budgetConfirmed,
    technicalRequirements
  };
}

export async function generateProposal(qualifiedLead: QualifiedLead): Promise<Pilot> {
  const scope = await definePilotScope(qualifiedLead);
  const successCriteria = await defineSuccessCriteria(qualifiedLead);
  const timeline = await createPilotTimeline(scope);
  const budget = await calculatePilotBudget(scope);
  
  return {
    id: generateId(),
    customerId: qualifiedLead.id,
    scope,
    duration: 8, // 8-week pilot
    successCriteria,
    timeline,
    budget
  };
}

export async function executePilot(pilot: Pilot): Promise<PilotResults> {
  await deployEdgeGateways(pilot);
  await configureDataConnections(pilot);
  await trainAnomalyModels(pilot);
  await calibrateAlertPolicies(pilot);
  const results = await monitorPilotPerformance(pilot);
  await generatePilotReport(results);
  return results;
}

// Product Development Processes
export async function developAnomalyModel(assetType: string, liftType?: string): Promise<AnomalyModel> {
  const trainingData = await collectTrainingData(assetType, liftType);
  const labeledData = await labelAnomalies(trainingData);
  const model = await trainModel(labeledData);
  const validatedModel = await validateModel(model);
  await deployModelToEdge(validatedModel);
  return validatedModel;
}

export async function enhancePlaybooks(failureMode: string): Promise<Playbook> {
  const historicalCases = await queryHistoricalCases(failureMode);
  const expertKnowledge = await captureExpertKnowledge(failureMode);
  const playbook = await synthesizePlaybook(historicalCases, expertKnowledge);
  const validatedPlaybook = await validateWithSMEs(playbook);
  await deployPlaybook(validatedPlaybook);
  return validatedPlaybook;
}

export async function integrateDataSource(sourceType: string, customer: Customer): Promise<Integration> {
  const connector = await selectConnector(sourceType);
  const credentials = await configureCredentials(customer, sourceType);
  const tagMapping = await mapTags(customer, sourceType);
  const integration = await testConnection(connector, credentials, tagMapping);
  await deployIntegration(integration);
  return integration;
}

// Revenue Generation Flows
export async function processSubscriptionBilling(customer: Customer): Promise<Invoice> {
  const usage = await calculateUsage(customer);
  const baseCharges = await calculateBaseCharges(customer.subscription);
  const addOnCharges = await calculateAddOnCharges(customer.subscription.addOns, usage);
  const invoice = await generateInvoice(customer, baseCharges, addOnCharges);
  await sendInvoice(invoice);
  return invoice;
}

export async function expandCustomerAccount(customer: Customer, expansionRequest: ExpansionRequest): Promise<Customer> {
  const feasibilityAssessment = await assessExpansionFeasibility(expansionRequest);
  const updatedPricing = await calculateExpansionPricing(customer, expansionRequest);
  const contract = await negotiateExpansionContract(customer, updatedPricing);
  const updatedCustomer = await deployExpansion(customer, expansionRequest);
  await updateBillingPlan(updatedCustomer);
  return updatedCustomer;
}

export async function deliverProfessionalServices(customer: Customer, serviceType: string): Promise<ServiceDelivery> {
  const statement = await createStatementOfWork(customer, serviceType);
  const team = await assignServiceTeam(statement);
  const delivery = await executeService(team, statement);
  const results = await validateServiceResults(delivery);
  await invoiceServices(customer, results);
  return delivery;
}

// Operational Procedures
export async function monitorSystemHealth(): Promise<HealthReport> {
  const edgeGatewayStatus = await checkEdgeGateways();
  const cloudInfrastructure = await checkCloudInfrastructure();
  const modelPerformance = await checkModelPerformance();
  const dataQuality = await checkDataQuality();
  const alertLatency = await checkAlertLatency();
  
  const healthReport = {
    timestamp: new Date(),
    edgeGatewayStatus,
    cloudInfrastructure,
    modelPerformance,
    dataQuality,
    alertLatency,
    overallHealth: calculateOverallHealth([
      edgeGatewayStatus,
      cloudInfrastructure,
      modelPerformance,
      dataQuality,
      alertLatency
    ])
  };
  
  if (healthReport.overallHealth < 0.95) {
    await escalateHealthIssue(healthReport);
  }
  
  return healthReport;
}

export async function handleCustomerAlert(alert: CustomerAlert): Promise<AlertResolution> {
  const severity = await classifyAlertSeverity(alert);
  const rootCause = await diagnoseRootCause(alert);
  const playbook = await retrievePlaybook(rootCause);
  const recommendations = await generateRecommendations(playbook, alert);
  
  await notifyCustomer(alert, recommendations);
  await createCMMSTicket(alert, recommendations);
  
  const resolution = await trackResolution(alert);
  await updateModelFeedback(alert, resolution);
  
  return resolution;
}

export async function performMaintenanceWindow(customer: Customer): Promise<MaintenanceResult> {
  await notifyCustomerMaintenance(customer);
  await pauseAlerting(customer);
  
  const modelUpdates = await deployModelUpdates(customer);
  const configUpdates = await updateConfigurations(customer);
  const systemUpdates = await updateSystemComponents(customer);
  
  await resumeAlerting(customer);
  await validatePostMaintenance(customer);
  await notifyMaintenanceComplete(customer);
  
  return {
    modelUpdates,
    configUpdates,
    systemUpdates,
    success: true
  };
}

// Decision-Making Workflows
export async function evaluateCustomerRenewal(customer: Customer): Promise<RenewalDecision> {
  const usageAnalysis = await analyzeCustomerUsage(customer);
  const satisfactionScore = await calculateSatisfactionScore(customer);
  const businessImpact = await measureBusinessImpact(customer);
  const competitiveRisk = await assessCompetitiveRisk(customer);
  
  const renewalProbability = await calculateRenewalProbability({
    usageAnalysis,
    satisfactionScore,
    businessImpact,
    competitiveRisk
  });
  
  if (renewalProbability < 0.7) {
    await initiateRetentionCampaign(customer);
  }
  
  const renewalStrategy = await developRenewalStrategy(customer, renewalProbability);
  
  return {
    customer,
    renewalProbability,
    strategy: renewalStrategy,
    actionItems: await generateRenewalActionItems(renewalStrategy)
  };
}

export async function prioritizeProductRoadmap(features: FeatureRequest[]): Promise<RoadmapPriority[]> {
  const customerDemand = await analyzeCustomerDemand(features);
  const technicalComplexity = await assessTechnicalComplexity(features);
  const businessValue = await calculateBusinessValue(features);
  const competitiveAdvantage = await evaluateCompetitiveAdvantage(features);
  
  const priorityScores = features.map(feature => ({
    feature,
    score: calculatePriorityScore({
      demand: customerDemand[feature.id],
      complexity: technicalComplexity[feature.id],
      value: businessValue[feature.id],
      advantage: competitiveAdvantage[feature.id]
    })
  }));
  
  return priorityScores
    .sort((a, b) => b.score - a.score)
    .map((item, index) => ({
      ...item,
      priority: index + 1,
      quarter: assignToQuarter(item.feature, index)
    }));
}

export async function makeInvestmentDecision(opportunity: InvestmentOpportunity): Promise<InvestmentDecision> {
  const marketAnalysis = await analyzeMarketOpportunity(opportunity);
  const technicalFeasibility = await assessTechnicalFeasibility(opportunity);
  const financialProjection = await projectFinancials(opportunity);
  const riskAssessment = await assessRisks(opportunity);
  const resourceRequirements = await calculateResourceNeeds(opportunity);
  
  const roi = calculateROI(financialProjection, resourceRequirements);
  const paybackPeriod = calculatePaybackPeriod(financialProjection);
  const riskScore = calculateRiskScore(riskAssessment);
  
  const recommendation = await generateInvestmentRecommendation({
    marketAnalysis,
    technicalFeasibility,
    roi,
    paybackPeriod,
    riskScore
  });
  
  return {
    opportunity,
    recommendation,
    roi,
    paybackPeriod,
    riskScore,
    rationale: await generateDecisionRationale(recommendation)
  };
}

// Helper types for the above functions
interface PilotResults {
  successCriteriaMetrics: Record<string, number>;
  customerFeedback: string;
  technicalPerformance: TechnicalMetrics;
  businessImpact: BusinessImpactMetrics;
}

interface PilotTimeline {
  phases: PilotPhase[];
  totalDuration: number;
  milestones: Milestone[];
}

interface PilotPhase {
  name: string;
  duration: number;
  deliverables: string[];
}

interface Milestone {
  name: string;
  date: Date;
  criteria: string[];
}

interface AnomalyModel {
  id: string;
  assetType: string;
  liftType?: string;
  version: string;
  accuracy: number;
  precision: number;
  recall: number;
  deploymentStatus: 'Training' | 'Validation' | 'Deployed' | 'Deprecated';
}

interface Playbook {
  id: string;
  failureMode: string;
  symptoms: string[];
  diagnosticSteps: string[];
  recommendedActions: string[];
  estimatedTimeToFix: number;
  confidence: number;
}

interface Integration {
  id: string;
  sourceType: string;
  status: 'Active' | 'Inactive' | 'Error';
  lastSync: Date;
  dataQualityScore: number;
}

interface Invoice {
  id: string;
  customerId: string;
  amount: number;
  dueDate: Date;
  lineItems: LineItem[];
}

interface LineItem {
  description: string;
  quantity: number;
  unitPrice: number;
  total: number;
}

interface ExpansionRequest {
  additionalWells: number;
  additionalFacilities: number;
  newBasins: string[];
  additionalFeatures: string[];
}

interface ServiceDelivery {
  id: string;
  serviceType: string;
  status: 'Planned' | 'InProgress' | 'Completed' | 'Cancelled';
  deliverables: string[];
  hoursSpent: number;
}

interface HealthReport {
  timestamp: Date;
  edgeGatewayStatus: number;
  cloudInfrastructure: number;
  modelPerformance: number;
  dataQuality: number;
  alertLatency: number;
  overallHealth: number;
}

interface CustomerAlert {
  id: string;
  customerId: string;
  assetId: string;
  severity: 'Low' | 'Medium' | 'High' | 'Critical';
  message: string;
  timestamp: Date;
  dataSnapshot: Record<string, any>;
}

interface AlertResolution {
  alertId: string;
  resolvedAt: Date;
  actualCause: string;
  actionsTaken: string[];
  downtime: number;
  deferredProduction: number;
}

interface MaintenanceResult {
  modelUpdates: string[];
  configUpdates: string[];
  systemUpdates: string[];
  success: boolean;
}

interface RenewalDecision {
  customer: Customer;
  renewalProbability: number;
  strategy: RenewalStrategy;
  actionItems: ActionItem[];
}

interface RenewalStrategy {
  approach: 'Standard' | 'Retention' | 'Expansion' | 'Migration';
  pricing: PricingStrategy;
  timeline: Date[];
  stakeholders: string[];
}

interface ActionItem {
  task: string;
  owner: string;
  dueDate: Date;
  priority: 'Low' | 'Medium' | 'High';
}

interface PricingStrategy {
  discountPercentage?: number;
  additionalFeatures?: string[];
  contractLength: number;
  paymentTerms: string;
}

interface FeatureRequest {
  id: string;
  title: string;
  description: string;
  requestedBy: string[];
  estimatedEffort: number;
}

interface RoadmapPriority {
  feature: FeatureRequest;
  score: number;
  priority: number;
  quarter: string;
}

interface InvestmentOpportunity {
  id: string;
  title: string;
  description: string;
  estimatedInvestment: number;
  timeframe: number;
  strategicAlignment: number;
}

interface InvestmentDecision {
  opportunity: InvestmentOpportunity;
  recommendation: 'Approve' | 'Reject' | 'Defer' | 'ModifyAndApprove';
  roi: number;
  paybackPeriod: number;
  riskScore: number;
  rationale: string;
}

interface TechnicalMetrics {
  detectionLatency: number;
  falsePositiveRate: number;
  modelAccuracy: number;
  systemUptime: number;
}

interface BusinessImpactMetrics {
  deferredProductionAvoided: number;
  mttrReduction: number;
  truckRollsReduced: number;
  methaneIntensityReduction: number;
}
```
