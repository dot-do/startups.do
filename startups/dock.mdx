---
name: Dock/Yard Appointment & Gate Bot
slug: dock
naics:
  primary: '493190'
  occupations: []
service:
  title: Dock/Yard Appointment & Gate Bot
  description: >-
    Automates dock scheduling with carriers and manages driver self check-in via
    SMS/QR.
  targetUsers:
    - Receiving/shipping coordinator
    - Yard manager
  triggers:
    - Inbound/outbound load created
    - Carrier request email/SMS
    - ETA changes
  inputs:
    - Load/ASN details
    - Door capacity and blackout windows
    - Carrier contacts
    - 'ETA feeds (e.g., project44/FourKites)'
  steps:
    - Offer appointment slots based on constraints
    - Confirm with carriers via email/SMS; calendar sync
    - Driver gate bot collects PO/Trailer/Seal on arrival
    - Notify team; assign door; update WMS/TMS
    - Auto-reschedule on ETA delays and re-optimize door plan
  tools:
    - Calendar API
    - SMS (Twilio)
    - Email
    - TMS/visibility APIs
    - WMS dock/yard endpoints
  outputs:
    - Live dock calendar
    - Driver check-in transcripts
    - Door assignment updates
  pricingModel:
    - Per-appointment fee
    - Monthly base
    - Setup fee
  humanInLoop: false
  feasibility:
    remoteOnLaptop: 5
    modelCapability: 4.5
    overall: 4.6
  risks:
    - Driver connectivity issues
    - Overbooking from stale ETAs
    - Carrier adoption/behavior change
  dependencies:
    - SMS number and templates
    - TMS or visibility feed
    - WMS dock management access
leanCanvas:
  problem:
    - >-
      Manual dock scheduling (phone/email/portals) consumes 2–6 labor hours per
      site per day, creates errors, and makes it hard to enforce dock
      constraints (door capacity, equipment type, hazmat).
    - >-
      Gate check-in is slow and inconsistent; drivers often wait 10–20 minutes
      to register, causing congestion, lost productivity, and detention claims.
    - >-
      Little real-time visibility or predictive ETA adjustment leads to missed
      slots, under/over-utilized doors, and avoidable overtime.
    - >-
      Carrier experience is fragmented across multiple portals; adoption is low
      when apps are required, increasing no-shows and rework.
    - >-
      Compliance and audit trails (who arrived when, documents, safety
      confirmations) are incomplete or paper-based, making KPI tracking and
      root-cause analysis difficult.
  solution:
    - >-
      Self-serve appointment scheduling for carriers via link/SMS; dynamic
      slotting enforces door capacity, equipment, commodity, temperature/hazmat
      rules.
    - >-
      Driver self check-in at gate via QR signage or SMS short code; bot
      verifies PO/PRO/reference, collects required documents, and issues
      door/instructions automatically.
    - >-
      Predictive ETA and reslotting using visibility/ELD/geofencing data;
      auto-notify warehouse when trucks are inbound/late/early with suggested
      slot adjustments.
    - >-
      Configurable rules engine for doors, labor shifts, work content (pallets,
      live/unload, drop), dwell targets, and SLA priorities per client.
    - >-
      Audit-quality event log and analytics: check-in/out times, door dwell,
      no-shows, detention exposure, carrier scorecards.
    - >-
      Out-of-the-box integrations to common WMS/TMS/YMS and telematics;
      webhook/API for custom workflows; kiosk fallback if phones are restricted.
    - >-
      Multilingual bot (EN/ES + extendable) and safety/compliance prompts
      (C-TPAT steps, PPE acknowledgement).
  uniqueValueProp: >-
    Frictionless, AI-driven dock scheduling and SMS/QR self check-in that
    compresses gate time from minutes to seconds, raises door utilization, and
    reduces dwell and labor—no app required for carriers or drivers.
  unfairAdvantage: >-
    Network effects and data moat: every driver/carrier using SMS/QR across
    sites improves identity matching and dwell prediction. Frictionless no-app
    UX boosts adoption versus portal-based tools, and prebuilt WMS/TMS/YMS
    connectors cut time-to-value to weeks, not months.
  customerSegments:
    - >-
      US ‘Other Warehousing and Storage’ (NAICS 493190) facilities with 10–80
      dock doors and 30–150 truck moves/day (bonded, chemical/specialty,
      bulk/packaging, lumber/paper, e-comm overflow, value-add kitting).
    - >-
      Third-party logistics (3PLs) operating multi-client campuses that need
      standardized scheduling and gate processes.
    - >-
      Shipper-owned distribution centers coded under 493190 with seasonal peaks
      requiring rapid scaling.
    - >-
      Yard security vendors and property managers that need digital gate logs
      and visitor workflows (secondary stakeholders).
    - >-
      Carriers/drivers and brokers as daily end users of scheduling and check-in
      (influencers).
  channels:
    - >-
      Direct sales to operations leaders at NAICS 493190 sites (Ops/Facility
      Managers, Logistics Directors).
    - >-
      Partnerships and integrations with WMS/TMS/YMS vendors (e.g., SAP EWM,
      Blue Yonder, Manhattan, Körber, Oracle, Infor, Yard Management Solutions)
      and their marketplaces.
    - >-
      Carrier/visibility ecosystems (FourKites, project44) for ETA data and
      co-marketing; telematics (Samsara, Geotab) for geofences.
    - >-
      Industry associations/events: WERC, CSCMP EDGE, MODEX/ProMat, IWLA;
      targeted webinars with case studies.
    - >-
      Outbound by NAICS + door-count intent data; ABM to multi-site 3PLs; ROI
      calculator-driven demos.
    - >-
      Land-and-expand via carrier invites: every scheduled carrier receives a
      “use with your other facilities” prompt.
    - Security integrator partnerships for gate/kiosk deployments.
  revenueStreams:
    - >-
      SaaS subscription per site: Starter $600/site/month (up to 800 appts), Pro
      $1,500/site/month (advanced optimizer, integrations), Enterprise
      $2,500+/site/month (SSO, dedicated VPC, premium support).
    - >-
      Usage-based: $0.02–$0.03 per SMS; $0.20 per scheduled appointment beyond
      plan limits; optional LPR stream $300/site/month; WhatsApp/voice IVR
      pass-through.
    - >-
      Implementation/onboarding: $2,500–$10,000 per site depending on
      integrations and SSO.
    - >-
      Professional services: report customization, KPI workshops, change
      management ($150–$220/hr).
    - >-
      Hardware margin (optional): kiosk kit $1,200–$2,000 one-time, QR signage
      pack $150/site.
    - 'Annual enterprise support/SLA uplift: +10–15% of ARR.'
  costStructure:
    - >-
      Cloud hosting and data (compute, storage, backups): ~$70–$150/site/month
      at scale.
    - >-
      Messaging/telecom (SMS/WhatsApp/voice): variable COGS ~0.6–1.5¢/msg,
      region-dependent.
    - 'Maps/geocoding, document OCR, LPR/computer vision licensing (if enabled).'
    - >-
      Engineering, product, and data science salaries; QA and security (SOC 2,
      pen tests).
    - Implementation/onboarding and customer success staffing.
    - 'Sales and marketing: SDRs, events, partner MDF, demos.'
    - >-
      Partner referral fees/revenue share (10–20% of first-year ARR where
      applicable).
    - 'Insurance, legal, and compliance (data privacy, contractual SLAs).'
  keyMetrics:
    - 'Average gate check-in duration (target: <2 minutes; baseline 8–15).'
    - 'Driver dwell time at door (target: -15–30% vs baseline by lane/load type).'
    - 'Door utilization (target: +5–12%); throughput (trucks/day).'
    - >-
      % automated appointments (target: >80% carrier self-service) and %
      automated check-ins (target: >85%).
    - 'No-show/late arrival rate (target: -25% via reminders/ETAs).'
    - >-
      Labor hours saved at gate/dispatch (target: 2–6 hours/day/site); cost per
      appointment.
    - 'Detention incidents and exposure (target: -20–40%).'
    - >-
      Appointment lead time variance and on-time adherence (target: >90% OTD to
      slot).
    - >-
      Carrier NPS/CSAT for facility experience (target: +20 points within 90
      days).
    - >-
      Uptime (target: 99.9%+), message delivery rate (>98%), integration sync
      latency (<60 sec).
    - >-
      Sales metrics: CAC payback <12 months, net revenue retention >110%, churn
      <8% annually.
storyBrand:
  character: >-
    Operations leaders at 3PL and storage facilities (NAICS 493190)—warehouse,
    yard, and gate teams who must keep docks full and trucks moving.
  problem: >-
    External: Phone/email scheduling, walk-ups, and paper gate logs create
    missed slots, long queues, and detention fees. Internal: Teams are stressed
    by constant fire-fighting and after-hours calls. Philosophical: Booking a
    door and checking in a driver shouldn’t require spreadsheets and hold music.
  guide: >-
    Dock/Yard Appointment & Gate Bot—an AI service built for
    warehousing—understands dock chaos and carrier constraints; we provide clear
    playbooks, integrations with common WMS/TMS/YMS, and transparent audit
    trails so your team stays in control.
  plan: >-
    Process: 1) Connect carriers and calendars; 2) Configure rules (dock hours,
    commodities, SLAs); 3) Turn on SMS/QR self check-in and exception handling;
    4) Monitor slots, yard status, and ETAs from one dashboard. Agreement:
    simple monthly pricing, quick pilot, bring-your-own phone—no kiosks
    required.
  callToAction: >-
    Direct: Book a 20-minute demo or start a 30-day pilot. Transitional: Get the
    dock ROI checklist and sample SOPs.
  success: >-
    Accurate schedules, shorter gate dwell, fewer calls, steady dock
    utilization, clear ETAs and yard visibility, automatic logs for audits,
    happier carriers, lower detention/demurrage, and more turns per door.
  failure: >-
    Keep bleeding time and fees to missed appointments, gate lines, manual
    errors, and frustrated drivers—risking overtime, customer scorecards, and
    lost capacity.
landingPage:
  hero:
    title: Dock/Yard Appointment & Gate Bot
    subtitle: >-
      Automate dock scheduling with carriers and driver self check-in via SMS/QR
      for Other Warehousing & Storage (NAICS 493190). Cut wait time, raise
      throughput, and gain real-time yard visibility.
    ctaText: Request a demo
    ctaHref: /demo
  problem:
    - Phone and email back-and-forth to book doors slows carriers and planners
    - Gate lines and paper logs drive dwell and detention costs
    - Unpredictable arrivals overwhelm docks while other slots sit empty
    - 'Limited visibility into ETAs, yard status, and door availability'
    - 'Manual check-in causes errors, language barriers, and safety risks'
    - Missed time windows and late reschedules disrupt labor planning
    - 'Data scattered across WMS/TMS, spreadsheets, and radios'
    - High admin overhead per load; after-hours coverage is inconsistent
  solution:
    - Always-on AI bot books appointments directly with carriers
    - 'Smart capacity calendar levels loads by door, equipment, and SLA'
    - Drivers self check-in/out via SMS or QR; no app required
    - 'Gate bot verifies load info and documents, then assigns a door'
    - 'Live ETA tracking and alerts keep ops, carriers, and customers aligned'
    - Auto rescheduling and waitlist fill cancellations in real time
    - 'Single system of record with audit trail, KPIs, and detention tracking'
    - 'Fast rollout: use standalone or integrate with WMS/TMS/YMS'
  features:
    - 'Two-way carrier booking via link, SMS, or email'
    - 'Rules engine for time windows, commodities, temp-control, trailer types'
    - Door and door-group capacity with equipment constraints
    - 'Priority logic for live vs drop, inbound vs outbound'
    - Geofenced arrival detection and dynamic ETA updates
    - QR codes for guard shack and driver kiosks
    - 'Document capture: BOL, IDs, lumper receipts, photos'
    - Automatic door assignment and dock call notifications
    - 'Real-time yard board: scheduled, at gate, at dock, loaded, departed'
    - 'Detention timers, SLA thresholds, and exception alerts'
    - Multi-site management and role-based access controls
    - Bilingual driver flows (English/Spanish) with configurable languages
    - Webhooks and native connectors for major WMS/TMS/YMS
    - 'Analytics: dwell, turn time, utilization, no-show rate'
    - 'SSO, permissions, and audit logging for compliance'
  steps:
    - Connect your WMS/TMS or start standalone
    - 'Set dock capacities, door groups, time windows, and rules'
    - 'Share booking link or QR with carriers (rate con, email, portal)'
    - Carrier selects a slot; bot confirms and sends driver instructions
    - 'Driver arrives, scans QR or texts; gate bot verifies and assigns a door'
    - Statuses and alerts flow to ops and systems; exceptions are escalated
    - Review KPIs and fine-tune rules to continuously reduce dwell
---
# Dock/Yard Appointment & Gate Bot

Generated for NAICS 493190 — Other Warehousing and Storage.
Service: Dock/Yard Appointment & Gate Bot

## Business Process Workflows

The following TypeScript functions define the core business processes and workflows for the dock scheduling startup:

```typescript
// Core Types
interface Lead {
  facilityId: string;
  contactInfo: ContactInfo;
  facilityDetails: FacilityDetails;
  currentPainPoints: string[];
  doorCount: number;
  dailyTruckMoves: number;
}

interface Customer {
  id: string;
  facilityId: string;
  subscriptionTier: 'starter' | 'pro' | 'enterprise';
  monthlyRevenue: number;
  onboardingStatus: 'pending' | 'active' | 'churned';
  integrations: Integration[];
}

interface Appointment {
  id: string;
  carrierId: string;
  driverId: string;
  scheduledTime: Date;
  doorAssignment?: string;
  status: 'scheduled' | 'checked-in' | 'at-dock' | 'completed' | 'no-show';
  loadDetails: LoadDetails;
}

interface DockSchedule {
  facilityId: string;
  doors: DoorCapacity[];
  appointments: Appointment[];
  constraints: SchedulingConstraints;
}

// Customer Acquisition Workflows
export async function acquireCustomer(lead: Lead): Promise<Customer> {
  try {
    const qualifiedLead = await qualifyLead(lead);
    const roiDemo = await generateROIDemo(qualifiedLead);
    const pilot = await proposePilotProgram(roiDemo);
    const contract = await negotiateContract(pilot);
    return await onboardCustomer(contract);
  } catch (error) {
    throw new Error(`Customer acquisition failed: ${error.message}`);
  }
}

async function qualifyLead(lead: Lead): Promise<QualifiedLead> {
  // Qualify based on NAICS 493190, door count 10-80, daily moves 30-150
  if (lead.doorCount < 10 || lead.doorCount > 80) {
    throw new Error('Facility size outside target range');
  }
  
  if (lead.dailyTruckMoves < 30 || lead.dailyTruckMoves > 150) {
    throw new Error('Daily truck volume outside target range');
  }

  const painPointScore = calculatePainPointScore(lead.currentPainPoints);
  const fitScore = calculateMarketFit(lead.facilityDetails);
  
  return {
    ...lead,
    qualificationScore: (painPointScore + fitScore) / 2,
    estimatedROI: calculateEstimatedROI(lead),
    recommendedTier: recommendSubscriptionTier(lead)
  };
}

async function generateROIDemo(qualifiedLead: QualifiedLead): Promise<ROIDemo> {
  const currentCosts = {
    laborHours: qualifiedLead.dailyTruckMoves * 0.25, // 15 min avg per truck
    detentionClaims: qualifiedLead.dailyTruckMoves * 0.1 * 150, // 10% detention rate
    overtimeCosts: calculateOvertimeCosts(qualifiedLead),
    missedSlotCosts: calculateMissedSlotCosts(qualifiedLead)
  };

  const projectedSavings = {
    laborReduction: currentCosts.laborHours * 0.7 * 25, // 70% reduction at $25/hr
    detentionReduction: currentCosts.detentionClaims * 0.3,
    overtimeReduction: currentCosts.overtimeCosts * 0.4,
    throughputIncrease: calculateThroughputGains(qualifiedLead)
  };

  return {
    currentCosts,
    projectedSavings,
    paybackPeriod: calculatePaybackPeriod(currentCosts, projectedSavings),
    annualROI: calculateAnnualROI(projectedSavings, qualifiedLead.recommendedTier)
  };
}

// Product Development Processes
export async function developFeature(featureRequest: FeatureRequest): Promise<Feature> {
  try {
    const requirements = await analyzeRequirements(featureRequest);
    const design = await createTechnicalDesign(requirements);
    const implementation = await implementFeature(design);
    const testing = await testFeature(implementation);
    return await deployFeature(testing);
  } catch (error) {
    throw new Error(`Feature development failed: ${error.message}`);
  }
}

async function analyzeRequirements(request: FeatureRequest): Promise<Requirements> {
  // Analyze customer feedback, usage patterns, and market needs
  const customerFeedback = await aggregateCustomerFeedback(request.category);
  const usageAnalytics = await analyzeUsagePatterns(request.category);
  const competitorAnalysis = await analyzeCompetitorFeatures(request.category);
  
  return {
    functionalRequirements: extractFunctionalRequirements(customerFeedback),
    technicalRequirements: defineTechnicalRequirements(usageAnalytics),
    integrationRequirements: defineIntegrationNeeds(competitorAnalysis),
    priority: calculateFeaturePriority(request, customerFeedback)
  };
}

// Revenue Generation Flows
export async function processSubscription(customer: Customer, tier: SubscriptionTier): Promise<Revenue> {
  try {
    const pricing = await calculatePricing(customer, tier);
    const billing = await setupBilling(customer, pricing);
    const usage = await trackUsage(customer);
    return await generateRevenue(billing, usage);
  } catch (error) {
    throw new Error(`Revenue processing failed: ${error.message}`);
  }
}

async function calculatePricing(customer: Customer, tier: SubscriptionTier): Promise<PricingStructure> {
  const basePricing = {
    starter: 600, // $600/site/month up to 800 appointments
    pro: 1500,    // $1,500/site/month with advanced features
    enterprise: 2500 // $2,500+/site/month with SSO, VPC
  };

  const usageBasedPricing = {
    smsRate: 0.025, // $0.02-$0.03 per SMS
    appointmentOverage: 0.20, // $0.20 per appointment beyond limits
    lprStream: 300 // $300/site/month for license plate recognition
  };

  return {
    monthlyBase: basePricing[tier],
    usageRates: usageBasedPricing,
    implementationFee: calculateImplementationFee(customer),
    annualDiscount: tier === 'enterprise' ? 0.15 : 0.10
  };
}

// Operational Procedures
export async function processAppointment(appointmentRequest: AppointmentRequest): Promise<Appointment> {
  try {
    const availability = await checkDoorAvailability(appointmentRequest);
    const constraints = await validateConstraints(appointmentRequest, availability);
    const slot = await assignOptimalSlot(appointmentRequest, constraints);
    const confirmation = await sendConfirmation(slot);
    return await createAppointment(slot, confirmation);
  } catch (error) {
    throw new Error(`Appointment processing failed: ${error.message}`);
  }
}

async function checkDoorAvailability(request: AppointmentRequest): Promise<AvailableSlots> {
  const facility = await getFacilityConfiguration(request.facilityId);
  const existingAppointments = await getExistingAppointments(request.facilityId, request.requestedDate);
  
  const availableSlots = facility.doors.map(door => {
    const doorSchedule = existingAppointments.filter(apt => apt.doorAssignment === door.id);
    return calculateAvailableTimeSlots(door, doorSchedule, facility.operatingHours);
  }).flat();

  return {
    slots: availableSlots,
    constraints: facility.constraints,
    recommendations: generateSlotRecommendations(availableSlots, request)
  };
}

export async function processDriverCheckIn(checkInData: DriverCheckInData): Promise<CheckInResult> {
  try {
    const verification = await verifyDriverCredentials(checkInData);
    const documents = await validateDocuments(checkInData.documents);
    const doorAssignment = await assignDoor(verification, documents);
    const notification = await notifyWarehouse(doorAssignment);
    return await completeCheckIn(doorAssignment, notification);
  } catch (error) {
    throw new Error(`Driver check-in failed: ${error.message}`);
  }
}

async function verifyDriverCredentials(checkInData: DriverCheckInData): Promise<DriverVerification> {
  // Verify PO/PRO/reference numbers, driver ID, carrier information
  const appointment = await findAppointmentByReference(checkInData.referenceNumber);
  if (!appointment) {
    throw new Error('No appointment found for reference number');
  }

  const driverMatch = await verifyDriverIdentity(checkInData.driverId, appointment.driverId);
  const carrierMatch = await verifyCarrierInfo(checkInData.carrierId, appointment.carrierId);

  return {
    appointmentId: appointment.id,
    verified: driverMatch && carrierMatch,
    arrivalTime: new Date(),
    earlyLateStatus: calculateArrivalStatus(appointment.scheduledTime)
  };
}

// Decision-Making Workflows
export async function optimizeDockSchedule(facilityId: string, date: Date): Promise<OptimizedSchedule> {
  try {
    const currentSchedule = await getCurrentSchedule(facilityId, date);
    const constraints = await getSchedulingConstraints(facilityId);
    const etaUpdates = await getETAUpdates(currentSchedule.appointments);
    const optimization = await runOptimizationEngine(currentSchedule, constraints, etaUpdates);
    return await implementScheduleChanges(optimization);
  } catch (error) {
    throw new Error(`Schedule optimization failed: ${error.message}`);
  }
}

async function runOptimizationEngine(
  schedule: DockSchedule, 
  constraints: SchedulingConstraints, 
  etaUpdates: ETAUpdate[]
): Promise<OptimizationResult> {
  // Apply constraint-based optimization considering:
  // - Door capacity and equipment type constraints
  // - Commodity and hazmat restrictions
  // - Temperature control requirements
  // - Labor shift patterns
  // - SLA priorities per client
  
  const objectives = {
    maximizeDoorUtilization: 0.4,
    minimizeDwellTime: 0.3,
    reduceDetentionRisk: 0.2,
    balanceWorkload: 0.1
  };

  const optimizedSlots = await solveSchedulingProblem(schedule, constraints, objectives);
  const impactAnalysis = await analyzeScheduleImpact(schedule, optimizedSlots);
  
  return {
    originalSchedule: schedule,
    optimizedSchedule: optimizedSlots,
    improvements: impactAnalysis,
    changeRequests: generateChangeRequests(schedule, optimizedSlots)
  };
}

export async function handleException(exception: OperationalException): Promise<ExceptionResolution> {
  try {
    const severity = await assessExceptionSeverity(exception);
    const options = await generateResolutionOptions(exception, severity);
    const decision = await makeResolutionDecision(options);
    const implementation = await implementResolution(decision);
    return await trackResolutionOutcome(implementation);
  } catch (error) {
    throw new Error(`Exception handling failed: ${error.message}`);
  }
}

async function assessExceptionSeverity(exception: OperationalException): Promise<ExceptionSeverity> {
  const impactFactors = {
    affectedAppointments: exception.affectedAppointments.length,
    detentionRisk: calculateDetentionRisk(exception),
    customerTier: getHighestCustomerTier(exception.affectedAppointments),
    timeToDeadline: calculateTimeToDeadline(exception),
    resourceAvailability: await checkResourceAvailability(exception)
  };

  const severityScore = calculateSeverityScore(impactFactors);
  
  return {
    level: severityScore > 8 ? 'critical' : severityScore > 5 ? 'high' : 'medium',
    impactFactors,
    escalationRequired: severityScore > 7,
    responseTimeTarget: severityScore > 8 ? 5 : severityScore > 5 ? 15 : 60 // minutes
  };
}

// Integration and Analytics Functions
export async function syncWithWMS(facilityId: string, updates: WMSUpdate[]): Promise<SyncResult> {
  try {
    const wmsConfig = await getWMSConfiguration(facilityId);
    const mappedData = await mapDataToWMSFormat(updates, wmsConfig);
    const syncResult = await pushToWMS(mappedData, wmsConfig);
    return await validateSyncSuccess(syncResult);
  } catch (error) {
    throw new Error(`WMS sync failed: ${error.message}`);
  }
}

export async function generateAnalytics(facilityId: string, period: DateRange): Promise<FacilityAnalytics> {
  try {
    const appointments = await getAppointmentHistory(facilityId, period);
    const checkIns = await getCheckInHistory(facilityId, period);
    const doorUtilization = await calculateDoorUtilization(appointments, period);
    const dwellAnalysis = await analyzeDwellTimes(checkIns);
    const carrierPerformance = await analyzeCarrierPerformance(appointments);
    
    return {
      period,
      facilityId,
      kpis: {
        averageCheckInTime: dwellAnalysis.averageCheckInTime,
        doorUtilization: doorUtilization.average,
        onTimePerformance: carrierPerformance.onTimeRate,
        noShowRate: carrierPerformance.noShowRate,
        detentionIncidents: dwellAnalysis.detentionCount,
        throughputImprovement: calculateThroughputImprovement(appointments, period)
      },
      trends: generateTrendAnalysis(appointments, checkIns, period),
      recommendations: generateOperationalRecommendations(doorUtilization, dwellAnalysis)
    };
  } catch (error) {
    throw new Error(`Analytics generation failed: ${error.message}`);
  }
}
```
