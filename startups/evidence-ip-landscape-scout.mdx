---
name: Evidence IP Landscape Scout
slug: evidence-ip-landscape-scout
domain: evidence-ip-landscape-scout.ai
naics:
  primary: "541714"
  occupations: ["Research Scientists", "IP Analysts", "Business Development Specialists"]
score:
  remote_on_laptop: 0.95
  model_capability: 0.9
  overall: 0.925
vmv:
  vision: "Real-time, source-grounded IP landscape intelligence for biotech R&D"
  mission: "Transform weeks of manual prior art research into minutes of AI-powered evidence synthesis"
  purpose: "Accelerate biotech innovation through comprehensive, actionable IP landscape analysis"
leanCanvas:
  problem:
    - "R&D and BD teams spend 40–80 person-hours per landscaping cycle to find and synthesize prior art across literature, preprints, and patents; results are quickly outdated (weeks)."
    - "Critical prior art is missed due to synonymy (targets/indications/modality names), inconsistent annotations, and siloed sources—creating FTO exposure and duplicated R&D effort."
    - "Existing alerts are noisy and non-actionable (low precision, lack of context, no claim-scoped views), forcing manual triage by senior scientists or IP analysts."
    - "Linking biological target → modality → indication evidence is manual; teams cannot quickly visualize gaps (white space) or strength of evidence across the triad."
    - "Enterprise tools are expensive and broad; they lack biology-specific NLP, passage-level grounding, and real-time preprint → patent linkage needed for early discovery decisions."
  solution:
    - "Unified evidence graph that normalizes targets (HGNC/UniProt), modalities (controlled vocabularies), and indications (MeSH/DOID) and links them to paper sections, preprint passages, and patent claims."
    - "High-recall retrieval with domain ontologies and synonym expansion; RAG summaries that cite exact passages with confidence scores and DOIs/patent IDs."
    - "Claim-scoped IP view: parses independent/dependent claims, extracts scope, entities, novelty cues, assignees, and litigation/licensing signals."
    - "Gap analysis and white-space maps across the target–modality–indication triad with evidence strength, trends, and competitive density visualizations."
    - "Precision alerts: new preprints/patents, prosecution updates, and material evidence shifts with user-tunable filters and relevance feedback."
    - "Collaboration and integrations: export to ELNs/LIMS, Slack/Teams, and BI tools; API for programmatic use; audit trails for compliance."
  uniqueValueProp: "Source-grounded, biology-aware AI that maps the literature, preprints, and patents around any target–modality–indication triad in minutes—not weeks—reducing search time by ~90%, improving relevant-art recall by 20–35% vs keyword baselines, and continuously alerting on changes with claim-level evidence and actionable gap analysis."
  unfairAdvantage: "Biology-first, passage-grounded triad mapping (target–modality–indication) with claim-scoped IP synthesis and validated retrieval benchmarks, plus a continuously learning synonym/ontology layer and private-index option—delivering higher recall with actionable, audit-ready evidence in minutes."
  customerSegments:
    - "Primary: Mid-size biotech R&D orgs (20–500 scientists) needing rapid landscaping for targets, modalities (e.g., mAbs, AAV, PROTACs), and disease indications."
    - "Primary: Pharma discovery, competitive intelligence, and BD&L teams evaluating external assets and freedom-to-operate risks."
    - "Secondary: Biotech IP/legal teams and outside counsel seeking claim-scoped evidence maps for FTO and prior art searches (non-legal advice)."
    - "Secondary: CROs and research consultancies offering landscaping as a service to clients."
    - "Secondary: Life science VCs and corporate venture groups performing technical diligence."
    - "Tertiary: Academic tech transfer offices evaluating novelty and partner interest."
  channels:
    - "Direct sales to biotech/pharma R&D, BD&L, and CI leaders (email/LinkedIn, targeted outbound with tailored demo landscapes)."
    - "Content-led growth: publish 12 flagship landscape reports/year (e.g., "PROTACs in KRAS G12C across solid tumors"), webinars, and benchmarks vs. keyword baselines."
    - "Partnerships: ELN/LIMS vendors (Benchling, Dotmatics) for marketplace listings; CROs to bundle landscaping with studies; IP analytics resellers."
    - "Conference presence and workshops: BIO, JPM week, AACR, ASCO, BIO-Europe, LES; offer free project triage sessions."
    - "Freemium/Trial: limited "single-triad" self-serve trial with masked counts; conversion to paid for full evidence and export."
    - "Developer/API channel: integrate with internal KM portals and CI dashboards in mid/large pharma."
  revenueStreams:
    - "SaaS subscriptions (annual): Team $24k/yr (up to 5 users, 50 landscapes/mo, standard alerts); Growth $72k/yr (up to 25 users, 250 landscapes/mo, API, SSO); Enterprise $120k–$400k/yr (unlimited users, private index/VPC, SLAs, custom ontologies)."
    - "Usage-based overage: $100 per additional landscape run and $0.02 per alert event processed beyond plan quotas."
    - "Managed services: custom deep-dive landscape or FTO prep packs at $8k–$25k per project (non-legal)."
    - "Premium data add-ons: licensed data (e.g., full-text via partners, commercial patent analytics) passed through at cost-plus 20%."
    - "Professional services: integrations, bespoke dashboards, ontology extensions ($200–$300/hr or fixed-scope SOW)."
  costStructure:
    - "Cloud infrastructure (annualized): $180k–$350k for compute, storage, and vector indices; marginal COGS $6–$18 per landscape run depending on depth and model size."
    - "Model and API costs: mix of hosted open models and premium LLM/API calls for summarization/claim parsing; target <20% of ARR as COGS at scale."
    - "Data acquisition/licensing: $0 (open sources) to $300k–$800k/yr with commercial partners depending on scope/geos."
    - "Team (Year 1–2): 3 ML/NLP engineers, 2 data engineers, 1 bioinformatics scientist, 1 IP analyst, 1 product manager, 2 GTM (AE + PMM); fully loaded $2.2M–$3.0M/yr."
    - "Security/compliance: SOC 2 readiness and pen tests $60k–$120k/yr; legal (IP/TOS/privacy) $60k–$100k/yr."
    - "Sales/marketing: events, content, and paid channels $200k–$400k/yr."
    - "Overhead: admin, tools, and workspace $120k–$200k/yr."
  keyMetrics:
    - "Acquisition/Activation: trial-to-paid conversion ≥30% for SMB biotech; enterprise POC-to-paid ≥40%; time-to-first-landscape <15 minutes (p50)."
    - "Engagement: weekly active users per account ≥50% of licensed seats; median projects/account/month ≥6; alert open/CTR ≥25%."
    - "Quality: precision@20 ≥0.80 and recall@100 ≥0.70 versus internal keyword baselines across 10 validated topics; hallucination rate <1% (audit-sampled)."
    - "Coverage: ≥95% of PubMed and bioRxiv/medRxiv indexed within 24 hours; global patent offices (USPTO/EPO/WIPO, CNIPA, JPO, KIPO) updates ≤72 hours."
    - "Retention/Revenue: gross revenue retention ≥90%, net revenue retention ≥120% at 12 months; ARR growth ≥100% YoY in years 1–2; gross margin ≥70%."
    - "Value: time saved per landscape ≥30 hours; % of alerted items leading to action ≥20%; # of gaps prioritized that become funded experiments per quarter."
    - "Security/Trust: SOC 2 Type I in 12 months, Type II in 18 months; SSO adoption ≥80% of enterprise accounts."
okrs:
  - objective: "Achieve product-market fit in biotech R&D"
    keyResults:
      - metric: "Trial-to-paid conversion rate"
        target: "≥30%"
      - metric: "Time-to-first-landscape"
        target: "≤15 minutes"
      - metric: "Weekly active users per account"
        target: "≥50% of licensed seats"
  - objective: "Establish technical superiority in IP landscape analysis"
    keyResults:
      - metric: "Precision@20 vs keyword baselines"
        target: "≥0.80"
      - metric: "Recall@100 vs keyword baselines"
        target: "≥0.70"
      - metric: "Hallucination rate"
        target: "<1%"
  - objective: "Scale revenue and customer base"
    keyResults:
      - metric: "ARR growth"
        target: "≥100% YoY"
      - metric: "Net revenue retention"
        target: "≥120%"
      - metric: "Gross margin"
        target: "≥70%"
storyBrand:
  character: "Biotech R&D and IP teams"
  problem: "Weeks of manual prior art research with missed critical evidence"
  guide: "AI-powered IP landscape intelligence platform"
  plan: "Trial → Pilot → Scale across R&D workflows"
  callToAction: "Start your free landscape analysis"
  success: "Minutes to comprehensive, actionable IP intelligence"
  failure: "Continued FTO exposure and duplicated R&D effort"
branding:
  nameIdeas: ["EvidenceScout", "IPLandscape.ai", "PriorArt.ai"]
  colors: { primary: "#2563EB", secondary: "#1E293B" }
  fonts: { heading: "Inter", body: "Inter" }
  logoPrompt: "Minimalist compass + DNA helix logo representing navigation through scientific evidence"
pricing:
  plans:
    - id: team
      name: "Team"
      price: 2000
      interval: monthly
      features: ["Up to 5 users", "50 landscapes/mo", "Standard alerts", "Email support"]
    - id: growth
      name: "Growth"
      price: 6000
      interval: monthly
      features: ["Up to 25 users", "250 landscapes/mo", "API access", "SSO", "Priority support"]
    - id: enterprise
      name: "Enterprise"
      price: 10000
      interval: monthly
      features: ["Unlimited users", "Private index/VPC", "SLAs", "Custom ontologies", "Dedicated CSM"]
  stripe:
    productId: ""
    priceIds: {}
prd:
  summary: "AI-powered IP landscape analysis platform for biotech R&D teams"
  scopeMVP:
    - "Target-modality-indication triad mapping interface"
    - "Literature and patent search with biology-aware NLP"
    - "Evidence synthesis with passage-level citations"
    - "Gap analysis and white-space visualization"
    - "Real-time alerts and monitoring"
    - "Export to common R&D tools (ELN/LIMS)"
experiments:
  - hypothesis: "Biology-aware search improves recall by 20-35% vs keyword baselines"
    metric: "Recall@100"
    variantCount: 3
  - hypothesis: "Claim-scoped IP analysis reduces FTO research time by 80%"
    metric: "Time to complete FTO analysis"
    variantCount: 2
variants:
  - name: "Academic-focused"
    changes: ["Preprint-heavy indexing", "Academic pricing", "University SSO"]
  - name: "Pharma enterprise"
    changes: ["Private cloud deployment", "Advanced compliance", "Custom ontologies"]
---

import { Business, on, every } from 'workflows.do'
import { Agent } from 'agents.do'
import { Human } from 'humans.do'

export const evidenceIPLandscapeScout = Business({
  name: 'Evidence IP Landscape Scout',
  url: 'https://evidence-ip-landscape-scout.ai',
  vision: 'Real-time, source-grounded IP landscape intelligence for biotech R&D',
  
  goals: [
    { objective: 'Achieve product-market fit in biotech R&D', keyResults: ['▲ trial-to-paid conversion ≥30%', '▼ time-to-first-landscape ≤15min', '▲ weekly active users ≥50%'] },
    { objective: 'Establish technical superiority', keyResults: ['▲ precision@20 ≥0.80', '▲ recall@100 ≥0.70', '▼ hallucination rate <1%'] },
    { objective: 'Scale revenue and customer base', keyResults: ['▲ ARR growth ≥100% YoY', '▲ NRR ≥120%', '▲ gross margin ≥70%'] },
  ],
  
  ceo: Human({ name: 'Dr. Sarah Chen', email: 'sarah@evidence-ip-landscape-scout.ai' }),
  cto: Human({ 
    name: 'Dr. Michael Rodriguez', 
    email: 'michael@evidence-ip-landscape-scout.ai',
    objective: 'Build the industry-leading biology-aware IP intelligence platform',
    keyResults: ['▼ search latency <3s p95', '▲ data coverage ≥95% PubMed/patents', '▲ API uptime ≥99.9%']
  }),
  
  departments: {
    research: Agent({ name: 'Research Intelligence Agent' }),
    sales: Human({ name: 'Alex Kim', email: 'alex@evidence-ip-landscape-scout.ai' }),
    customerSuccess: Agent({ name: 'Customer Success Agent' }),
  },
})

export interface Lead {
  id: string
  company: string
  email: string
  role: string
  useCase: 'FTO' | 'competitive-intelligence' | 'prior-art' | 'white-space-analysis'
  targetTherapeuticArea?: string
  teamSize: number
  currentTools: string[]
  painPoints: string[]
  source: 'inbound' | 'outbound' | 'referral' | 'content'
}

export interface Customer {
  id: string
  company: string
  plan: 'team' | 'growth' | 'enterprise'
  users: number
  onboardingStatus: 'pending' | 'in-progress' | 'completed'
  firstLandscapeDate?: Date
  monthlyLandscapes: number
  alertsEnabled: boolean
}

export interface LandscapeRequest {
  id: string
  customerId: string
  target: string
  modality: string
  indication: string
  depth: 'quick' | 'standard' | 'comprehensive'
  includePatents: boolean
  includePreprints: boolean
  timeframe?: string
  status: 'queued' | 'processing' | 'completed' | 'failed'
}

export interface EvidenceMap {
  id: string
  landscapeId: string
  targetModalityIndicationTriad: {
    target: string
    modality: string
    indication: string
  }
  literatureEvidence: Array<{
    doi: string
    title: string
    passages: string[]
    confidenceScore: number
    evidenceType: 'preclinical' | 'clinical' | 'review'
  }>
  patentEvidence: Array<{
    patentId: string
    title: string
    claims: string[]
    assignee: string
    noveltyIndicators: string[]
    litigationRisk: 'low' | 'medium' | 'high'
  }>
  gapAnalysis: {
    whiteSpaceAreas: string[]
    competitiveDensity: number
    evidenceStrength: number
    recommendedActions: string[]
  }
}

export async function acquireCustomer(lead: Lead): Promise<Customer> {
  const qualifiedLead = await qualifyLead(lead)
  const demoLandscape = await generateDemoLandscape(qualifiedLead)
  const proposal = await generateProposal(qualifiedLead, demoLandscape)
  const contract = await negotiateContract(proposal)
  return await onboardCustomer(contract)
}

export async function qualifyLead(lead: Lead): Promise<Lead & { qualified: boolean; score: number }> {
  const qualificationCriteria = {
    teamSize: lead.teamSize >= 5 ? 20 : lead.teamSize * 4,
    useCase: lead.useCase === 'FTO' ? 25 : 20,
    currentPainPoints: lead.painPoints.length * 5,
    therapeuticFocus: lead.targetTherapeuticArea ? 15 : 0,
    role: lead.role.includes('Director') || lead.role.includes('VP') ? 20 : 10,
  }
  
  const score = Object.values(qualificationCriteria).reduce((sum, points) => sum + points, 0)
  const qualified = score >= 60
  
  return { ...lead, qualified, score }
}

export async function generateDemoLandscape(lead: Lead): Promise<EvidenceMap> {
  const demoTriad = {
    target: lead.targetTherapeuticArea ? getRelevantTarget(lead.targetTherapeuticArea) : 'KRAS',
    modality: 'small molecule',
    indication: lead.targetTherapeuticArea || 'solid tumors'
  }
  
  return await conductLandscapeAnalysis({
    id: `demo-${lead.id}`,
    customerId: lead.id,
    target: demoTriad.target,
    modality: demoTriad.modality,
    indication: demoTriad.indication,
    depth: 'standard',
    includePatents: true,
    includePreprints: true,
    status: 'queued'
  })
}

export async function generateProposal(lead: Lead, demoResults: EvidenceMap): Promise<{
  plan: 'team' | 'growth' | 'enterprise'
  pricing: number
  features: string[]
  roi: string
}> {
  const planRecommendation = lead.teamSize <= 5 ? 'team' : 
                           lead.teamSize <= 25 ? 'growth' : 'enterprise'
  
  const pricing = {
    team: 24000,
    growth: 72000,
    enterprise: 120000
  }[planRecommendation]
  
  const timeSavingsPerLandscape = 35
  const estimatedLandscapesPerMonth = Math.min(lead.teamSize * 4, 50)
  const annualTimeSavings = timeSavingsPerMonth * estimatedLandscapesPerMonth * 12
  const costPerHour = 150
  const annualSavings = annualTimeSavings * costPerHour
  const roi = `${Math.round((annualSavings - pricing) / pricing * 100)}%`
  
  return {
    plan: planRecommendation,
    pricing,
    features: getPlanFeatures(planRecommendation),
    roi
  }
}

export async function negotiateContract(proposal: any): Promise<any> {
  return {
    ...proposal,
    signedDate: new Date(),
    contractId: `contract-${Date.now()}`
  }
}

export async function onboardCustomer(contract: any): Promise<Customer> {
  const customer: Customer = {
    id: `customer-${Date.now()}`,
    company: contract.company,
    plan: contract.plan,
    users: contract.teamSize,
    onboardingStatus: 'pending',
    monthlyLandscapes: 0,
    alertsEnabled: false
  }
  
  await setupCustomerEnvironment(customer)
  await scheduleOnboardingCall(customer)
  await sendWelcomeEmail(customer)
  
  return customer
}

export async function conductLandscapeAnalysis(request: LandscapeRequest): Promise<EvidenceMap> {
  const searchResults = await executeTriadSearch(request)
  const literatureEvidence = await extractLiteratureEvidence(searchResults.literature)
  const patentEvidence = await extractPatentEvidence(searchResults.patents)
  const gapAnalysis = await performGapAnalysis(literatureEvidence, patentEvidence, request)
  
  return {
    id: `evidence-${request.id}`,
    landscapeId: request.id,
    targetModalityIndicationTriad: {
      target: request.target,
      modality: request.modality,
      indication: request.indication
    },
    literatureEvidence,
    patentEvidence,
    gapAnalysis
  }
}

export async function executeTriadSearch(request: LandscapeRequest): Promise<{
  literature: any[]
  patents: any[]
}> {
  const synonyms = await expandSynonyms(request.target, request.modality, request.indication)
  const literatureQuery = buildBiologyAwareQuery(synonyms, 'literature')
  const patentQuery = buildBiologyAwareQuery(synonyms, 'patents')
  
  const [literature, patents] = await Promise.all([
    searchLiteratureDatabases(literatureQuery),
    searchPatentDatabases(patentQuery)
  ])
  
  return { literature, patents }
}

export async function extractLiteratureEvidence(literatureResults: any[]): Promise<EvidenceMap['literatureEvidence']> {
  return literatureResults.map(paper => ({
    doi: paper.doi,
    title: paper.title,
    passages: extractRelevantPassages(paper.fullText),
    confidenceScore: calculateConfidenceScore(paper),
    evidenceType: classifyEvidenceType(paper)
  }))
}

export async function extractPatentEvidence(patentResults: any[]): Promise<EvidenceMap['patentEvidence']> {
  return patentResults.map(patent => ({
    patentId: patent.id,
    title: patent.title,
    claims: parseIndependentClaims(patent.claims),
    assignee: patent.assignee,
    noveltyIndicators: extractNoveltyIndicators(patent.claims),
    litigationRisk: assessLitigationRisk(patent)
  }))
}

export async function performGapAnalysis(
  literature: EvidenceMap['literatureEvidence'],
  patents: EvidenceMap['patentEvidence'],
  request: LandscapeRequest
): Promise<EvidenceMap['gapAnalysis']> {
  const evidenceMatrix = buildEvidenceMatrix(literature, patents)
  const whiteSpaceAreas = identifyWhiteSpace(evidenceMatrix)
  const competitiveDensity = calculateCompetitiveDensity(patents)
  const evidenceStrength = calculateEvidenceStrength(literature)
  const recommendedActions = generateRecommendations(whiteSpaceAreas, competitiveDensity, evidenceStrength)
  
  return {
    whiteSpaceAreas,
    competitiveDensity,
    evidenceStrength,
    recommendedActions
  }
}

export async function processAlertTrigger(alertData: {
  type: 'new-patent' | 'new-preprint' | 'prosecution-update'
  content: any
  affectedCustomers: string[]
}): Promise<void> {
  for (const customerId of alertData.affectedCustomers) {
    const customer = await getCustomer(customerId)
    if (customer.alertsEnabled) {
      const relevanceScore = await calculateRelevanceScore(alertData.content, customer)
      if (relevanceScore > 0.7) {
        await sendAlert(customer, alertData, relevanceScore)
      }
    }
  }
}

export async function generateMonthlyReport(customerId: string): Promise<{
  landscapesCompleted: number
  alertsProcessed: number
  timesSaved: number
  keyInsights: string[]
  recommendedActions: string[]
}> {
  const customer = await getCustomer(customerId)
  const monthlyActivity = await getMonthlyActivity(customerId)
  
  return {
    landscapesCompleted: monthlyActivity.landscapes.length,
    alertsProcessed: monthlyActivity.alerts.length,
    timesSaved: monthlyActivity.landscapes.length * 35,
    keyInsights: await extractKeyInsights(monthlyActivity),
    recommendedActions: await generateActionRecommendations(monthlyActivity)
  }
}

on('LandscapeRequest.Submitted', async (request: LandscapeRequest, { ai, db, taskQueue }) => {
  await db.landscapeRequests.update(request.id, { status: 'processing' })
  
  try {
    const evidenceMap = await conductLandscapeAnalysis(request)
    await db.evidenceMaps.create(evidenceMap)
    await db.landscapeRequests.update(request.id, { status: 'completed' })
    
    taskQueue.enqueue('SendLandscapeComplete', { 
      customerId: request.customerId, 
      landscapeId: request.id,
      evidenceMapId: evidenceMap.id 
    })
  } catch (error) {
    await db.landscapeRequests.update(request.id, { status: 'failed' })
    taskQueue.enqueue('SendLandscapeError', { 
      customerId: request.customerId, 
      landscapeId: request.id, 
      error: error.message 
    })
  }
})

on('Customer.Onboarded', async (customer: Customer, { ai, db, taskQueue }) => {
  await db.customers.update(customer.id, { onboardingStatus: 'in-progress' })
  
  taskQueue.enqueue('ScheduleOnboardingCall', { customerId: customer.id })
  taskQueue.enqueue('SendWelcomeEmail', { customerId: customer.id })
  taskQueue.enqueue('SetupDemoLandscape', { customerId: customer.id })
})

on('Alert.Triggered', async (alert: any, { ai, db, taskQueue }) => {
  const relevantCustomers = await findRelevantCustomers(alert)
  
  for (const customer of relevantCustomers) {
    if (customer.alertsEnabled) {
      const relevanceScore = await ai.call('calculateRelevance', { 
        alert: alert.content, 
        customerProfile: customer.profile 
      })
      
      if (relevanceScore > 0.7) {
        taskQueue.enqueue('SendAlert', { 
          customerId: customer.id, 
          alertData: alert, 
          relevanceScore 
        })
      }
    }
  }
})

every('hour', async ({ ai, db, task }) => {
  const pendingRequests = await db.landscapeRequests.find({ status: 'queued' })
  const processingCapacity = await getProcessingCapacity()
  
  const requestsToProcess = pendingRequests.slice(0, processingCapacity)
  
  for (const request of requestsToProcess) {
    task.do('ProcessLandscapeRequest', request)
  }
})

every('day at 09:00', async ({ ai, db, task }) => {
  const customers = await db.customers.find({ alertsEnabled: true })
  
  for (const customer of customers) {
    const dailyAlerts = await db.alerts.find({ 
      customerId: customer.id, 
      createdAt: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) } 
    })
    
    if (dailyAlerts.length > 0) {
      const digest = await ai.call('generateAlertDigest', { alerts: dailyAlerts })
      task.do('SendDailyDigest', { customerId: customer.id, digest })
    }
  }
})

every('week on Mon at 08:00', async ({ ai, db, task }) => {
  const customers = await db.customers.find({ plan: { $in: ['growth', 'enterprise'] } })
  
  for (const customer of customers) {
    const weeklyReport = await generateMonthlyReport(customer.id)
    task.do('SendWeeklyReport', { customerId: customer.id, report: weeklyReport })
  }
})

every('month on 1st at 10:00', async ({ ai, db, task }) => {
  const allCustomers = await db.customers.find({})
  
  for (const customer of allCustomers) {
    const monthlyReport = await generateMonthlyReport(customer.id)
    const usageAnalysis = await analyzeCustomerUsage(customer.id)
    const expansionOpportunities = await identifyExpansionOpportunities(customer, usageAnalysis)
    
    task.do('SendMonthlyReport', { customerId: customer.id, report: monthlyReport })
    
    if (expansionOpportunities.length > 0) {
      task.do('NotifyCSM', { 
        customerId: customer.id, 
        opportunities: expansionOpportunities 
      })
    }
  }
})

async function getRelevantTarget(therapeuticArea: string): Promise<string> {
  const targetMap = {
    'oncology': 'KRAS',
    'immunology': 'TNF',
    'neurology': 'APOE',
    'cardiology': 'PCSK9'
  }
  return targetMap[therapeuticArea.toLowerCase()] || 'EGFR'
}

async function getPlanFeatures(plan: string): Promise<string[]> {
  const features = {
    team: ['Up to 5 users', '50 landscapes/mo', 'Standard alerts', 'Email support'],
    growth: ['Up to 25 users', '250 landscapes/mo', 'API access', 'SSO', 'Priority support'],
    enterprise: ['Unlimited users', 'Private index/VPC', 'SLAs', 'Custom ontologies', 'Dedicated CSM']
  }
  return features[plan] || features.team
}

async function setupCustomerEnvironment(customer: Customer): Promise<void> {
  // Implementation for setting up customer-specific environment
}

async function scheduleOnboardingCall(customer: Customer): Promise<void> {
  // Implementation for scheduling onboarding call
}

async function sendWelcomeEmail(customer: Customer): Promise<void> {
  // Implementation for sending welcome email
}

async function expandSynonyms(target: string, modality: string, indication: string): Promise<any> {
  // Implementation for expanding biological synonyms using ontologies
}

async function buildBiologyAwareQuery(synonyms: any, database: string): Promise<string> {
  // Implementation for building biology-aware search queries
}

async function searchLiteratureDatabases(query: string): Promise<any[]> {
  // Implementation for searching PubMed, bioRxiv, medRxiv
}

async function searchPatentDatabases(query: string): Promise<any[]> {
  // Implementation for searching USPTO, EPO, WIPO patent databases
}

async function extractRelevantPassages(fullText: string): Promise<string[]> {
  // Implementation for extracting relevant passages using NLP
}

async function calculateConfidenceScore(paper: any): Promise<number> {
  // Implementation for calculating confidence scores
}

async function classifyEvidenceType(paper: any): Promise<'preclinical' | 'clinical' | 'review'> {
  // Implementation for classifying evidence type
}

async function parseIndependentClaims(claims: string): Promise<string[]> {
  // Implementation for parsing independent patent claims
}

async function extractNoveltyIndicators(claims: string): Promise<string[]> {
  // Implementation for extracting novelty indicators
}

async function assessLitigationRisk(patent: any): Promise<'low' | 'medium' | 'high'> {
  // Implementation for assessing litigation risk
}

async function buildEvidenceMatrix(literature: any[], patents: any[]): Promise<any> {
  // Implementation for building evidence matrix
}

async function identifyWhiteSpace(evidenceMatrix: any): Promise<string[]> {
  // Implementation for identifying white space areas
}

async function calculateCompetitiveDensity(patents: any[]): Promise<number> {
  // Implementation for calculating competitive density
}

async function calculateEvidenceStrength(literature: any[]): Promise<number> {
  // Implementation for calculating evidence strength
}

async function generateRecommendations(whiteSpace: string[], density: number, strength: number): Promise<string[]> {
  // Implementation for generating actionable recommendations
}

async function getCustomer(customerId: string): Promise<Customer> {
  // Implementation for retrieving customer data
}

async function calculateRelevanceScore(content: any, customer: Customer): Promise<number> {
  // Implementation for calculating alert relevance score
}

async function sendAlert(customer: Customer, alertData: any, relevanceScore: number): Promise<void> {
  // Implementation for sending alerts to customers
}

async function getMonthlyActivity(customerId: string): Promise<any> {
  // Implementation for retrieving monthly activity data
}

async function extractKeyInsights(activity: any): Promise<string[]> {
  // Implementation for extracting key insights from activity
}

async function generateActionRecommendations(activity: any): Promise<string[]> {
  // Implementation for generating action recommendations
}

async function findRelevantCustomers(alert: any): Promise<Customer[]> {
  // Implementation for finding customers relevant to alert
}

async function getProcessingCapacity(): Promise<number> {
  // Implementation for determining current processing capacity
}

async function analyzeCustomerUsage(customerId: string): Promise<any> {
  // Implementation for analyzing customer usage patterns
}

async function identifyExpansionOpportunities(customer: Customer, usage: any): Promise<any[]> {
  // Implementation for identifying expansion opportunities
}

export default function Page() {
  return (
    <>
      <Hero
        title="IP landscape intelligence in minutes, not weeks"
        subtitle="AI-powered platform that maps literature, preprints, and patents around any target–modality–indication triad with source-grounded evidence and actionable gap analysis."
        ctaText="Start your free landscape analysis"
        ctaHref="/contact"
      />
      <Problem bullets={[
        "R&D teams spend 40-80 hours per landscaping cycle with quickly outdated results",
        "Critical prior art is missed due to synonymy and siloed sources",
        "Existing alerts are noisy and non-actionable, requiring manual triage",
        "Manual linking of target-modality-indication evidence prevents gap visualization",
        "Enterprise tools lack biology-specific NLP and real-time preprint-patent linkage"
      ]} />
      <Solution bullets={[
        "Unified evidence graph normalizing targets, modalities, and indications",
        "High-recall retrieval with domain ontologies and RAG summaries",
        "Claim-scoped IP view with scope extraction and litigation signals",
        "Gap analysis and white-space maps with competitive density visualization",
        "Precision alerts with user-tunable filters and relevance feedback"
      ]} />
      <Features items={[
        "Biology-aware search and synonym expansion",
        "Source-grounded evidence synthesis",
        "Claim-level patent analysis",
        "Real-time alerts and monitoring",
        "Gap analysis and white-space mapping",
        "ELN/LIMS integrations and API access"
      ]} />
      <Steps steps={[
        "Free trial with demo landscape",
        "Pilot with core R&D team",
        "Scale across organization"
      ]} />
    </>
  )
}
