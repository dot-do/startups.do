---
name: ThermaMason AI
slug: thermamason
naics:
  primary: '327331'
  occupations: []
service:
  title: Energy & Kiln/Dryer Optimization
  description: >-
    Analyze energy use and kiln/dryer cycles to cut kWh/therms and demand
    charges without compromising quality.
  targetUsers:
    - Plant Manager
    - Maintenance/Energy Lead
    - Finance
  triggers:
    - Monthly utility bill received
    - Demand charge spikes
    - Process change or new product
  inputs:
    - 'Utility interval data (kW/kWh, demand charges)'
    - Kiln/dryer cycle telemetry and setpoints
    - Production schedule and batch types
    - Ambient conditions (optional)
  steps:
    - Baseline energy intensity by SKU and cycle
    - Cluster cycles to identify inefficient patterns
    - Simulate setpoint/schedule tweaks and load shifting
    - Recommend cycle libraries and demand-limit strategies
    - Build savings tracker and M&V report
  tools:
    - Python/Pandas
    - Time-series clustering
    - Optuna for parameter search
    - Power BI
    - Green Button/utility portal exports
  outputs:
    - Cycle optimization recommendations
    - Demand charge reduction plan
    - Monthly M&V savings report
  pricingModel:
    - Low monthly retainer + performance fee (% of verified savings)
    - Optional one-time audit
  humanInLoop: true
  feasibility:
    remoteOnLaptop: 8
    modelCapability: 7
    overall: 7.5
  risks:
    - Incomplete telemetry or manual operation overrides
    - Quality impact if changes not validated
    - Seasonality affecting results
  dependencies:
    - Access to utility interval data
    - Kiln/dryer telemetry exports
    - Approval to trial revised cycles
leanCanvas:
  problem:
    - >-
      Kiln and curing/dryer energy is 15–35% of unit cost for brick and 5–15%
      for concrete block; energy waste from suboptimal cycles, idling, and poor
      load planning drives margins down.
    - >-
      Demand charges (often $12–$25/kW-month) spike from simultaneous starts,
      peak-hour operation, or compressed-air/fan ramps add 8–20% to electricity
      bills.
    - >-
      Recipes are fixed or operator-tuned and drift over time with feedstock
      moisture, ambient conditions, and maintenance state—leading to 2–6%
      scrap/rework or quality variability.
    - >-
      Data is siloed across PLCs/SCADA, historians, and utility bills; no
      unified baseline for kWh/therms per 1,000 units by SKU, shift, or
      kiln/line.
    - >-
      Limited in-house data science and APC expertise; OEM controls deliver
      stability but not continuous economic optimization vs. tariffs and carbon
      targets.
    - >-
      Capital for new kilns is scarce; plants need software-led, low-capex
      savings with <12-month payback and credible M&V to unlock utility
      incentives.
    - >-
      Safety and compliance concerns (overfires, off-gas, VOCs) deter aggressive
      optimization without guardrails and automated interlocks.
  solution:
    - >-
      Unified data layer: Connect to PLC/SCADA (OPC UA/Modbus), historians
      (PI/AVEVA), meters, and utility billing; normalize to kWh and therms per
      1,000 units and per cycle.
    - >-
      Digital twin + baseline models: ML models for heat-up/soak/cool phases
      that account for load, moisture, ambient temp, fuel quality, and kiln
      health; establish baseline kWh/therms and peak kW.
    - >-
      Cycle optimizer: Recommends dynamic setpoints, ramps, and hold times to
      minimize energy per unit while meeting core specs (strength, absorption,
      warpage).
    - >-
      Peak demand scheduler: Shifts non-critical cycles and high-load ramps
      outside peak windows; coordinates fans, compressors, and autoclaves to
      avoid coincident peaks.
    - >-
      Quality guardrails: Hard constraints on temperature gradients, dew point,
      O2, and pressure; automated interlocks with rollback to safe recipes if
      drift detected.
    - >-
      Anomaly detection & predictive maintenance: Flag fouled burners, leaking
      dampers, failing fan bearings, blocked flues, and sensor drift to prevent
      energy creep and unplanned downtime.
    - >-
      Operator copilot: Role-based UI with playbooks, what-if scenarios, and
      on-shift recommendations; mobile alerts for deviations.
    - >-
      M&V and incentives: IPMVP Option C measurement, weather/feedstock
      normalization, and support to capture utility rebates/retrofit incentives.
    - >-
      Carbon and compliance reporting: Auto-generate MTCO2e per product line,
      ESG rollups, and audit trails.
  uniqueValueProp: >-
    Cut kiln/dryer energy cost 10–20% and demand charges 10–25% in 8–12
    weeks—with guaranteed quality guardrails and third-party verified savings
    (IPMVP) that qualify for utility incentives. No major capex, integrates with
    existing PLC/SCADA.
  unfairAdvantage: >-
    A constraint-aware kiln/dryer optimization engine trained on cross-plant
    datasets, coupled with OEM and utility program partnerships that accelerate
    approvals and incentives—delivering verified savings without compromising
    quality or safety.
  customerSegments:
    - >-
      Primary: US and Canada concrete block/CMU and brick manufacturers (NAICS
      327331) with gas-fired kilns, steam/autoclave curing rooms, or dryers;
      energy spend >$500k/year.
    - >-
      Secondary: OEM kiln/dryer providers and system integrators seeking
      differentiated analytics/APC offering.
    - >-
      Tertiary: Multi-plant building materials groups consolidating energy
      programs and carbon reporting.
  channels:
    - >-
      Account-based sales to Plant Managers, Operations Directors, and
      Energy/ESG leaders at NAICS 327331 firms; target 200 priority plants by
      energy spend and kiln count.
    - >-
      Industry associations and events: NCMA/ICPI-NCPA, Brick Industry
      Association (BIA), World of Concrete; host technical workshops and ROI
      clinics.
    - >-
      OEM/integrator partnerships: Co-sell with kiln/dryer OEMs (e.g., Lingl,
      Harrop, Keller HCW) and control SI partners; bundle into
      upgrades/retrofits.
    - >-
      Utility program alliances: Register as trade ally with major IOUs;
      collaborate with implementers (CLEAResult, DNV) to pre-qualify measure and
      secure incentives.
    - >-
      Pilot-first motion: 8–12 week paid pilots on 1 line with savings
      guarantee; convert >70% to 3-year subscriptions post-M&V.
    - >-
      Content and proof: Publish case studies with kWh/therm/peak kW reductions;
      calculators that output payback with local tariffs; webinars with
      customers.
    - >-
      DR aggregators: Integrate with Enel X/CPower to monetize DR; share
      performance fees with customers.
    - >-
      Referral program: Incentivize multi-plant rollouts and OEM referrals with
      discounts and revenue share.
  revenueStreams:
    - >-
      SaaS subscription per line: $30k–$75k/year depending on complexity and
      features.
    - >-
      Implementation/integration fee: $15k–$50k per site (covers data
      connectors, edge hardware, commissioning, recipe onboarding).
    - >-
      Performance fee: 10–20% of verified first-year savings (optional
      shared-savings plan).
    - >-
      Premium support/SLA: 24/7 support, quarterly onsite optimization:
      $10k–$25k/year per site.
    - >-
      OEM/integrator licensing: White-label analytics/APC modules with annual
      license and per-deployment fees.
    - >-
      Utility incentive facilitation: Fee share (5–10%) for secured
      rebates/retrofit incentives where allowed.
  costStructure:
    - >-
      R&D: Data science, process control engineers, software engineers for
      real-time/edge, UI/UX.
    - >-
      Cloud and edge infra: Compute, data storage, model training/serving; est.
      $200–$600/month per line.
    - >-
      Hardware: Edge gateways, meters, sensors as needed; $5k–$25k per line
      one-time (pass-through or financed).
    - 'Implementation: Field engineering, travel, partner commissions (10–20%).'
    - 'Sales and marketing: ABM tools, events, content, demos, pilots.'
    - 'Security and compliance: SOC 2 audits, penetration tests, cyber insurance.'
    - >-
      M&V and program admin: Third-party verification costs, tariff database, DR
      integrations.
    - 'G&A: Legal (data/controls liability), finance, HR.'
  keyMetrics:
    - >-
      Customer energy intensity: therms per 1,000 bricks; kWh per 1,000 CMUs;
      target 10–20% reduction in 90 days.
    - >-
      Peak demand: kW reduction vs. baseline; target 10–25% reduction and <2
      peak excursions/month.
    - >-
      Quality KPIs: Scrap/rework rate ≤ baseline; strength/absorption within
      spec 99%+ of cycles.
    - >-
      Cycle time: Reduce average cycle time 3–8% without quality loss; OEE gain
      2–5%.
    - >-
      Availability: System uptime ≥ 99.5%; edge data latency < 5 seconds;
      control recommendation acceptance rate > 70%.
    - >-
      Model performance: Forecast MAE for energy per cycle < 6%; anomaly
      detection precision/recall > 0.8.
    - >-
      Time-to-value: Pilot installed to measurable savings ≤ 8 weeks; payback <
      6 months for typical site.
    - >-
      Commercial: Pilot-to-subscription conversion ≥ 70%; ARR per plant
      $60k–$250k; gross margin ≥ 70%; churn < 8% annually.
storyBrand:
  character: >-
    Plant managers and operations leaders at concrete block and brick
    manufacturers who must lower energy spend and demand peaks without risking
    cure quality or throughput.
  problem: >-
    External: Rising kWh/therm costs and demand charges from kiln/dryer peaks;
    inconsistent cycles waste energy and time. Internal: You’re accountable for
    margins, uptime, and quality (strength, absorption, color) and can’t risk
    tinkering. Philosophical: Manufacturers shouldn’t have to choose between
    product quality and energy efficiency.
  guide: >-
    Empathy: We’ve run plant-floor projects and understand cure windows,
    moisture profiles, and seasonal swings. Authority: Built by thermal/process
    engineers and data scientists; proven AI optimization on industrial
    kilns/dryers; references, QA guardrails, and secure data handling.
  plan: >-
    1) Assess: Baseline interval energy, kiln/dryer logs, production, and
    weather; pinpoint peak drivers. 2) Model: Build an AI twin of your
    kilns/dryers with quality-constrained optimization. 3) Optimize & Prove:
    Pilot schedule/setpoint improvements; verify savings and QC on-line. 4)
    Scale: Roll out, train operators, automate alerts and weekly tuning.
    Agreement: no downtime, QC guardrails, transparent M&V, opt-out at any
    stage.
  callToAction: >-
    Direct: Schedule a 30-minute discovery call and share a month of data.
    Transitional: Request a sample savings report and the Kiln/Dryer Energy
    Checklist.
  success: >-
    Lower energy use 8–20% and demand charges 10–30% (typical), maintain or
    improve strength/absorption/color, stabilize schedules, increase throughput,
    cut CO2, and gain predictable utility costs with payback in months, not
    years.
  failure: >-
    Status quo means persistent overpayment on energy and peaks, margin erosion,
    missed ESG targets, avoidable quality variability and rework, surprise
    penalty bills, and pressure to spend on unnecessary capex.
landingPage:
  hero:
    title: AI Energy & Kiln/Dryer Optimization for Concrete Block & Brick Plants
    subtitle: >-
      Cut kWh, therms, and demand charges—without compromising strength or
      finish.
    ctaText: Book a 30‑min demo
    ctaHref: /demo
  problem:
    - 'Kilns/dryers run conservatively, inflating energy use.'
    - Demand spikes trigger costly peak and ratchet charges.
    - 'Static recipes ignore moisture, product mix, and weather.'
    - Quality risk blocks cycle changes and throughput gains.
    - Operators lack real-time visibility into true energy drivers.
    - 'Sustainability goals need verifiable, audit-ready savings.'
  solution:
    - >-
      AI analyzes energy, moisture, and cycle data to tune schedules in real
      time.
    - >-
      Predictive models preserve strength, density, and finish while cutting
      waste.
    - Load shifts off-peak to cap demand and flatten spikes.
    - 'One-click setpoint and recipe recommendations, operator-approved.'
    - 'Automated M&V reports: kWh/therms saved and peak kW avoided.'
    - Works with existing PLC/SCADA—no major capex required.
  features:
    - Digital twin of kiln/dryer thermodynamics and airflow.
    - 'Adaptive cycle optimization per product, mold, and line speed.'
    - Peak demand forecasting with preheat/preload strategies.
    - Weather- and gas/utility price–aware scheduling.
    - 'Sensor fusion: moisture, temperature, RH, and burner data.'
    - >-
      Quality constraints for compressive strength, density, color, and crack
      risk.
    - 'SCADA/PLC connectors (Allen‑Bradley, Siemens, Modbus/TCP).'
    - Operator HMI with approve/override and safe limits.
    - 'Automated, audit-ready M&V and carbon reporting.'
    - 'Health monitoring for drift, fouling, and burner efficiency.'
    - Multi-plant benchmarking with role-based dashboards.
  steps:
    - 'Week 1: Share utility bills, cycle logs, and PLC tag list.'
    - 'Week 2: Site walk and secure read-only connectivity.'
    - 'Week 3: Baseline model and opportunity map delivered.'
    - 'Weeks 4–6: Pilot on one kiln/dryer with operator-in-the-loop.'
    - 'Month 2: Add demand management and schedule optimization.'
    - 'Go‑Live: Guided setpoints or closed-loop control, with continuous tuning.'
shortName: ThermaMason AI
---

# ThermaMason AI

Generated for NAICS 327331 — Concrete Block and Brick Manufacturing.
Service: Energy & Kiln/Dryer Optimization

## Business Process Functions

```typescript
// Core business entity interfaces
interface Lead {
  id: string;
  companyName: string;
  plantLocation: string;
  contactInfo: ContactInfo;
  energySpend: number;
  kilnCount: number;
  naicsCode: string;
  currentEnergyIntensity?: number;
}

interface Customer {
  id: string;
  lead: Lead;
  contractDetails: ContractDetails;
  plantData: PlantData;
  onboardingStatus: OnboardingStatus;
}

interface PlantData {
  kilnTypes: KilnType[];
  energyBaseline: EnergyBaseline;
  productionSchedule: ProductionSchedule;
  qualitySpecs: QualitySpecs;
}

interface EnergyBaseline {
  kWhPer1000Units: number;
  thermsPer1000Units: number;
  peakDemandKW: number;
  demandCharges: number;
  totalEnergyCost: number;
}

interface OptimizationRecommendation {
  cycleAdjustments: CycleAdjustment[];
  demandReduction: DemandReduction;
  energySavings: EnergySavings;
  qualityGuardrails: QualityGuardrail[];
  implementationPlan: ImplementationPlan;
}

// Customer Acquisition Workflows
export async function acquireCustomer(lead: Lead): Promise<Customer> {
  const qualifiedLead = await qualifyLead(lead);
  const energyAssessment = await conductEnergyAssessment(qualifiedLead);
  const proposal = await generateProposal(qualifiedLead, energyAssessment);
  const pilot = await executePilotProgram(proposal);
  const contract = await negotiateContract(pilot);
  return await onboardCustomer(contract);
}

export async function qualifyLead(lead: Lead): Promise<QualifiedLead> {
  // Validate NAICS 327331 classification
  if (lead.naicsCode !== '327331') {
    throw new Error('Lead does not match target NAICS code');
  }
  
  // Check minimum energy spend threshold ($500k/year)
  if (lead.energySpend < 500000) {
    throw new Error('Energy spend below minimum threshold');
  }
  
  // Verify kiln/dryer presence
  const hasKilnDryer = await verifyKilnDryerPresence(lead);
  if (!hasKilnDryer) {
    throw new Error('No gas-fired kilns or dryers detected');
  }
  
  return {
    ...lead,
    qualificationScore: calculateQualificationScore(lead),
    priorityLevel: determinePriorityLevel(lead)
  };
}

export async function conductEnergyAssessment(lead: QualifiedLead): Promise<EnergyAssessment> {
  const utilityData = await collectUtilityData(lead);
  const kilnTelemetry = await gatherKilnTelemetry(lead);
  const productionData = await analyzeProductionData(lead);
  
  const baseline = await establishEnergyBaseline(utilityData, kilnTelemetry, productionData);
  const opportunities = await identifyOptimizationOpportunities(baseline);
  
  return {
    baseline,
    opportunities,
    potentialSavings: calculatePotentialSavings(opportunities),
    paybackPeriod: estimatePaybackPeriod(opportunities)
  };
}

// Product Development Processes
export async function developOptimizationEngine(plantData: PlantData[]): Promise<OptimizationEngine> {
  const digitalTwin = await buildDigitalTwin(plantData);
  const mlModels = await trainMLModels(plantData);
  const constraintEngine = await buildConstraintEngine(plantData);
  
  return await integrateOptimizationComponents(digitalTwin, mlModels, constraintEngine);
}

export async function buildDigitalTwin(plantData: PlantData[]): Promise<DigitalTwin> {
  const thermalModels = await createThermalModels(plantData);
  const airflowModels = await createAirflowModels(plantData);
  const moistureModels = await createMoistureModels(plantData);
  
  return await calibrateDigitalTwin(thermalModels, airflowModels, moistureModels);
}

export async function trainMLModels(plantData: PlantData[]): Promise<MLModels> {
  const energyPredictionModel = await trainEnergyPredictionModel(plantData);
  const qualityPredictionModel = await trainQualityPredictionModel(plantData);
  const anomalyDetectionModel = await trainAnomalyDetectionModel(plantData);
  
  return {
    energyPrediction: energyPredictionModel,
    qualityPrediction: qualityPredictionModel,
    anomalyDetection: anomalyDetectionModel
  };
}

// Revenue Generation Flows
export async function generateRevenue(customer: Customer): Promise<RevenueStream> {
  const subscription = await processSubscriptionRevenue(customer);
  const implementation = await processImplementationFees(customer);
  const performance = await processPerformanceFees(customer);
  const support = await processSupportRevenue(customer);
  
  return await consolidateRevenueStreams(subscription, implementation, performance, support);
}

export async function processSubscriptionRevenue(customer: Customer): Promise<SubscriptionRevenue> {
  const lineCount = customer.plantData.kilnTypes.length;
  const complexity = assessComplexity(customer.plantData);
  
  const annualFee = calculateSubscriptionFee(lineCount, complexity); // $30k-$75k/year
  
  return await processRecurringPayment(customer, annualFee);
}

export async function processPerformanceFees(customer: Customer): Promise<PerformanceRevenue> {
  const verifiedSavings = await measureAndVerifySavings(customer);
  const performanceFeeRate = 0.15; // 10-20% of verified savings
  
  if (verifiedSavings.firstYearSavings > 0) {
    const performanceFee = verifiedSavings.firstYearSavings * performanceFeeRate;
    return await processPerformancePayment(customer, performanceFee);
  }
  
  return { amount: 0, verified: false };
}

// Operational Procedures
export async function optimizeKilnOperation(customer: Customer): Promise<OptimizationResult> {
  const currentData = await collectRealTimeData(customer);
  const recommendations = await generateOptimizationRecommendations(currentData);
  const safetyCheck = await validateSafetyConstraints(recommendations);
  
  if (safetyCheck.passed) {
    return await implementOptimizations(recommendations);
  } else {
    return await rollbackToSafeRecipe(customer);
  }
}

export async function generateOptimizationRecommendations(data: RealTimeData): Promise<OptimizationRecommendation> {
  const cycleOptimizer = await optimizeCycleParameters(data);
  const demandScheduler = await optimizePeakDemand(data);
  const qualityGuardrails = await enforceQualityConstraints(data);
  
  return {
    cycleAdjustments: cycleOptimizer.recommendations,
    demandReduction: demandScheduler.recommendations,
    energySavings: calculateEnergySavings(cycleOptimizer, demandScheduler),
    qualityGuardrails: qualityGuardrails,
    implementationPlan: createImplementationPlan(cycleOptimizer, demandScheduler)
  };
}

export async function monitorAndMaintain(customer: Customer): Promise<MaintenanceResult> {
  const anomalies = await detectAnomalies(customer);
  const predictiveMaintenance = await predictMaintenanceNeeds(customer);
  const performanceMetrics = await trackPerformanceMetrics(customer);
  
  if (anomalies.length > 0) {
    await alertOperators(customer, anomalies);
    await scheduleMaintenanceActions(customer, anomalies);
  }
  
  return {
    anomalies,
    predictiveMaintenance,
    performanceMetrics,
    systemHealth: assessSystemHealth(performanceMetrics)
  };
}

// Decision-Making Workflows
export async function makeOptimizationDecision(
  customer: Customer,
  recommendations: OptimizationRecommendation
): Promise<OptimizationDecision> {
  const riskAssessment = await assessOptimizationRisk(recommendations);
  const benefitAnalysis = await analyzeBenefits(recommendations);
  const operatorApproval = await requestOperatorApproval(recommendations);
  
  if (riskAssessment.acceptable && benefitAnalysis.positive && operatorApproval.approved) {
    return await approveOptimization(recommendations);
  } else {
    return await rejectOptimization(recommendations, {
      risk: riskAssessment,
      benefits: benefitAnalysis,
      approval: operatorApproval
    });
  }
}

export async function decidePilotConversion(pilot: PilotProgram): Promise<ConversionDecision> {
  const savingsVerification = await verifyPilotSavings(pilot);
  const qualityValidation = await validateQualityMaintenance(pilot);
  const operatorFeedback = await collectOperatorFeedback(pilot);
  const roiAnalysis = await calculateROI(pilot);
  
  const conversionScore = calculateConversionScore({
    savings: savingsVerification,
    quality: qualityValidation,
    feedback: operatorFeedback,
    roi: roiAnalysis
  });
  
  // Target >70% pilot-to-subscription conversion
  if (conversionScore > 0.7) {
    return await convertToSubscription(pilot);
  } else {
    return await extendPilotOrTerminate(pilot, conversionScore);
  }
}

export async function makeCapacityPlanningDecision(
  demandForecast: DemandForecast,
  currentCapacity: PlantCapacity
): Promise<CapacityDecision> {
  const utilizationAnalysis = await analyzeCapacityUtilization(currentCapacity);
  const bottleneckIdentification = await identifyBottlenecks(currentCapacity);
  const optimizationPotential = await assessOptimizationPotential(currentCapacity);
  
  if (utilizationAnalysis.efficiency < 0.8) {
    return await recommendOptimizationFirst(optimizationPotential);
  } else if (demandForecast.growth > currentCapacity.max) {
    return await recommendCapacityExpansion(demandForecast, bottleneckIdentification);
  } else {
    return await maintainCurrentCapacity(currentCapacity);
  }
}

// Utility functions for business logic
async function calculateQualificationScore(lead: Lead): Promise<number> {
  const energySpendScore = Math.min(lead.energySpend / 1000000, 1.0); // Normalize to $1M
  const kilnCountScore = Math.min(lead.kilnCount / 10, 1.0); // Normalize to 10 kilns
  
  return (energySpendScore * 0.6) + (kilnCountScore * 0.4);
}

async function calculatePotentialSavings(opportunities: OptimizationOpportunity[]): Promise<SavingsPotential> {
  const energyCostReduction = opportunities.reduce((sum, opp) => sum + opp.energySavings, 0);
  const demandChargeReduction = opportunities.reduce((sum, opp) => sum + opp.demandSavings, 0);
  
  return {
    energyCostReduction: energyCostReduction * 0.15, // 10-20% target
    demandChargeReduction: demandChargeReduction * 0.175, // 10-25% target
    totalAnnualSavings: (energyCostReduction * 0.15) + (demandChargeReduction * 0.175),
    paybackPeriod: calculatePaybackPeriod(energyCostReduction, demandChargeReduction)
  };
}

async function validateSafetyConstraints(recommendations: OptimizationRecommendation): Promise<SafetyValidation> {
  const temperatureGradients = await checkTemperatureGradients(recommendations);
  const dewPointLimits = await checkDewPointLimits(recommendations);
  const oxygenLevels = await checkOxygenLevels(recommendations);
  const pressureLimits = await checkPressureLimits(recommendations);
  
  return {
    passed: temperatureGradients.valid && dewPointLimits.valid && oxygenLevels.valid && pressureLimits.valid,
    violations: [
      ...temperatureGradients.violations,
      ...dewPointLimits.violations,
      ...oxygenLevels.violations,
      ...pressureLimits.violations
    ]
  };
}
```
