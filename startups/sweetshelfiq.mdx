---
name: SweetShelfIQ
slug: sweetshelfiq
naics:
  primary: "424450"
  occupations: []
leanCanvas:
  problem:
    - "Wholesaler category managers spend 10–20 hours per retailer reset assembling SKU lists and planograms from spreadsheets, PDFs, and legacy tools."
    - "Seasonality in confectionery (Valentine's, Easter, Halloween, Holiday) causes frequent mismatches between DC inventory, retailer shelf space, and consumer demand, resulting in 5–10% lost sales and high markdowns."
    - "One-size-fits-all assortments ignore retailer type, region, and shelf constraints; small-format retailers (2–4 ft candy sets) are underserved."
    - "Planogram proposals often lack defensible analytics (velocity, margin, promo calendar), lowering retailer acceptance rates below 50%."
    - "Compliance and execution gaps (no store-level plan) cause out-of-stocks and facing errors; post-reset audits show 20–30% non-compliance."
    - "Wholesalers lack integrated visibility across syndicated data (NIQ/Circana), POS, DC inventory, and manufacturer promotions, slowing responses to retailer RFPs by 1–2 weeks."
    - "Temperature and melt risk (summer chocolate) and adjacency rules are not systematically applied, leading to waste and poor shopper experience."
    - "New item introductions and SKU rationalization are guesswork, causing proliferation without incremental sales or margin gains."
  solution:
    - "AI-driven assortment optimization using velocity, margin dollars, DC inventory, and promotional uplift models per retailer format and season."
    - "Auto-generated basic planograms (e.g., 2–8 ft shelf, peg/shelf mix) with constraints for facings, adjacency, pack type, and temperature/melt risk by region/time."
    - "Seasonal switch-over builder that maps everyday→seasonal→everyday, with DC depletion plans and markdown minimization."
    - "Retailer-ready proposal packs (PDF/PowerPoint export) with rationale: expected sales lift, GM$, turns, OOS reduction, and new-item justifications."
    - "Integration to wholesaler data (ERP/OMS/DC inventory), syndicated data (NIQ/Circana), and retailer POS where available; export to JDA/Blue Yonder, NIQ Spaceman, and DotActiv."
    - "Compliance toolkit: printable planograms, shelf tags/UPC lists, and a mobile checklist; optional photo-based audits via partner."
    - "Continuous learning loop: post-implementation readouts compare forecast vs actual and refine rules."
    - "API-first architecture for partners (manufacturers, brokers) to co-author proposals with the wholesaler."
  uniqueValueProp: "Increase retailer acceptance and sales lift with AI-generated, data-backed assortments and basic planograms tailored to retailer type, season, and shelf space—delivered in minutes, aligned to DC inventory and promo calendars."
  unfairAdvantage: "Confectionery-specific models and taxonomy (season codes, melt risk, adjacency rules) trained on multi-season data; integrations that align assortments with DC inventory and promo funding; partnerships with manufacturers and space-planning vendors to co-sell and drive retailer acceptance; growing benchmark dataset that improves recommendations and proposal credibility."
  customerSegments:
    - "Primary: Confectionery merchant wholesalers (NAICS 424450) with category management and space planning teams."
    - "Broadline convenience distributors with strong candy sets (e.g., regional divisions of national wholesalers)."
    - "Specialty candy wholesalers serving independent grocers, dollar, drug, and gift channels."
    - "Wholesaler divisions supporting small chains (10–500 stores) where basic planograms drive outsized impact."
    - "Secondary influencers: confectionery manufacturers and brokers acting as category captains/cos, seeking data-driven proposals via wholesalers."
  channels:
    - "Direct sales to wholesaler HQ and regional divisions via category management leaders."
    - "Pilot-led selling: 8–12 week paid pilots with 1–2 retailer accounts per division."
    - "Co-selling with manufacturers/brokers seeking category captaincy; revenue-sharing on joint proposals."
    - "Trade shows and associations: Sweets & Snacks Expo, NACS Show, Category Management Association events."
    - "Content marketing: seasonal assortment guides, planogram benchmarks, ROI case studies; targeted LinkedIn ABM."
    - "Partnerships with syndicated data providers (NIQ/Circana) and space-planning vendors for referrals and integrations."
    - "Reseller/implementation partners: CPG analytics consultancies and broker networks."
    - "Customer marketing to existing wholesaler retailer base: offer value-added planogram service as differentiation."
  revenueStreams:
    - "Annual SaaS subscription per wholesaler division: $36k–$120k depending on user seats (5–25), retailer count, and data integrations."
    - "Per-retailer/store planogram package: $5–$15/store/year for basic planograms and compliance kit (via wholesaler upsell)."
    - "Implementation and data integration fees: $15k–$50k one-time per division (ERP/DC inventory, syndicated data, SSO)."
    - "Professional services (custom rules, advanced analytics, seasonal playbooks): $150–$250/hour or fixed bundles."
    - "Manufacturer/broker sponsorships for new-item modules and joint proposals: $25k–$100k per season/brand cluster."
    - "Optional photo-audit/compliance add-on (via partner): $3–$6/store/month; revenue share 20–30%."
  costStructure:
    - "People (year 1–2): 6–10 FTE product/engineering/data ($1.2M–$2.2M), 2–3 FTE category advisors/CSM ($350k–$600k), 1–2 FTE sales/marketing ($250k–$500k)."
    - "Cloud/compute: $8k–$20k/month (model training/inference, storage, secure VPC)."
    - "Syndicated data and product catalog enrichment (optional/partner): $100k–$300k/year depending on scope."
    - "Security/compliance: SOC 2 Type II, pen tests, logging: $60k–$150k/year."
    - "Sales/marketing: events, content, travel: $100k–$250k/year."
    - "Third-party integrations and licenses (JDA/Spaceman exports, OCR for planogram images): $20k–$80k/year."
  keyMetrics:
    - "Retailer acceptance rate of proposed assortments/planograms: target 65–80% (baseline often <50%)."
    - "Sales lift vs control after reset: target +3–7% category sales; GM$ lift +2–5%."
    - "Out-of-stock reduction on top 50 SKUs: target −15–30% within 60 days of reset."
    - "Inventory turns improvement on seasonal items: target +10–20%; seasonal leftover markdown reduction −15–25%."
    - "Time-to-proposal: reduce from 1–2 weeks to <1 day; planogram generation <5 minutes per set."
    - "SKU rationalization: reduce tail SKUs by 10–20% without losing category sales; new item success rate >60% after 90 days."
    - "Compliance rate at store audits: target 80–90% within 30 days of reset."
    - "User adoption: weekly active users/seat >70%; proposal creation per division: 4–12/month."
    - "Forecast accuracy (seasonal lift MAPE): <20% after 2 seasons of learning."
---

# SweetShelfIQ Business Workflows

## Core Business Process Functions

```typescript
// Core data types for confectionery wholesaler operations
interface Lead {
  wholesalerId: string
  companyName: string
  contactInfo: ContactInfo
  currentChallenges: string[]
  retailerCount: number
  annualVolume: number
  currentTools: string[]
}

interface Customer {
  id: string
  wholesaler: WholesalerProfile
  subscription: SubscriptionTier
  integrations: DataIntegration[]
  onboardingStatus: OnboardingStatus
}

interface RetailerProfile {
  id: string
  name: string
  format: 'convenience' | 'grocery' | 'dollar' | 'drug' | 'gift'
  shelfSpace: ShelfConstraints
  region: string
  seasonalPreferences: SeasonalProfile[]
}

interface SKU {
  upc: string
  description: string
  category: string
  seasonCode: 'everyday' | 'valentine' | 'easter' | 'halloween' | 'holiday'
  meltRisk: boolean
  velocity: number
  marginDollars: number
  dcInventory: number
  promoSchedule: PromoEvent[]
}

interface Planogram {
  retailerId: string
  shelfSize: number
  skuAssortment: SKU[]
  facingRules: FacingRule[]
  adjacencyConstraints: AdjacencyRule[]
  expectedPerformance: PerformanceMetrics
}

// Customer Acquisition Workflows
export async function acquireCustomer(lead: Lead): Promise<Customer> {
  try {
    const qualifiedLead = await qualifyLead(lead)
    const proposal = await generateProposal(qualifiedLead)
    const pilot = await setupPilot(proposal)
    const contract = await negotiateContract(pilot)
    return await onboardCustomer(contract)
  } catch (error) {
    throw new Error(`Customer acquisition failed: ${error.message}`)
  }
}

async function qualifyLead(lead: Lead): Promise<QualifiedLead> {
  const scoreCard = await calculateLeadScore({
    retailerCount: lead.retailerCount,
    annualVolume: lead.annualVolume,
    currentPainPoints: lead.currentChallenges,
    techStack: lead.currentTools
  })
  
  if (scoreCard.score < 70) {
    throw new Error('Lead does not meet qualification criteria')
  }
  
  return {
    ...lead,
    score: scoreCard.score,
    fitReason: scoreCard.reasoning,
    estimatedARR: calculateEstimatedARR(lead)
  }
}

async function generateProposal(qualifiedLead: QualifiedLead): Promise<Proposal> {
  const benchmarkData = await fetchIndustryBenchmarks(qualifiedLead.wholesaler.segment)
  const roiProjection = await calculateROIProjection({
    currentTimeToProposal: benchmarkData.avgTimeToProposal,
    currentAcceptanceRate: benchmarkData.avgAcceptanceRate,
    targetImprovement: {
      timeReduction: 0.85, // 85% reduction
      acceptanceIncrease: 0.30 // 30% increase
    }
  })
  
  return {
    customizedDemo: await buildCustomDemo(qualifiedLead),
    roiCalculator: roiProjection,
    pilotPlan: await designPilotProgram(qualifiedLead),
    pricingOptions: await generatePricingOptions(qualifiedLead)
  }
}

async function setupPilot(proposal: Proposal): Promise<PilotProgram> {
  const selectedRetailers = await selectPilotRetailers(proposal.pilotPlan)
  const dataConnections = await establishDataConnections(proposal.pilotPlan.dataRequirements)
  
  return {
    duration: '8-12 weeks',
    retailers: selectedRetailers,
    successMetrics: definePilotKPIs(),
    dataIntegrations: dataConnections,
    timeline: generatePilotTimeline()
  }
}

// Product Development Processes
export async function developProductFeature(featureRequest: FeatureRequest): Promise<ProductRelease> {
  try {
    const requirements = await analyzeFeatureRequirements(featureRequest)
    const design = await createFeatureDesign(requirements)
    const development = await implementFeature(design)
    const testing = await validateFeature(development)
    return await releaseFeature(testing)
  } catch (error) {
    throw new Error(`Product development failed: ${error.message}`)
  }
}

async function analyzeFeatureRequirements(request: FeatureRequest): Promise<Requirements> {
  const customerFeedback = await aggregateCustomerFeedback(request.category)
  const marketResearch = await conductMarketAnalysis(request.category)
  const technicalFeasibility = await assessTechnicalFeasibility(request)
  
  return {
    userStories: generateUserStories(customerFeedback),
    acceptanceCriteria: defineAcceptanceCriteria(request),
    technicalSpecs: technicalFeasibility,
    priorityScore: calculateFeaturePriority(customerFeedback, marketResearch)
  }
}

async function createFeatureDesign(requirements: Requirements): Promise<FeatureDesign> {
  const uiMockups = await generateUIMockups(requirements.userStories)
  const apiSpecs = await defineAPISpecifications(requirements.technicalSpecs)
  const dataModel = await designDataModel(requirements)
  
  return {
    userInterface: uiMockups,
    apiEndpoints: apiSpecs,
    dataStructures: dataModel,
    integrationPoints: identifyIntegrationPoints(requirements)
  }
}

// Revenue Generation Flows
export async function processRetailerRFP(rfp: RetailerRFP): Promise<ProposalResponse> {
  try {
    const analysis = await analyzeRFPRequirements(rfp)
    const assortment = await optimizeAssortment(analysis)
    const planogram = await generatePlanogram(assortment)
    const proposal = await buildProposalPackage(planogram)
    return await submitProposal(proposal)
  } catch (error) {
    throw new Error(`RFP processing failed: ${error.message}`)
  }
}

async function analyzeRFPRequirements(rfp: RetailerRFP): Promise<RFPAnalysis> {
  const retailerProfile = await fetchRetailerProfile(rfp.retailerId)
  const shelfConstraints = await parseShelfRequirements(rfp.specifications)
  const seasonalNeeds = await identifySeasonalRequirements(rfp.timeframe)
  
  return {
    retailer: retailerProfile,
    constraints: shelfConstraints,
    seasonal: seasonalNeeds,
    competitiveContext: await analyzeCompetitiveLandscape(rfp.retailerId)
  }
}

async function optimizeAssortment(analysis: RFPAnalysis): Promise<OptimizedAssortment> {
  const availableInventory = await fetchDCInventory(analysis.retailer.distributionCenter)
  const velocityData = await getSyndicatedData(analysis.retailer.region)
  const promoCalendar = await getPromoCalendar(analysis.seasonal.timeframe)
  
  const aiModel = await loadAssortmentOptimizationModel()
  const optimization = await aiModel.optimize({
    inventory: availableInventory,
    velocity: velocityData,
    promotions: promoCalendar,
    constraints: analysis.constraints,
    objectives: ['maximize_margin_dollars', 'minimize_oos_risk', 'optimize_turns']
  })
  
  return {
    selectedSKUs: optimization.skuList,
    expectedPerformance: optimization.projections,
    rationale: optimization.reasoning,
    alternatives: optimization.alternativeOptions
  }
}

async function generatePlanogram(assortment: OptimizedAssortment): Promise<Planogram> {
  const shelfLayout = await calculateOptimalLayout({
    skus: assortment.selectedSKUs,
    shelfDimensions: assortment.constraints.shelfSize,
    facingRules: await getFacingRules(),
    adjacencyRules: await getAdjacencyRules()
  })
  
  const complianceChecks = await validateCompliance(shelfLayout)
  const visualPlanogram = await renderPlanogramVisual(shelfLayout)
  
  return {
    layout: shelfLayout,
    visual: visualPlanogram,
    compliance: complianceChecks,
    implementation: await generateImplementationGuide(shelfLayout)
  }
}

// Operational Procedures
export async function executeSeasonalTransition(transition: SeasonalTransition): Promise<TransitionResult> {
  try {
    const currentInventory = await auditCurrentInventory(transition.fromSeason)
    const depletionPlan = await createDepletionStrategy(currentInventory)
    const newAssortment = await planNewSeasonAssortment(transition.toSeason)
    const timeline = await scheduleTransition(depletionPlan, newAssortment)
    return await executeTransitionPlan(timeline)
  } catch (error) {
    throw new Error(`Seasonal transition failed: ${error.message}`)
  }
}

async function auditCurrentInventory(season: SeasonCode): Promise<InventoryAudit> {
  const dcInventory = await fetchAllDCInventory()
  const seasonalItems = dcInventory.filter(item => item.seasonCode === season)
  const expirationDates = await checkExpirationDates(seasonalItems)
  
  return {
    totalUnits: seasonalItems.reduce((sum, item) => sum + item.quantity, 0),
    totalValue: seasonalItems.reduce((sum, item) => sum + item.value, 0),
    expiringItems: expirationDates.filter(item => item.daysToExpiry < 90),
    markdownCandidates: identifyMarkdownCandidates(seasonalItems)
  }
}

async function createDepletionStrategy(audit: InventoryAudit): Promise<DepletionPlan> {
  const markdownSchedule = await optimizeMarkdownTiming(audit.markdownCandidates)
  const promotionalOpportunities = await identifyPromoOpportunities(audit.expiringItems)
  const transferOptions = await findTransferOpportunities(audit.totalUnits)
  
  return {
    markdowns: markdownSchedule,
    promotions: promotionalOpportunities,
    transfers: transferOptions,
    timeline: generateDepletionTimeline(markdownSchedule, promotionalOpportunities)
  }
}

// Decision-Making Workflows
export async function evaluateNewItemIntroduction(newItem: NewItemProposal): Promise<IntroductionDecision> {
  try {
    const marketAnalysis = await analyzeMarketOpportunity(newItem)
    const cannibalAnalysis = await assessCannibalizationRisk(newItem)
    const supplierTerms = await evaluateSupplierTerms(newItem)
    const retailerFit = await assessRetailerFit(newItem)
    return await makeIntroductionDecision(marketAnalysis, cannibalAnalysis, supplierTerms, retailerFit)
  } catch (error) {
    throw new Error(`New item evaluation failed: ${error.message}`)
  }
}

async function analyzeMarketOpportunity(newItem: NewItemProposal): Promise<MarketAnalysis> {
  const categoryTrends = await getCategoryTrends(newItem.category)
  const competitorAnalysis = await analyzeCompetitors(newItem)
  const consumerInsights = await getConsumerInsights(newItem.targetDemographic)
  
  return {
    marketSize: calculateMarketSize(categoryTrends),
    growthProjection: projectGrowth(categoryTrends, consumerInsights),
    competitivePosition: assessCompetitivePosition(competitorAnalysis),
    riskFactors: identifyRiskFactors(categoryTrends, competitorAnalysis)
  }
}

async function assessCannibalizationRisk(newItem: NewItemProposal): Promise<CannibalizationAnalysis> {
  const existingSKUs = await getExistingSKUs(newItem.category)
  const similarProducts = identifySimilarProducts(newItem, existingSKUs)
  const elasticityData = await getElasticityData(similarProducts)
  
  const cannibalizationModel = await loadCannibalizationModel()
  const prediction = await cannibalizationModel.predict({
    newItem: newItem,
    existingProducts: similarProducts,
    elasticity: elasticityData
  })
  
  return {
    riskLevel: prediction.riskScore,
    affectedSKUs: prediction.impactedProducts,
    netIncrementalSales: prediction.incrementalProjection,
    mitigation: generateMitigationStrategies(prediction)
  }
}

export async function optimizePromotionalCalendar(calendar: PromotionalCalendar): Promise<OptimizedCalendar> {
  try {
    const historicalPerformance = await analyzeHistoricalPromos(calendar.category)
    const competitorActivity = await trackCompetitorPromos(calendar.timeframe)
    const inventoryConstraints = await getInventoryConstraints(calendar.timeframe)
    const optimization = await optimizePromoTiming(historicalPerformance, competitorActivity, inventoryConstraints)
    return await finalizePromotionalPlan(optimization)
  } catch (error) {
    throw new Error(`Promotional optimization failed: ${error.message}`)
  }
}

// Compliance and Audit Workflows
export async function conductComplianceAudit(audit: ComplianceAuditRequest): Promise<ComplianceReport> {
  try {
    const storeVisits = await scheduleStoreVisits(audit.storeList)
    const auditResults = await executeStoreAudits(storeVisits)
    const analysis = await analyzeComplianceGaps(auditResults)
    const actionPlan = await createComplianceActionPlan(analysis)
    return await generateComplianceReport(auditResults, analysis, actionPlan)
  } catch (error) {
    throw new Error(`Compliance audit failed: ${error.message}`)
  }
}

async function executeStoreAudits(visits: StoreVisit[]): Promise<AuditResult[]> {
  const auditResults = []
  
  for (const visit of visits) {
    const planogramCompliance = await checkPlanogramCompliance(visit.storeId)
    const facingAccuracy = await verifyFacingAccuracy(visit.storeId)
    const outOfStocks = await identifyOutOfStocks(visit.storeId)
    const shelfCondition = await assessShelfCondition(visit.storeId)
    
    auditResults.push({
      storeId: visit.storeId,
      compliance: planogramCompliance,
      facings: facingAccuracy,
      availability: outOfStocks,
      condition: shelfCondition,
      overallScore: calculateComplianceScore(planogramCompliance, facingAccuracy, outOfStocks, shelfCondition)
    })
  }
  
  return auditResults
}

// Integration and Data Management Workflows
export async function synchronizeDataSources(integration: DataIntegrationRequest): Promise<SyncResult> {
  try {
    const erpData = await extractERPData(integration.erpConnection)
    const syndicatedData = await fetchSyndicatedData(integration.dataProvider)
    const posData = await collectPOSData(integration.retailerConnections)
    const reconciliation = await reconcileDataSources(erpData, syndicatedData, posData)
    return await updateDataWarehouse(reconciliation)
  } catch (error) {
    throw new Error(`Data synchronization failed: ${error.message}`)
  }
}

async function reconcileDataSources(erp: ERPData, syndicated: SyndicatedData, pos: POSData): Promise<ReconciledData> {
  const skuMapping = await createSKUMapping(erp.products, syndicated.products, pos.products)
  const inventoryReconciliation = await reconcileInventory(erp.inventory, pos.sales)
  const salesReconciliation = await reconcileSales(syndicated.sales, pos.sales)
  
  return {
    masterSKUList: skuMapping.masterList,
    reconciledInventory: inventoryReconciliation,
    reconciledSales: salesReconciliation,
    dataQualityScore: calculateDataQuality(skuMapping, inventoryReconciliation, salesReconciliation)
  }
}

// Performance Monitoring and Optimization
export async function monitorPerformanceMetrics(monitoring: PerformanceMonitoringRequest): Promise<PerformanceReport> {
  try {
    const kpiData = await collectKPIData(monitoring.timeframe)
    const benchmarks = await fetchBenchmarks(monitoring.category)
    const analysis = await analyzePerformance(kpiData, benchmarks)
    const recommendations = await generateRecommendations(analysis)
    return await createPerformanceReport(kpiData, analysis, recommendations)
  } catch (error) {
    throw new Error(`Performance monitoring failed: ${error.message}`)
  }
}

async function analyzePerformance(kpis: KPIData, benchmarks: BenchmarkData): Promise<PerformanceAnalysis> {
  const variance = calculateVarianceFromBenchmarks(kpis, benchmarks)
  const trends = identifyTrends(kpis.historical)
  const outliers = detectOutliers(kpis.current)
  const rootCauses = await identifyRootCauses(variance, trends, outliers)
  
  return {
    performanceGaps: variance.significantGaps,
    trendAnalysis: trends,
    anomalies: outliers,
    rootCauseAnalysis: rootCauses,
    improvementOpportunities: identifyImprovementOpportunities(variance, trends)
  }
}
```

## Workflow Integration Points

The SweetShelfIQ business workflows integrate with multiple external systems and data sources:

- **ERP/OMS Systems**: Real-time inventory data, order management, supplier information
- **Syndicated Data Providers**: NIQ/Circana market data, velocity trends, competitive intelligence
- **Retailer POS Systems**: Sales data, inventory turns, promotional performance
- **Space Planning Tools**: JDA/Blue Yonder, NIQ Spaceman, DotActiv integration
- **Manufacturer Systems**: Promotional calendars, new item information, trade funding
- **Compliance Partners**: Photo audit services, mobile compliance applications

These workflows represent the core business processes that enable SweetShelfIQ to deliver AI-driven assortment optimization and planogram generation for confectionery wholesalers, reducing proposal time from weeks to minutes while improving retailer acceptance rates and sales performance.
