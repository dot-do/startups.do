---
name: SheetWise Optimizer
slug: sheetwise
naics:
  primary: '322219'
  occupations: []
service:
  title: Sheet Utilization & Ganging Optimizer
  description: >-
    Optimizes imposition/ganging across open jobs on same stock to reduce waste
    and make-readies.
  targetUsers:
    - Planners
    - Prepress
    - Operations
  triggers:
    - Batch planning run
    - New job intake
    - Stock change notice
  inputs:
    - Open orders with due dates
    - Dielines per SKU
    - Available sheet sizes/stock
    - Press/finisher constraints
    - Changeover matrix
  steps:
    - Sync open jobs from ERP/MES
    - Cluster by substrate/ink/finishing compatibility
    - Run true-shape nesting/imposition; compute yield and changeover tradeoffs
    - Propose ganged layouts and run sizes; simulate due-date adherence
    - Export layout files (JDF/PDF/CAD) to prepress
    - 'Generate KPI report (yield%, makereadies avoided)'
  tools:
    - Tilia Phoenix API or Esko Automation Engine
    - SVGNest for true-shape
    - OR-Tools for sequencing
    - ERP/MES connectors
    - JDF/PDF generators
  outputs:
    - Optimized ganging plan
    - Layout files for prepress/CAM
    - Yield and time savings report
  pricingModel:
    - Monthly SaaS
    - 'Per planning run (e.g., $50–$200)'
  humanInLoop: true
  feasibility:
    remoteOnLaptop: 7
    modelCapability: 7
    overall: 7
  risks:
    - Press/feeder constraints not fully modeled
    - Operator acceptance of ganged runs
    - CAD fidelity for true-shape
  dependencies:
    - Access to dielines and press constraints
    - ERP/MES job data
    - Prepress workflow integration
leanCanvas:
  problem:
    - >-
      Substrate waste from suboptimal imposition/ganging is typically 1–4% above
      theoretical minimum, eroding gross margins on commodity
      cartons/containers.
    - >-
      High make-ready time (20–45 minutes/job on sheetfed presses; 10–25
      minutes/tooling on die cutters) caused by avoidable plate/die changeovers
      and poor batch sequencing.
    - >-
      Schedulers and prepress teams lack a single tool to automatically find
      cross-job ganging opportunities across open orders on the same stock,
      caliper, grain direction, and color set.
    - >-
      Existing imposition tools work job-by-job and ignore plant constraints
      (press width, die availability, gluer windows, WIP buffers, delivery due
      dates/penalties).
    - >-
      Frequent short runs and SKU proliferation increase setups and paperboard
      scrap, overwhelming manual planners and tribal-knowledge heuristics.
    - >-
      Disconnected data across MIS/ERP, prepress, and shop-floor systems
      prevents dynamic optimization based on real availability and priorities.
    - >-
      Inefficient use of common dies and legacy die libraries increases tooling
      costs and time-to-press.
    - >-
      Volatile board lead times and costs require better stock utilization and
      proactive consolidation to hit OTD and margin targets.
  solution:
    - >-
      AI optimization engine that proposes gang layouts across all open orders
      sharing stock/caliper/grain/ink set, maximizing sheet utilization and
      minimizing changeovers.
    - >-
      Constraint-aware scheduling that sequences press and die-cutter runs to
      minimize wash-ups, plate/die changes, and gluer setups while respecting
      due dates and WIP buffers.
    - >-
      Die library intelligence that recommends reuse of existing dies and
      highlights ROI for new combo dies when savings exceed a configurable
      threshold.
    - >-
      What-if simulator for planners to test scenarios (e.g., “hold Job X 24
      hours to gang with Jobs Y/Z”) with instant impact on waste, make-ready,
      and OTD risk.
    - >-
      Automated imposition export to prepress (Esko, Prinect, Preps) with press
      marks, grain alignment, nicks, and chase sizes respected.
    - >-
      Live data integration with MIS/ERP for orders, due dates, routings, stock
      availability; and optional machine data (IoT) for actual speeds and
      downtime.
    - >-
      Inventory-sensitive optimization that prioritizes jobs to deplete aging
      stock and reduce partial pallets/odd lots.
    - >-
      Sustainability analytics reporting CO2e and fiber savings tied to
      optimizer decisions for customer scorecards.
    - >-
      Operator-friendly approval workflow: planner reviews recommended gangs,
      accepts/edits, logs reasons for overrides for continuous learning.
    - >-
      Performance dashboards highlighting realized vs. projected savings,
      acceptance rates, and bottlenecks.
  uniqueValueProp: >-
    Reduce paperboard waste by 1–3% and make-ready time by 10–25% by
    automatically ganging compatible SKUs across open jobs on the same stock and
    tooling, using an AI-driven optimizer that accounts for real plant
    constraints and integrates with your MIS and prepress. Typical payback < 6
    months.
  unfairAdvantage: >-
    A constraint-aware optimization engine trained on real plant data and
    enriched by die-library intelligence, combined with turnkey integrations to
    MIS/prepress and a pilot-to-ROI motion that quantifies savings. Anonymized
    benchmarks create a data network effect competitors without cross-customer
    insights cannot easily replicate.
  customerSegments:
    - >-
      Mid-market paperboard container manufacturers (NAICS 322219) with 2–8
      sheetfed offset or flexo presses and in-house die cutting/folding-gluing.
    - >-
      Multi-plant enterprises seeking cross-plant scheduling and stock pooling
      for regional optimization.
    - 'Operations/plant managers measured on OEE, waste, and on-time delivery.'
    - >-
      Production planners and prepress managers responsible for imposition, die
      reuse, and job batching.
    - CFO/VP Operations focused on material cost reduction and throughput gains.
    - >-
      Contract packaging firms that outsource printing/die cutting but control
      scheduling and stock.
    - >-
      Converters with frequent short runs, private-label work, and high SKU
      churn on common stocks.
  channels:
    - >-
      Direct sales to plant and operations leaders via targeted ABM of NAICS
      322219 firms with 2–8 presses and $10–200M revenue.
    - >-
      Alliances with MIS/ERP and prepress vendors/integrators to co-sell and
      embed connectors; referral fees and co-marketing.
    - >-
      Industry associations and events: AICC, TAPPI, Paperboard Packaging
      Council (PPC), PACK EXPO; speaking slots and live optimization demos.
    - >-
      Content-led growth: ROI calculators, whitepapers on ganging economics,
      case studies showing sheet savings and setup reduction.
    - >-
      Pilot-led motion: 8–12 week paid pilots with clear success criteria and
      executive sponsor alignment.
    - >-
      Outbound to private-equity-backed platforms consolidating converters; sell
      multi-plant rollouts.
    - >-
      Customer advisory board and community webinars to drive referrals and
      expansion.
  revenueStreams:
    - >-
      SaaS subscription tiered by number of presses/lines and users (e.g.,
      $30k–$90k ARR per plant).
    - >-
      Optional consumption-based pricing for optimization runs beyond included
      quota.
    - >-
      One-time implementation/integration fees ($15k–$75k per plant depending on
      systems).
    - >-
      Performance-based upside: optional 10–20% share-of-verified savings during
      first 6–12 months.
    - Premium support/SLAs and training packages.
    - >-
      Enterprise add-ons: multi-plant optimization, advanced scheduling,
      benchmarking module.
  costStructure:
    - 'R&D and product engineering (solver, integrations, UI/UX).'
    - >-
      Cloud infrastructure (compute for solver, storage, monitoring)
      $1k–$5k/month/base plant depending on usage.
    - Integration/professional services delivery team.
    - 'Sales and marketing (ABM tools, events, content).'
    - Partner enablement and referral commissions (10–20%).
    - Customer success and support.
    - 'Security/compliance (SOC 2, pen tests, insurance).'
    - Data acquisition/labeling for die library normalization and model tuning.
  keyMetrics:
    - >-
      Material waste reduction vs. historical baseline (target: 1.5–3.0%
      absolute reduction on eligible jobs).
    - >-
      Make-ready minutes per job (target: 10–25% reduction on presses and die
      cutters).
    - >-
      Percentage of eligible jobs optimized/ganged (target: >70% within 90 days
      of go-live).
    - 'Planner acceptance rate of AI recommendations (target: >75%).'
    - >-
      Net monthly savings realized (board cost + make-ready labor/overhead) vs.
      subscription cost (target: 5–10x ROI).
    - >-
      Solver runtime and plan freshness (P95 < 120 seconds; daily
      re-optimization by default).
    - >-
      On-time delivery improvement (target: +2–5 percentage points) with no
      quality escapes.
    - 'Throughput/OEE lift on critical assets (target: +3–7%).'
    - >-
      Implementation time-to-value (first savings within 30 days; full rollout
      8–12 weeks).
    - Churn (<8% logo churn) and NPS (>40) after 12 months.
storyBrand:
  character: >-
    Plant managers, schedulers, and prepress leads at paperboard container
    manufacturers (NAICS 322219) who must keep presses full, waste low, and
    orders on time.
  problem: >-
    External: Suboptimal ganging and imposition across open jobs on the same
    stock drives sheet waste, make‑readies, and changeovers. Internal: It’s hard
    to see the best plan across a live queue, dies, coatings, and due windows—so
    teams feel like they’re leaving money on the floor. Philosophical: You
    shouldn’t have to waste board and hours because the optimal plan is
    invisible.
  guide: >-
    We understand mixed SKUs, die libraries, coatings, calipers, grain, and
    tight windows. Our AI optimizer is built by print-tech engineers, integrates
    with MIS/ERP and prepress, and provides auditable recommendations your team
    can trust.
  plan: >-
    1) Connect: Sync open jobs, stock specs, die library, and constraints from
    your MIS/ERP and prepress. 2) Pilot: Run on one press/stock family; compare
    utilization and make‑readies; tune rules. 3) Go live: Push daily gang plans
    and press forms, with savings estimates and KPI tracking—your team approves
    before release.
  callToAction: >-
    Direct: Schedule a 30‑minute fit assessment. Transitional: Request a free
    sample optimization using this week’s jobs.
  success: >-
    Higher sheet utilization, fewer make‑readies and wash‑ups, steadier
    schedules, lower board and energy use, improved margins, stronger on‑time
    performance, happier customers, and defensible sustainability metrics.
  failure: >-
    Continued board waste, excessive changeovers and overtime, missed ship
    windows, rushed freight, margin erosion, and a stressed production team.
landingPage:
  hero:
    title: AI Sheet Utilization & Ganging Optimizer
    subtitle: >-
      Auto-gang open jobs on the same stock to cut waste and make-ready for
      Other Paperboard Container Manufacturing (NAICS 322219).
    ctaText: Book a demo
    ctaHref: /demo
  problem:
    - Underfilled sheets and oversized gutters drive scrap and cost.
    - Frequent changeovers inflate make-ready time and sheets.
    - Ganging opportunities across same-stock jobs are missed.
    - Manual imposition ties up prepress and delays schedules.
    - 'ERP/MIS shows orders, not optimal ganged layouts.'
    - Inconsistent gripper/side guide rules cause rework.
    - 'Press, die-cut, and finishing constraints conflict in planning.'
  solution:
    - 'AI groups open jobs by stock, caliper, colors, and due dates.'
    - Builds constraint-aware ganged impositions for press and die-cut.
    - 'Minimizes waste, make-ready, and plate/die changes simultaneously.'
    - Runs what-if scenarios to balance yield with due-date risk.
    - Exports imposition PDFs and CAD files (CF2/DXF/ARD) plus JDF/JMF.
    - Syncs with MIS/ERP and inventory for live data.
    - 'Tracks savings per run, line, and customer.'
  features:
    - 'Constraint-aware ganging across print, die-cut, fold/glue.'
    - Supports sheet-fed offset and digital carton workflows.
    - 'Rules for gripper, side guide, bleed, gutters, nicks, tie points.'
    - 'Rotation limits by grain direction, caliper, and coating.'
    - Color/ink change and washup cost modeling.
    - Food-contact vs non-food keep-out rules.
    - Die library matching and die reuse recommendations.
    - Variable repeat and step-and-repeat nesting.
    - Auto sheet size selection from stock catalog.
    - 'MOQ, overrun, and spoilage controls.'
    - 'KPIs: yield/sheet, scrap %, make-ready sheets, runtime.'
    - What-if planner with due date and overtime constraints.
    - 'One-click export: PDF imposition, CF2/DXF/ARD, cut lists.'
    - APIs and connectors for leading MIS and prepress systems.
    - On-prem or private cloud; SSO and role-based access.
    - Audit trail with versioning and rollback.
    - Operator review UI with drag-and-drop swaps.
    - 'Multi-plant, multi-press scheduling and load balancing.'
  steps:
    - 'Connect MIS/ERP, prepress, and inventory.'
    - 'Select stock, caliper, and target press/die line.'
    - Import open jobs and plant constraints automatically.
    - Click Optimize to generate ganged layouts.
    - 'Review KPIs; tweak rotations, gutters, or job mix as needed.'
    - Approve and export to prepress/pressroom systems.
    - Run production and track actuals and savings.
---

# SheetWise Optimizer

Generated for NAICS 322219 — Other Paperboard Container Manufacturing.
Service: Sheet Utilization & Ganging Optimizer

## Business Process Functions

```typescript
// Core data types for Sheetwise business processes
interface Lead {
  id: string;
  company: string;
  naicsCode: string;
  pressCount: number;
  annualRevenue: number;
  contactInfo: ContactInfo;
  painPoints: string[];
  currentWastePercentage?: number;
  makeReadyTime?: number;
}

interface Customer {
  id: string;
  company: string;
  contractValue: number;
  implementationStatus: 'pilot' | 'rollout' | 'live';
  plants: Plant[];
  subscriptionTier: 'basic' | 'premium' | 'enterprise';
}

interface Plant {
  id: string;
  location: string;
  pressCount: number;
  misSystem: string;
  prepressSystem: string;
  monthlyVolume: number;
}

interface OptimizationJob {
  id: string;
  plantId: string;
  openOrders: Order[];
  constraints: PlantConstraints;
  targetMetrics: TargetMetrics;
  status: 'queued' | 'running' | 'completed' | 'failed';
}

interface Order {
  id: string;
  sku: string;
  quantity: number;
  dueDate: Date;
  stock: StockSpec;
  dieline: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
}

interface GangingPlan {
  id: string;
  orders: Order[];
  sheetUtilization: number;
  estimatedWasteSavings: number;
  makeReadyReduction: number;
  layoutFile: string;
  approvalStatus: 'pending' | 'approved' | 'rejected';
}

// Customer Acquisition Workflows
export async function acquireCustomer(lead: Lead): Promise<Customer> {
  try {
    const qualifiedLead = await qualifyLead(lead);
    const proposal = await generateProposal(qualifiedLead);
    const pilot = await conductPilot(proposal);
    const contract = await negotiateContract(pilot);
    return await onboardCustomer(contract);
  } catch (error) {
    throw new Error(`Customer acquisition failed: ${error.message}`);
  }
}

export async function qualifyLead(lead: Lead): Promise<Lead> {
  if (lead.naicsCode !== '322219') {
    throw new Error('Lead not in target NAICS code 322219');
  }
  
  if (lead.pressCount < 2 || lead.pressCount > 8) {
    throw new Error('Press count outside target range (2-8 presses)');
  }
  
  if (lead.annualRevenue < 10_000_000 || lead.annualRevenue > 200_000_000) {
    throw new Error('Revenue outside target range ($10M-$200M)');
  }
  
  const wasteAssessment = await assessCurrentWaste(lead);
  const roiPotential = await calculateROIPotential(lead, wasteAssessment);
  
  if (roiPotential.paybackMonths > 12) {
    throw new Error('ROI potential does not meet 12-month payback criteria');
  }
  
  return {
    ...lead,
    currentWastePercentage: wasteAssessment.wastePercentage,
    makeReadyTime: wasteAssessment.avgMakeReadyTime
  };
}

export async function generateProposal(lead: Lead): Promise<Proposal> {
  const baselineMetrics = await analyzeBaseline(lead);
  const projectedSavings = await calculateProjectedSavings(baselineMetrics);
  const pricingTier = await determinePricingTier(lead);
  
  return {
    leadId: lead.id,
    baselineWaste: baselineMetrics.wastePercentage,
    projectedWasteReduction: projectedSavings.wasteReduction,
    projectedMakeReadyReduction: projectedSavings.makeReadyReduction,
    annualSavings: projectedSavings.annualSavings,
    subscriptionCost: pricingTier.annualCost,
    roi: projectedSavings.annualSavings / pricingTier.annualCost,
    paybackMonths: (pricingTier.annualCost / projectedSavings.annualSavings) * 12,
    implementationFee: pricingTier.implementationFee
  };
}

export async function conductPilot(proposal: Proposal): Promise<PilotResults> {
  const pilotPlan = await createPilotPlan(proposal);
  const dataIntegration = await setupDataIntegration(pilotPlan);
  const optimizationRuns = await runPilotOptimizations(pilotPlan, dataIntegration);
  const results = await measurePilotResults(optimizationRuns);
  
  if (results.wasteReduction < 1.0 || results.makeReadyReduction < 10) {
    throw new Error('Pilot results below minimum thresholds');
  }
  
  return results;
}

// Product Development Processes
export async function developOptimizationEngine(): Promise<void> {
  await enhanceGangingAlgorithm();
  await improveConstraintModeling();
  await optimizePerformance();
  await validateAccuracy();
}

export async function enhanceGangingAlgorithm(): Promise<void> {
  const trainingData = await collectGangingData();
  const model = await trainOptimizationModel(trainingData);
  const validation = await validateModel(model);
  
  if (validation.accuracy < 0.85) {
    throw new Error('Model accuracy below threshold');
  }
  
  await deployModel(model);
}

export async function integrateWithMISSystem(customer: Customer, misType: string): Promise<Integration> {
  const connector = await buildMISConnector(misType);
  const dataMapping = await mapDataFields(customer, connector);
  const testConnection = await testIntegration(connector, dataMapping);
  
  if (!testConnection.success) {
    throw new Error(`MIS integration failed: ${testConnection.error}`);
  }
  
  return await activateIntegration(connector, dataMapping);
}

// Revenue Generation Flows
export async function generateRevenue(customer: Customer): Promise<RevenueMetrics> {
  const subscriptionRevenue = await processSubscriptionBilling(customer);
  const usageRevenue = await processUsageBilling(customer);
  const servicesRevenue = await processServicesRevenue(customer);
  
  return {
    subscriptionRevenue,
    usageRevenue,
    servicesRevenue,
    totalRevenue: subscriptionRevenue + usageRevenue + servicesRevenue,
    month: new Date().getMonth() + 1,
    year: new Date().getFullYear()
  };
}

export async function processSubscriptionBilling(customer: Customer): Promise<number> {
  const tierPricing = await getTierPricing(customer.subscriptionTier);
  const plantCount = customer.plants.length;
  const monthlyAmount = tierPricing.basePrice + (tierPricing.perPlantPrice * plantCount);
  
  await generateInvoice(customer, monthlyAmount, 'subscription');
  return monthlyAmount;
}

export async function expandCustomerAccount(customer: Customer): Promise<Customer> {
  const expansionOpportunities = await identifyExpansionOpportunities(customer);
  const proposal = await createExpansionProposal(expansionOpportunities);
  const approval = await getExpansionApproval(customer, proposal);
  
  if (approval.approved) {
    return await implementExpansion(customer, approval.expandedServices);
  }
  
  return customer;
}

// Operational Procedures
export async function executeOptimizationWorkflow(job: OptimizationJob): Promise<GangingPlan> {
  try {
    const validatedJob = await validateOptimizationJob(job);
    const clusteredOrders = await clusterOrdersByCompatibility(validatedJob.openOrders);
    const gangingOptions = await generateGangingOptions(clusteredOrders, validatedJob.constraints);
    const optimizedPlan = await selectOptimalGanging(gangingOptions, validatedJob.targetMetrics);
    const layoutFiles = await generateLayoutFiles(optimizedPlan);
    
    return {
      ...optimizedPlan,
      layoutFile: layoutFiles.impositionPDF,
      approvalStatus: 'pending'
    };
  } catch (error) {
    await logOptimizationError(job.id, error);
    throw new Error(`Optimization workflow failed: ${error.message}`);
  }
}

export async function clusterOrdersByCompatibility(orders: Order[]): Promise<OrderCluster[]> {
  const clusters: OrderCluster[] = [];
  
  for (const order of orders) {
    const compatibleCluster = clusters.find(cluster => 
      isCompatible(order, cluster.stock, cluster.constraints)
    );
    
    if (compatibleCluster) {
      compatibleCluster.orders.push(order);
    } else {
      clusters.push({
        id: generateClusterId(),
        orders: [order],
        stock: order.stock,
        constraints: await deriveConstraints(order)
      });
    }
  }
  
  return clusters;
}

export async function generateGangingOptions(clusters: OrderCluster[], constraints: PlantConstraints): Promise<GangingOption[]> {
  const options: GangingOption[] = [];
  
  for (const cluster of clusters) {
    if (cluster.orders.length > 1) {
      const nestingResults = await runNestingAlgorithm(cluster.orders, constraints);
      const utilizationMetrics = await calculateUtilization(nestingResults);
      
      options.push({
        clusterId: cluster.id,
        orders: cluster.orders,
        layout: nestingResults.layout,
        sheetUtilization: utilizationMetrics.utilization,
        wasteReduction: utilizationMetrics.wasteReduction,
        makeReadyReduction: utilizationMetrics.makeReadyReduction
      });
    }
  }
  
  return options.sort((a, b) => b.wasteReduction - a.wasteReduction);
}

// Decision-Making Workflows
export async function approveGangingPlan(plan: GangingPlan, approver: User): Promise<GangingPlan> {
  const riskAssessment = await assessPlanRisk(plan);
  const impactAnalysis = await analyzeDeliveryImpact(plan);
  
  if (riskAssessment.riskLevel === 'high' && !approver.canApproveHighRisk) {
    throw new Error('High-risk plan requires senior approver');
  }
  
  if (impactAnalysis.onTimeDeliveryRisk > 0.1) {
    const confirmation = await requestRiskConfirmation(approver, impactAnalysis);
    if (!confirmation.approved) {
      return { ...plan, approvalStatus: 'rejected' };
    }
  }
  
  await logApprovalDecision(plan.id, approver.id, 'approved');
  return { ...plan, approvalStatus: 'approved' };
}

export async function handleCustomerChurn(customer: Customer, churnReason: string): Promise<ChurnResult> {
  const retentionStrategy = await determineRetentionStrategy(customer, churnReason);
  const retentionOffer = await createRetentionOffer(retentionStrategy);
  const customerResponse = await presentRetentionOffer(customer, retentionOffer);
  
  if (customerResponse.accepted) {
    const updatedCustomer = await implementRetentionOffer(customer, retentionOffer);
    return { retained: true, customer: updatedCustomer };
  } else {
    await processChurn(customer);
    return { retained: false, churnDate: new Date() };
  }
}

export async function optimizeResourceAllocation(): Promise<ResourcePlan> {
  const customerDemand = await forecastCustomerDemand();
  const currentCapacity = await assessCurrentCapacity();
  const gaps = await identifyCapacityGaps(customerDemand, currentCapacity);
  
  return await createResourcePlan(gaps);
}

// Performance Monitoring and Continuous Improvement
export async function monitorSystemPerformance(): Promise<PerformanceMetrics> {
  const optimizationMetrics = await collectOptimizationMetrics();
  const customerSatisfactionMetrics = await collectCustomerMetrics();
  const systemHealthMetrics = await collectSystemHealthMetrics();
  
  return {
    avgOptimizationTime: optimizationMetrics.avgTime,
    avgWasteReduction: optimizationMetrics.avgWasteReduction,
    customerNPS: customerSatisfactionMetrics.nps,
    systemUptime: systemHealthMetrics.uptime,
    errorRate: systemHealthMetrics.errorRate
  };
}

export async function implementContinuousImprovement(): Promise<void> {
  const performanceData = await monitorSystemPerformance();
  const improvementOpportunities = await identifyImprovementOpportunities(performanceData);
  
  for (const opportunity of improvementOpportunities) {
    if (opportunity.impact === 'high' && opportunity.effort === 'low') {
      await implementImprovement(opportunity);
    }
  }
}
```
