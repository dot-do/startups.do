---
name: PeakMold AI
slug: peakmold
naics:
  primary: '326191'
  occupations: []
service:
  title: Energy-Optimized Press/Machine Scheduling
  description: >-
    Schedules molding/extrusion jobs to minimize energy cost while meeting due
    dates and constraints.
  targetUsers:
    - Operations Manager
    - Energy Manager
    - Plant Manager
  triggers:
    - 'Day-ahead schedule run (e.g., 16:00)'
    - Utility tariff change or DR event
    - New urgent order
  inputs:
    - Job queue with due dates/quantities
    - Machine cycle times by SKU/mold
    - Changeover/downtime windows
    - 'Utility tariff (TOU, demand charges)'
    - Historical kW/kWh by machine
  steps:
    - Pull job and machine data from ERP/MES
    - Load utility tariff and expected baseline
    - Optimize sequence/starts to flatten peaks (OR-Tools)
    - Estimate kWh and demand charges vs baseline
    - Publish schedule and on/off recommendations
    - Track actual vs plan for continuous improvement
  tools:
    - OR-Tools/Pyomo
    - UtilityAPI/Green Button for tariff/meter data
    - 'Python (pandas, numpy)'
    - Google Sheets/Excel Online
    - Power BI dashboard
  outputs:
    - Daily machine schedule with timestamps
    - Projected energy cost and demand peak
    - Deviation/exception report
  pricingModel:
    - Setup + monthly
    - Optional performance fee on verified energy savings
  humanInLoop: true
  feasibility:
    remoteOnLaptop: 4.5
    modelCapability: 4.3
    overall: 4.4
  risks:
    - Incomplete or inaccurate cycle time data
    - Operator adherence to schedule
    - Tariff complexity across sites
  dependencies:
    - MES/ERP job data
    - Tariff/meter data access
    - Agreement on scheduling rules/constraints
leanCanvas:
  problem:
    - >-
      Electricity is 5–15% of conversion costs for plastics processing, and
      demand charges can be 30–60% of the electric bill; manual schedules often
      create avoidable peaks.
    - >-
      Schedulers optimize for due dates and utilization, not real-time tariffs
      or demand charges; TOU and RTP price signals are rarely embedded in
      dispatch decisions.
    - >-
      Machine constraints (mold changeovers, color contamination, dryer
      availability, cure/heat-up times, qualified labor) make energy-aware
      scheduling complex and error-prone.
    - >-
      Uncoordinated start-ups (presses, extruders, dryers, chillers) produce
      short, expensive demand spikes that lock in high demand charges for the
      month.
    - >-
      Limited visibility of true cost-to-serve per job (kWh/unit, $/unit)
      prevents margin-based prioritization.
    - >-
      Existing ERP/MES APS modules are not energy-aware; plants resort to
      spreadsheets and tribal knowledge leading to missed due dates or higher
      scrap when attempting load shifting.
    - >-
      Inability to reliably participate in utility demand response or peak
      shaving without risking OTD or quality.
  solution:
    - >-
      AI-driven APS that co-optimizes due dates, changeovers, labor, and machine
      constraints with tariffs, demand charges, and DR events.
    - >-
      Digital twin of the shop floor (machines, molds, dryers, utilities, labor
      pools) and a constraint-based optimizer that runs continuously and
      re-plans as conditions change.
    - >-
      Tariff-aware dispatching: automatically staggers high-draw equipment
      during peak windows; pre-heats/pre-dries outside peak; sequences
      color/mold families to minimize changeover and scrap.
    - >-
      Peak shaving: monitors real-time kW, predicts 15–60 min ahead, and adjusts
      starts/pauses to avoid crossing demand thresholds.
    - >-
      What-if simulation: planners compare delivery, energy cost, and OEE across
      alternative schedules before committing.
    - >-
      MES/ERP integration (Epicor/DELMIAWorks, Infor, SAP, Plex, etc.) plus
      OPC-UA/Kepware connectors to machine PLCs for status, load, and energy
      proxies.
    - >-
      Automated reporting of kWh/unit and $/order for margin analytics and
      sustainability disclosures (Scope 2).
  uniqueValueProp: >-
    Reduce electricity cost 8–15% and monthly peak demand 10–25% while
    maintaining ≥95% on-time delivery by making your press/machine schedule
    energy-aware—no new hardware, ROI in 3–6 months.
  unfairAdvantage: >-
    A plastics-specific, energy-aware APS with pre-built color/changeover
    templates, tariff and demand-charge modeling, and connectors to common
    plastics ERPs/MES—validated by plant-level case studies and a growing
    cross-plant dataset that improves peak prediction and sequencing over time.
  customerSegments:
    - >-
      US and Canada plastics plumbing fixture manufacturers (NAICS 326191) with
      5–50 major machines: injection presses, extrusion lines, thermoformers,
      sheet extruders, large ovens, dryers.
    - >-
      Roles: VP Operations, Plant Manager, Production Planner/Scheduler,
      Energy/Facilities Manager, Continuous Improvement Lead, CFO (cost focus).
    - >-
      Early adopters: multi-shift plants in TOU/RTP markets or with high demand
      charges; multi-site enterprises seeking standardization; facilities with
      frequent changeovers or color changes.
    - >-
      Secondary: Contract manufacturers producing private-label fixtures;
      vertically integrated bath/shower enclosure makers with in-house extrusion
      and thermoforming.
  channels:
    - >-
      Direct sales to VPs of Operations and Plant Managers via account-based
      outreach to top 200 NAICS 326191 firms; cadenced LinkedIn + email with ROI
      calculator.
    - >-
      Utility/energy-efficiency program partnerships to offer subsidized pilots;
      co-marketing with DR aggregators where shared savings is available.
    - >-
      ERP/MES ISV partnerships and system integrator referrals
      (Epicor/DELMIAWorks, Infor, Plex implementers) bundling energy-aware
      scheduling in upgrades.
    - >-
      Industry associations and events: Plastics Industry Association, NPE
      tradeshow, regional manufacturing councils; webinars on demand charges and
      energy-aware APS.
    - >-
      Content marketing: case studies (peak kW reduction, $/unit), technical
      whitepapers, and a self-serve “energy cost of scheduling” calculator.
    - >-
      Pilot-first GTM: 8–12 week paid pilots with savings guarantee; convert to
      annual SaaS on demonstrated KPIs.
    - >-
      Customer success-led land-and-expand: start with one plant, then template
      rollout playbook to sister sites.
  revenueStreams:
    - >-
      SaaS subscription (tiered by machine count): $300–$600 per machine per
      month; volume discounts for >25 machines.
    - >-
      One-time onboarding/integration: $15k–$50k per plant depending on system
      complexity and custom connectors.
    - >-
      Performance-based option: 10–20% of verified first-year energy cost
      savings in lieu of part of subscription for pilots.
    - >-
      Premium support/SLA and advanced analytics add-on: $2k–$5k per plant per
      year.
    - >-
      Enterprise license for multi-site deployments with centralized
      optimization: negotiated annual fee.
    - >-
      Optional DR revenue share: fee as a percentage of incremental DR proceeds
      attributable to optimized curtailment.
  costStructure:
    - >-
      R&D: optimization/ML engineers, tariff modeling, UI; ongoing model
      improvements.
    - >-
      Cloud infrastructure: compute for optimization, databases, monitoring;
      estimated $50–$200 per machine per year at scale.
    - >-
      Data integration: building and maintaining ERP/MES and OPC connectors;
      certifications.
    - >-
      Sales and marketing: ABM tooling, events, collateral; partner commissions
      (10–20%).
    - >-
      Customer success/onboarding: solution architects, project management,
      training content.
    - 'Security/compliance: SOC 2 audits, pen-testing, cyber insurance.'
    - 'General and administrative: legal (MSAs, DPAs), finance, overhead.'
  keyMetrics:
    - >-
      Energy cost reduction (% vs. normalized baseline): target 8–15% within 90
      days; methodology: weather- and volume-normalized regression vs. prior 3–6
      months.
    - >-
      Peak demand reduction (max kW/mo): target 10–25% reduction; track
      coincident peaks avoided and demand charge savings.
    - >-
      kWh per good unit by product family: target 5–12% reduction from load
      shifting and fewer re-heats/restarts.
    - >-
      On-time delivery rate: maintain or improve to ≥95%; schedule adherence
      ≥85% with defined freeze windows.
    - >-
      Changeover hours per week: reduce by 10–20% through family sequencing;
      track scrap rate delta (target −2 to −4%).
    - >-
      Planner time spent scheduling: reduce by 30–50%; measure time to generate
      a feasible schedule (<10 minutes).
    - >-
      Adoption/automation: % of orders auto-scheduled without manual edits;
      target ≥70% by month 3.
    - >-
      Time-to-value: days from kickoff to first optimized schedule in
      production; target ≤45 days.
    - >-
      Customer economics: verified annual savings per plant ($100k–$500k
      depending on size); payback ≤6 months.
    - >-
      Business metrics: net revenue retention ≥120%, gross margin ≥70%, logo
      churn <8% annually, LTV/CAC >4.
storyBrand:
  character: >-
    Plant/operations manager at a plastics plumbing fixture manufacturer (NAICS
    326191) who must hit due dates, control energy spend, and keep
    presses/extruders utilized without chaos.
  problem: >-
    External: Volatile TOU rates and demand charges plus manual schedules create
    costly peaks, overtime, and missed ship dates. Internal: Constant
    firefighting and limited visibility. Philosophical: Making the same parts
    shouldn’t cost more just because of timing—energy should be planned, not
    endured. Villain: Spiky electricity prices and rigid legacy scheduling.
  guide: >-
    We’re energy-aware scheduling experts for plastics. We understand molds,
    resins, colors, cycle times, tooling limits, and changeovers. Our AI has cut
    energy costs 10–20% while protecting service levels and integrates with
    ERP/MES so you stay in control.
  plan: >-
    1) Connect data: jobs, press/extruder limits, tariffs, maintenance, and
    shifts. 2) Optimize: generate a cost-minimizing schedule that honors due
    dates and constraints; scenario test and approve. 3) Run and refine: publish
    to the floor, track peaks, and adjust in minutes. Pilot in 2 weeks with low
    risk.
  callToAction: >-
    Direct: Book a 30-minute demo or start a 14-day pilot with your real jobs.
    Transitional: Download a case study and use the savings calculator.
  success: >-
    10–20% lower energy spend, fewer demand peaks and penalties, higher on-time
    delivery, smoother shifts and changeovers, reduced scrap and overtime,
    verified CO2 reductions, and stronger margins per part.
  failure: >-
    Overpay for power, trigger demand spikes, scramble schedules, miss due
    dates, burn overtime and resin, and lose margin to competitors using
    energy-optimized scheduling.
landingPage:
  hero:
    title: Energy-Optimized Press & Extrusion Scheduling
    subtitle: >-
      AI that schedules molding/extrusion to hit due dates at the lowest energy
      cost. Built for Plastics Plumbing Fixture Manufacturing (NAICS 326191).
    ctaText: Book a demo
    ctaHref: /book-demo
  problem:
    - >-
      Energy prices and demand charges spike costs on large presses, extruders,
      dryers, and chillers.
    - >-
      Traditional finite-capacity schedules ignore time-of-use tariffs and peak
      windows.
    - Rush orders and frequent mold/color changes waste energy and capacity.
    - >-
      Manual dispatching can’t juggle machine–tooling eligibility, dryer
      capacity, and labor shifts.
    - 'Missed due dates, overtime, and high scrap erode margins and OTIF.'
    - 'No clear view of energy cost or CO2 per job, part, or customer.'
  solution:
    - >-
      Tariff-aware optimization schedules jobs to avoid peaks and leverage
      off-peak rates while meeting due dates.
    - >-
      Co-schedules presses, extruders, dryers, and operators to minimize
      changeovers and idle energy.
    - 'Continuously re-plans as orders, tariffs, or equipment status change.'
    - >-
      What-if simulations for rush orders, tariff updates, and battery/solar
      usage in seconds.
    - Shop-floor-ready dispatch with locks/overrides to protect critical runs.
    - 'Live dashboards for energy cost, savings, and emissions by job and SKU.'
  features:
    - >-
      TOU/RTP tariff-aware finite-capacity scheduling with demand charge
      avoidance.
    - >-
      Peak forecasting and smart load shifting for presses, extruders, dryers,
      chillers, and compressors.
    - >-
      Machine–tooling matrix with cavitation, cycle time, and mold warmup
      modeling.
    - 'Mold/color family sequencing to cut purges, warmups, and scrap.'
    - Dryer/chiller/compressor capacity and resin availability constraints.
    - 'Labor-aware scheduling for shifts, skills, and certifications.'
    - >-
      ERP/MES integrations (SAP, Oracle, Epicor, DELMIAWorks, Plex) and CSV/API
      connectors.
    - >-
      Real-time signals from meters/SCADA; auto-replan for downtime and
      maintenance windows.
    - >-
      On-site solar/battery-aware scheduling; optional battery dispatch to shave
      peaks.
    - >-
      Planner Gantt with energy overlay; mobile dispatch lists for
      supervisors/operators.
    - >-
      Due date, priority, and SLA rules with schedule locks and manual
      overrides.
    - 'Audit logs, traceability, and energy/CO2 reporting per order and customer.'
  steps:
    - 'Connect ERP/MES orders, machine list, tariffs, meters, and calendars.'
    - >-
      Configure constraints: tooling eligibility, changeovers, dryer/chiller
      limits, labor shifts.
    - 'Set objectives: cost vs service; define peak windows and demand limits.'
    - >-
      Run the optimizer; review energy-aware Gantt; approve and publish to the
      floor.
    - >-
      Monitor execution; auto-replan on changes; track savings and OTIF in
      dashboards.
---
# PeakMold AI

Generated for NAICS 326191 — Plastics Plumbing Fixture Manufacturing.
Service: Energy-Optimized Press/Machine Scheduling

## Business Workflow Functions

```typescript
// Core Types
interface Lead {
  id: string;
  company: string;
  contactName: string;
  email: string;
  phone: string;
  naicsCode: string;
  machineCount: number;
  annualEnergySpend: number;
  currentSchedulingMethod: 'manual' | 'erp' | 'spreadsheet';
  painPoints: string[];
  source: 'direct' | 'referral' | 'utility' | 'event';
}

interface QualifiedLead extends Lead {
  fitScore: number;
  estimatedSavings: number;
  decisionMakers: string[];
  timeline: string;
  budget: number;
}

interface Customer {
  id: string;
  lead: QualifiedLead;
  contractValue: number;
  startDate: Date;
  plantLocations: PlantLocation[];
  subscriptionTier: 'basic' | 'premium' | 'enterprise';
}

interface PlantLocation {
  id: string;
  name: string;
  address: string;
  machines: Machine[];
  utilityProvider: string;
  tariffStructure: TariffStructure;
  erpSystem: string;
}

interface Machine {
  id: string;
  type: 'injection_press' | 'extruder' | 'thermoformer' | 'dryer' | 'chiller';
  capacity: number;
  powerRating: number;
  cycleTime: number;
  toolingCompatibility: string[];
}

interface TariffStructure {
  touRates: { period: string; rate: number }[];
  demandCharges: { threshold: number; rate: number }[];
  seasonalVariations: boolean;
}

interface OptimizationResult {
  schedule: ProductionSchedule;
  energyCostReduction: number;
  peakDemandReduction: number;
  onTimeDeliveryRate: number;
  co2Reduction: number;
}

interface ProductionSchedule {
  jobs: ScheduledJob[];
  totalEnergyCost: number;
  peakDemand: number;
  scheduleEfficiency: number;
}

interface ScheduledJob {
  jobId: string;
  machineId: string;
  startTime: Date;
  endTime: Date;
  energyConsumption: number;
  priority: number;
}

// Customer Acquisition Workflows
export async function acquireCustomer(lead: Lead): Promise<Customer> {
  const qualifiedLead = await qualifyLead(lead);
  const roiAnalysis = await calculateROI(qualifiedLead);
  const proposal = await generateProposal(qualifiedLead, roiAnalysis);
  const pilot = await setupPilot(qualifiedLead, proposal);
  const contract = await negotiateContract(pilot);
  return await onboardCustomer(contract);
}

export async function qualifyLead(lead: Lead): Promise<QualifiedLead> {
  // Validate NAICS code (326191 - Plastics Plumbing Fixture Manufacturing)
  if (lead.naicsCode !== '326191') {
    throw new Error('Lead does not match target NAICS code');
  }
  
  // Calculate fit score based on machine count, energy spend, and pain points
  const fitScore = calculateFitScore(lead);
  
  if (fitScore < 7) {
    throw new Error('Lead does not meet minimum qualification criteria');
  }
  
  // Estimate potential savings (8-15% energy cost reduction)
  const estimatedSavings = lead.annualEnergySpend * 0.12; // 12% average
  
  // Identify decision makers and timeline
  const decisionMakers = await identifyDecisionMakers(lead);
  const timeline = await assessPurchaseTimeline(lead);
  const budget = await estimateBudget(lead);
  
  return {
    ...lead,
    fitScore,
    estimatedSavings,
    decisionMakers,
    timeline,
    budget
  };
}

export async function calculateROI(lead: QualifiedLead): Promise<ROIAnalysis> {
  const monthlySubscriptionCost = lead.machineCount * 450; // $300-600 per machine
  const onboardingCost = Math.min(50000, Math.max(15000, lead.machineCount * 1000));
  const annualCost = monthlySubscriptionCost * 12 + onboardingCost;
  
  const paybackPeriod = annualCost / lead.estimatedSavings;
  const threeYearROI = (lead.estimatedSavings * 3 - annualCost * 3) / (annualCost * 3);
  
  return {
    estimatedSavings: lead.estimatedSavings,
    annualCost,
    paybackPeriod,
    threeYearROI,
    breakEvenMonth: Math.ceil(paybackPeriod * 12)
  };
}

export async function setupPilot(lead: QualifiedLead, proposal: Proposal): Promise<PilotProgram> {
  // 8-12 week paid pilot with savings guarantee
  const pilotDuration = 10; // weeks
  const pilotCost = Math.min(25000, lead.machineCount * 500);
  
  const pilot = await createPilotProgram({
    leadId: lead.id,
    duration: pilotDuration,
    cost: pilotCost,
    savingsGuarantee: lead.estimatedSavings * 0.6, // 60% of estimated savings
    machines: await selectPilotMachines(lead),
    successCriteria: definePilotSuccessCriteria(lead)
  });
  
  return pilot;
}

// Product Development Workflows
export async function developEnergyOptimization(plantData: PlantData): Promise<OptimizationAlgorithm> {
  const digitalTwin = await createDigitalTwin(plantData);
  const constraints = await defineConstraints(plantData);
  const objectives = await defineObjectives(plantData);
  
  const algorithm = await buildOptimizationAlgorithm({
    digitalTwin,
    constraints,
    objectives,
    solver: 'OR-Tools'
  });
  
  return await validateAlgorithm(algorithm, plantData);
}

export async function integrateERP(customer: Customer, erpSystem: string): Promise<ERPIntegration> {
  const connector = await selectERPConnector(erpSystem);
  const dataMapping = await mapERPFields(erpSystem, customer);
  const authentication = await setupERPAuth(customer, erpSystem);
  
  const integration = await createIntegration({
    customerId: customer.id,
    erpSystem,
    connector,
    dataMapping,
    authentication,
    syncFrequency: '15min'
  });
  
  return await testIntegration(integration);
}

export async function createDigitalTwin(plantData: PlantData): Promise<DigitalTwin> {
  const machineModels = await modelMachines(plantData.machines);
  const utilityModel = await modelUtilitySystem(plantData.utilityData);
  const processModel = await modelProductionProcesses(plantData.processes);
  
  return {
    machines: machineModels,
    utilities: utilityModel,
    processes: processModel,
    constraints: await extractConstraints(plantData),
    lastUpdated: new Date()
  };
}

// Revenue Generation Workflows
export async function manageSaaSSubscription(customer: Customer): Promise<SubscriptionStatus> {
  const usage = await trackUsage(customer);
  const billing = await calculateBilling(customer, usage);
  const renewal = await assessRenewal(customer);
  
  if (renewal.risk === 'high') {
    await triggerCustomerSuccess(customer, renewal.reasons);
  }
  
  return {
    customerId: customer.id,
    tier: customer.subscriptionTier,
    monthlyRevenue: billing.amount,
    usage,
    renewalProbability: renewal.probability,
    nextBillingDate: billing.nextDate
  };
}

export async function calculatePerformanceBasedPricing(customer: Customer, savings: Energysavings): Promise<PerformanceRevenue> {
  // 10-20% of verified first-year energy cost savings
  const sharePercentage = 0.15; // 15% average
  const verifiedSavings = await verifySavings(customer, savings);
  const performanceRevenue = verifiedSavings.annualSavings * sharePercentage;
  
  return {
    customerId: customer.id,
    verifiedSavings: verifiedSavings.annualSavings,
    sharePercentage,
    performanceRevenue,
    paymentSchedule: 'quarterly'
  };
}

export async function expandToEnterprise(customer: Customer): Promise<EnterpriseExpansion> {
  const additionalPlants = await identifyExpansionOpportunities(customer);
  const enterprisePricing = await calculateEnterprisePricing(customer, additionalPlants);
  const rolloutPlan = await createRolloutPlan(additionalPlants);
  
  return {
    customerId: customer.id,
    additionalPlants,
    enterprisePricing,
    rolloutPlan,
    estimatedTimeline: rolloutPlan.totalWeeks,
    additionalRevenue: enterprisePricing.annualValue
  };
}

// Operational Procedures
export async function onboardPlant(customer: Customer, plant: PlantLocation): Promise<OnboardingResult> {
  // 45-day target from kickoff to first optimized schedule
  const dataIntegration = await integrateDataSources(plant);
  const systemConfiguration = await configureOptimization(plant);
  const training = await conductTraining(plant.staff);
  const testing = await runPilotSchedules(plant);
  
  const onboardingResult = {
    plantId: plant.id,
    customerId: customer.id,
    completionDate: new Date(),
    timeToValue: calculateTimeToValue(dataIntegration.startDate),
    firstOptimizedSchedule: testing.firstSchedule,
    trainingCompleted: training.completed,
    systemLive: true
  };
  
  await notifyCustomerSuccess(onboardingResult);
  return onboardingResult;
}

export async function optimizeSchedule(plant: PlantLocation, jobs: ProductionJob[]): Promise<OptimizationResult> {
  const constraints = await loadConstraints(plant);
  const tariffs = await getCurrentTariffs(plant.utilityProvider);
  const machineStatus = await getMachineStatus(plant.machines);
  
  const optimization = await runOptimization({
    jobs,
    constraints,
    tariffs,
    machineStatus,
    objectives: ['minimize_energy_cost', 'maintain_delivery_dates', 'reduce_peaks']
  });
  
  const result = await validateSchedule(optimization);
  await publishSchedule(plant, result.schedule);
  
  return result;
}

export async function monitorPerformance(customer: Customer): Promise<PerformanceMetrics> {
  const energyMetrics = await calculateEnergyMetrics(customer);
  const deliveryMetrics = await calculateDeliveryMetrics(customer);
  const operationalMetrics = await calculateOperationalMetrics(customer);
  
  const performance = {
    customerId: customer.id,
    period: 'monthly',
    energyCostReduction: energyMetrics.costReduction,
    peakDemandReduction: energyMetrics.peakReduction,
    onTimeDeliveryRate: deliveryMetrics.otdRate,
    scheduleAdherence: operationalMetrics.adherence,
    co2Reduction: energyMetrics.co2Reduction,
    lastUpdated: new Date()
  };
  
  if (performance.energyCostReduction < 0.08) {
    await triggerPerformanceReview(customer, performance);
  }
  
  return performance;
}

// Decision-Making Workflows
export async function makeSchedulingDecision(
  plant: PlantLocation,
  scenario: SchedulingScenario
): Promise<SchedulingDecision> {
  const alternatives = await generateAlternatives(scenario);
  const analysis = await analyzeAlternatives(alternatives, plant);
  const recommendation = await selectBestAlternative(analysis);
  
  const decision = {
    scenarioId: scenario.id,
    plantId: plant.id,
    alternatives: alternatives.length,
    selectedAlternative: recommendation.alternative,
    expectedSavings: recommendation.savings,
    riskLevel: recommendation.risk,
    confidence: recommendation.confidence,
    timestamp: new Date()
  };
  
  await logDecision(decision);
  return decision;
}

export async function participateInDemandResponse(
  plant: PlantLocation,
  drEvent: DemandResponseEvent
): Promise<DRParticipation> {
  const capability = await assessDRCapability(plant, drEvent);
  
  if (capability.canParticipate) {
    const curtailmentPlan = await createCurtailmentPlan(plant, drEvent);
    const adjustedSchedule = await adjustScheduleForDR(plant, curtailmentPlan);
    
    return {
      eventId: drEvent.id,
      plantId: plant.id,
      participating: true,
      curtailmentMW: curtailmentPlan.reduction,
      revenue: drEvent.rate * curtailmentPlan.reduction,
      adjustedSchedule,
      riskAssessment: capability.risk
    };
  }
  
  return {
    eventId: drEvent.id,
    plantId: plant.id,
    participating: false,
    reason: capability.reason
  };
}

export async function analyzeWhatIfScenario(
  plant: PlantLocation,
  scenario: WhatIfScenario
): Promise<ScenarioAnalysis> {
  const baselineSchedule = await getCurrentSchedule(plant);
  const scenarioSchedule = await simulateScenario(plant, scenario);
  
  const comparison = {
    scenario: scenario.name,
    plantId: plant.id,
    baseline: {
      energyCost: baselineSchedule.energyCost,
      peakDemand: baselineSchedule.peakDemand,
      deliveryRate: baselineSchedule.deliveryRate
    },
    proposed: {
      energyCost: scenarioSchedule.energyCost,
      peakDemand: scenarioSchedule.peakDemand,
      deliveryRate: scenarioSchedule.deliveryRate
    },
    impact: {
      costDelta: scenarioSchedule.energyCost - baselineSchedule.energyCost,
      peakDelta: scenarioSchedule.peakDemand - baselineSchedule.peakDemand,
      deliveryDelta: scenarioSchedule.deliveryRate - baselineSchedule.deliveryRate
    },
    recommendation: await generateRecommendation(baselineSchedule, scenarioSchedule)
  };
  
  return comparison;
}

// Helper function implementations (pseudocode)
async function calculateFitScore(lead: Lead): Promise<number> {
  // Score based on machine count (5-50 target), energy spend, pain points
  let score = 0;
  if (lead.machineCount >= 5 && lead.machineCount <= 50) score += 3;
  if (lead.annualEnergySpend > 100000) score += 2;
  if (lead.currentSchedulingMethod === 'manual') score += 2;
  if (lead.painPoints.includes('high_energy_costs')) score += 2;
  if (lead.painPoints.includes('demand_charges')) score += 1;
  return Math.min(10, score);
}

async function identifyDecisionMakers(lead: Lead): Promise<string[]> {
  // Typical roles: VP Operations, Plant Manager, Energy Manager, CFO
  return ['VP Operations', 'Plant Manager', 'Energy Manager'];
}

async function assessPurchaseTimeline(lead: Lead): Promise<string> {
  // Based on pain severity and budget cycle
  return lead.painPoints.length > 3 ? '3-6 months' : '6-12 months';
}

async function estimateBudget(lead: Lead): Promise<number> {
  // Estimate based on machine count and typical pricing
  return lead.machineCount * 450 * 12 + 25000; // Annual subscription + onboarding
}

// Additional helper functions would be implemented here...
// (selectPilotMachines, definePilotSuccessCriteria, createPilotProgram, etc.)
```

## Integration Points

The workflow functions integrate with the broader .do platform through:

- **Functions**: Each workflow step can be deployed as serverless functions
- **Workflows**: Complex multi-step processes like customer onboarding can be orchestrated
- **Agents**: AI agents can execute decision-making workflows autonomously
- **APIs**: RESTful endpoints expose workflow triggers and status
- **Events**: Workflow state changes emit events for monitoring and integration

## Usage Examples

```typescript
// Customer acquisition flow
const newCustomer = await acquireCustomer(incomingLead);

// Daily optimization
const schedule = await optimizeSchedule(plant, todaysJobs);

// Performance monitoring
const metrics = await monitorPerformance(customer);

// What-if analysis
const analysis = await analyzeWhatIfScenario(plant, {
  name: 'Rush Order Impact',
  changes: { urgentJobs: 3, deadline: 'tomorrow' }
});
```
