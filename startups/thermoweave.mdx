---
name: ThermoWeave
slug: thermoweave
naics:
  primary: '325212'
  occupations: []
service:
  title: ThermoWeave Copilot - Energy Optimization for Synthetic Rubber Plants
  description: >-
    Physics-informed AI that optimizes boilers, steam headers, dryers, and chillers 
    to reduce energy consumption by 8-15% while maintaining quality constraints.
  targetUsers:
    - Plant Managers
    - Process Engineers
    - Energy Managers
    - Production Engineers
  triggers:
    - Daily optimization schedule
    - Process condition changes
    - Energy price fluctuations
    - Quality parameter deviations
  inputs:
    - DCS/SCADA data via OPC UA/Modbus/PI
    - Steam header pressures and flows
    - Dryer outlet moisture and temperature
    - Chiller performance metrics
    - Production schedules and grade specifications
  steps:
    - Collect real-time process data and validate quality
    - Run physics-informed ML models for moisture prediction
    - Execute multi-objective optimization with safety constraints
    - Generate setpoint recommendations with confidence bands
    - Deploy changes with operator approval and monitoring
    - Track energy savings and verify quality compliance
  tools:
    - OPC UA/Modbus/PI connectors
    - Physics-informed ML models
    - Multi-objective optimizer
    - IPMVP-compliant M&V system
    - Operator interface with approval workflows
  outputs:
    - Optimized setpoints for boilers, dryers, chillers
    - Energy savings projections and verification
    - Quality risk assessments
    - Carbon emissions reduction reports
    - Operator recommendations with reasoning
  pricingModel:
    - Annual SaaS subscription per plant ($120k-$300k)
    - Implementation fee ($50k-$150k per site)
    - Performance-based upside (10-20% of verified savings)
  humanInLoop: true
  feasibility:
    remoteOnLaptop: 4
    modelCapability: 4
    overall: 4
  risks:
    - Off-spec product risk if constraints violated
    - Plant safety concerns with automated control
    - Model accuracy degradation over time
    - Integration complexity with legacy systems
  dependencies:
    - Access to DCS/SCADA systems
    - Historical process data
    - Plant operating procedures
    - Safety system integration approval
leanCanvas:
  problem:
    - Synthetic rubber plants run dryers, steam headers, and chillers conservatively to avoid off-spec moisture/temperature, wasting 8–20% of energy per ton.
    - Steam header imbalances (PRV throttling, poor boiler loading, condensate return losses) raise fuel cost and variability; operators lack visibility and optimization tools.
    - Dryer outlet moisture control is noisy and lagging; limited inline sensors force setpoints well above required temperature/humidity, increasing energy use and off-spec risk.
    - Chillers often overcool to maintain margins; condenser fouling, suboptimal sequencing, and poor setpoint coordination increase kW/ton.
    - Existing APC/MPC projects are expensive, brittle across products, and not tailored for batch-to-batch variability in SR grades; operator trust and adoption are low.
    - Energy and emissions targets (corporate and regulatory) demand measurable reduction with verification without compromising throughput or quality.
  solution:
    - Edge-deployed optimization copilot that connects via OPC UA/Modbus/PI to DCS/SCADA; runs in recommendation mode or closed-loop with operator approval.
    - Physics + ML hybrid models: moisture soft sensor for dryer outlet; steam header network model; chiller plant model (sequencing + setpoints).
    - Multi-objective optimizer (cost, energy, emissions) with hard safety/quality constraints and operator-configurable guardrails.
    - Boiler/steam: load allocation across boilers, header pressure targeting, PRV loss minimization, condensate return optimization.
    - Dryers: feed-forward control using upstream moisture/throughput/grade; zone temperature/airflow/humidity setpoint optimization to hit moisture spec with minimum energy.
    - Chillers: condenser approach optimization, chilled-water and condenser-water setpoints, pump/VFD logic and sequencing based on real-time load and weather.
    - What-if sandbox: simulate recipes, ambient conditions, and schedules; quantify expected savings and quality risk before deploying.
    - M&V and reporting: baselines, savings, and tCO2e reduction with IPMVP Option B; utility-incentive-ready reports.
    - Operator UX: clear suggestions, confidence bands, and reason codes; override tracking to build trust and continuous learning.
  uniqueValueProp: Reduce steam/electric energy per ton by 8–15% in 8–12 weeks with zero increase in off-spec risk. ThermoWeave Copilot optimizes boilers/steam headers, dryers, and chillers using a physics-informed AI that respects quality constraints (moisture/temperature) and plant safety, delivering measurable savings with IPMVP-compliant M&V.
  unfairAdvantage: Pre-built, SR-specific dryer/steam/chiller models and moisture soft sensors tuned for emulsion and solution SBR/BR/NBR grades; proven guardrail library for safe closed-loop deployment and IPMVP-ready M&V. Early partnerships with OEMs/integrators and IISRP members accelerate adoption and create data network effects that improve models per grade/facility.
  customerSegments:
    - Plant managers, process/production engineers, energy managers at synthetic rubber plants (NAICS 325212).
    - Corporate operations excellence and sustainability leaders at SR producers.
    - Utility-sponsored industrial efficiency programs and ESCOs seeking verifiable savings in chemicals.
    - OEMs and system integrators servicing boilers, dryers, chillers, and DCS/SCADA in SR plants.
  channels:
    - Direct enterprise sales to top SR producers (IISRP member list) targeting NA/EU multi-plant accounts.
    - Pilot-led land-and-expand: 12-week paid proof-of-value on 1 line/dryer and one steam header; expand to full plant and fleet post-M&V.
    - Alliances with OEMs and integrators: Honeywell, Emerson, Yokogawa, Rockwell, Trane/JCI, boiler OEMs (Cleaver-Brooks), dryer OEMs; co-sell/service attach.
    - Utility/ESCO partnerships to fund pilots via industrial efficiency incentives; provide M&V packages aligned with program requirements.
    - Industry presence: ACS Rubber Division, IISRP Annual General Meeting, AIChE Spring, and targeted technical webinars/white papers with case studies.
    - Account-based marketing: benchmark reports via non-intrusive energy scans using historian data; ROI calculators tailored to plant capacity and fuel/electricity prices.
  revenueStreams:
    - Annual SaaS subscription per plant: $120k–$300k (tiered by number of dryers/headers/chiller capacity and autonomy level).
    - One-time implementation/integration fee: $50k–$150k per site (covers modeling, edge gateway, commissioning, and training).
    - Performance-based upside: 10–20% of verified first-year energy savings above guaranteed minimum.
    - Enterprise license for multi-site deployments with volume discounts and corporate analytics add-ons.
    - Optional MRV/carbon reporting module: $20k/year per site; optional carbon credit/rebate administration fee (5–10%).
    - Professional services: change management, operator training, custom dashboards ($200/hr or fixed bundles).
  costStructure:
    - Personnel: ML engineers, chemical/process engineers, control engineers, solution architects, customer success, sales ($4–6M/year at scale).
    - Cloud/edge infrastructure: GPUs for model training, data storage, monitoring ($200–500k/year).
    - Edge hardware: industrial gateways/IPC with secure images ($5–10k/site).
    - Systems integrator/OEM partner fees and revenue share (10–25% of deal value for co-sell/installation).
    - Compliance and security: SOC 2, ISA/IEC 62443 readiness, penetration testing, insurance ($150–300k/year).
    - Travel/onsite commissioning and training ($10–30k/site).
    - Marketing and industry events ($150–300k/year).
    - R&D for physics-informed models, soft sensors, and optimizer IP ($500k–1M/year).
  keyMetrics:
    - Energy intensity reduction (specific energy per ton): target -8% to -15% vs 90-day pre-baseline.
    - Dryer outlet moisture control: mean within spec; standard deviation reduced by 20–40%; Cpk ≥ 1.33.
    - Steam header performance: PRV loss reduction ≥ 30%; boiler load variance -20%; condensate return rate +5–10 pp.
    - Chiller efficiency: plant kW/ton -8–12%; condenser approach -1 to -2°C; compressor surge events = 0.
    - Operator adoption: recommendation acceptance rate ≥ 70% within 4 weeks; override rate < 15% in steady state; autonomy uptime ≥ 85%.
    - Production impact: zero increase in off-spec; throughput change tracked (tons/hour) with ≥ 98% on-spec lots.
    - Financial: verified energy savings $/year; payback ≤ 6 months; gross margin ≥ 65% on software; NRR ≥ 120%.
    - Reliability/Safety: optimizer availability ≥ 99%; automatic safe state on data quality degradation; change management compliance (MOC sign-offs within SLA).
storyBrand:
  character: >-
    Plant managers and process engineers at synthetic rubber facilities who must 
    meet production targets while reducing energy costs and emissions without 
    compromising product quality or plant safety.
  problem: >-
    Manual optimization can't keep up with changing process conditions, leading 
    to conservative operation that wastes 8-20% of energy. Existing control 
    systems lack the intelligence to balance energy efficiency with quality 
    constraints across interconnected steam, drying, and cooling systems.
  guide: >-
    We're chemical engineers and AI experts who understand synthetic rubber 
    production. We deliver a physics-informed optimization platform that 
    respects quality constraints, integrates with existing DCS/SCADA, and 
    provides verifiable energy savings with IPMVP-compliant measurement.
  plan: >-
    1) Connect to plant historian and DCS systems. 2) Deploy physics-informed 
    models calibrated to your specific grades and equipment. 3) Run advisory 
    mode to demonstrate value. 4) Enable closed-loop optimization with operator 
    oversight. 5) Track and verify energy savings with continuous improvement.
  callToAction: >-
    Start a 12-week pilot on one production line to quantify energy savings 
    and quality impact.
  success: >-
    Consistently lower energy costs per ton, reduced emissions, improved process 
    stability, and verified savings that meet corporate sustainability targets—
    all while maintaining or improving product quality.
  failure: >-
    Continue wasting energy through conservative operation, missing emissions 
    targets, and struggling with manual optimization that can't keep pace with 
    changing conditions.
landingPage:
  hero:
    title: ThermoWeave Copilot - Energy Optimization for Synthetic Rubber Plants
    subtitle: >-
      Physics-informed AI that reduces energy consumption by 8-15% while 
      maintaining quality constraints in synthetic rubber production.
    ctaText: Request a pilot
    ctaHref: /pilot
  problem:
    - Conservative operation wastes 8-20% of energy per ton
    - Steam header imbalances increase fuel costs and variability
    - Dryer moisture control forces high energy setpoints
    - Chiller overcooling and poor sequencing waste electricity
    - Manual optimization can't keep up with changing conditions
    - Existing APC/MPC systems are expensive and brittle
    - Energy and emissions targets demand measurable reduction
  solution:
    - Real-time optimization that balances energy efficiency with quality constraints
    - Physics-informed ML models for moisture prediction and system modeling
    - Multi-objective optimization across boilers, dryers, and chillers
    - IPMVP-compliant measurement and verification of energy savings
    - Operator-friendly interface with approval workflows and guardrails
    - Edge deployment with secure integration to existing DCS/SCADA systems
  features:
    - 'DCS/SCADA integration: OPC UA, Modbus, PI System connectors'
    - 'Physics-informed models: moisture soft sensors, steam network models'
    - 'Multi-objective optimization: energy, cost, emissions with quality constraints'
    - 'Boiler optimization: load allocation, header pressure, condensate return'
    - 'Dryer optimization: zone temperature, airflow, humidity setpoints'
    - 'Chiller optimization: sequencing, setpoints, pump/VFD control'
    - 'What-if simulation: test scenarios before deployment'
    - 'M&V reporting: IPMVP Option B compliant savings verification'
    - 'Operator interface: recommendations with confidence bands and reasoning'
    - 'Safety systems: automatic rollback, quality constraint monitoring'
    - 'Edge deployment: secure, low-latency local processing'
    - 'Enterprise features: multi-site analytics, corporate reporting'
  steps:
    - 'Assess: Evaluate plant systems and identify optimization opportunities'
    - 'Connect: Integrate with DCS/SCADA and historian systems'
    - 'Model: Deploy physics-informed ML models calibrated to your processes'
    - 'Validate: Run advisory mode to demonstrate energy savings potential'
    - 'Pilot: Enable optimization on selected equipment with operator oversight'
    - 'Optimize: Expand to full plant with closed-loop control and guardrails'
    - 'Scale: Deploy across multiple sites with centralized monitoring'
    - 'Verify: Continuous M&V reporting and model improvement'
---

# ThermoWeave - Business Process Functions

## Customer Acquisition Workflows

```typescript
interface Lead {
  company: string;
  plantLocation: string;
  contactInfo: ContactInfo;
  plantCapacity: number; // tons/year
  energyCosts: number; // $/year
  currentSystems: string[];
  painPoints: string[];
}

interface QualifiedLead extends Lead {
  fitScore: number;
  estimatedSavings: number;
  decisionMakers: Contact[];
  timeline: string;
  budget: number;
}

interface Customer {
  id: string;
  contract: Contract;
  plantData: PlantConfiguration;
  implementation: ImplementationPlan;
}

export async function acquireCustomer(lead: Lead): Promise<Customer> {
  // Step 1: Qualify the lead based on plant characteristics and fit
  const qualifiedLead = await qualifyLead(lead);
  
  // Step 2: Conduct technical assessment and energy audit
  const assessment = await conductPlantAssessment(qualifiedLead);
  
  // Step 3: Generate customized proposal with ROI projections
  const proposal = await generateProposal(assessment);
  
  // Step 4: Negotiate contract terms and pilot scope
  const contract = await negotiateContract(proposal);
  
  // Step 5: Onboard customer with implementation planning
  return await onboardCustomer(contract);
}

async function qualifyLead(lead: Lead): Promise<QualifiedLead> {
  // Assess plant size, energy intensity, and technology readiness
  const fitScore = calculateFitScore(lead);
  
  if (fitScore < 0.6) {
    throw new Error('Lead does not meet minimum qualification criteria');
  }
  
  // Estimate potential energy savings based on plant characteristics
  const estimatedSavings = calculatePotentialSavings(lead);
  
  // Identify decision makers and buying process
  const decisionMakers = await identifyDecisionMakers(lead);
  
  return {
    ...lead,
    fitScore,
    estimatedSavings,
    decisionMakers,
    timeline: determineBuyingTimeline(lead),
    budget: estimateBudget(lead)
  };
}

async function conductPlantAssessment(lead: QualifiedLead): Promise<PlantAssessment> {
  // Remote energy scan using historian data
  const energyBaseline = await performEnergyAudit(lead);
  
  // Assess current control systems and integration points
  const systemsAssessment = await assessControlSystems(lead);
  
  // Identify optimization opportunities
  const opportunities = await identifyOptimizationOpportunities(energyBaseline, systemsAssessment);
  
  return {
    energyBaseline,
    systemsAssessment,
    opportunities,
    estimatedROI: calculateROI(opportunities),
    implementationComplexity: assessComplexity(systemsAssessment)
  };
}
```

## Product Development Processes

```typescript
interface ModelDevelopment {
  plantType: string;
  processData: ProcessData;
  modelAccuracy: number;
  validationResults: ValidationResults;
}

interface FeatureRequest {
  customerId: string;
  description: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  businessValue: number;
  technicalComplexity: number;
}

export async function developPhysicsInformedModel(
  plantData: ProcessData,
  gradeSpecifications: GradeSpec[]
): Promise<ModelDevelopment> {
  // Step 1: Preprocess and validate plant data
  const cleanedData = await preprocessPlantData(plantData);
  
  // Step 2: Develop physics-based model structure
  const physicsModel = await buildPhysicsModel(cleanedData, gradeSpecifications);
  
  // Step 3: Train ML components for soft sensors
  const mlComponents = await trainMLComponents(cleanedData, physicsModel);
  
  // Step 4: Validate model accuracy against historical data
  const validationResults = await validateModel(physicsModel, mlComponents, cleanedData);
  
  // Step 5: Deploy model to edge infrastructure
  await deployModelToEdge(physicsModel, mlComponents);
  
  return {
    plantType: inferPlantType(plantData),
    processData: cleanedData,
    modelAccuracy: validationResults.accuracy,
    validationResults
  };
}

export async function prioritizeFeatureDevelopment(
  requests: FeatureRequest[]
): Promise<FeatureRequest[]> {
  // Score features based on business value and technical feasibility
  const scoredFeatures = requests.map(request => ({
    ...request,
    score: calculateFeatureScore(request.businessValue, request.technicalComplexity)
  }));
  
  // Sort by score and strategic alignment
  return scoredFeatures
    .sort((a, b) => b.score - a.score)
    .filter(feature => feature.score > 0.5); // Minimum viability threshold
}

async function buildPhysicsModel(
  data: ProcessData,
  grades: GradeSpec[]
): Promise<PhysicsModel> {
  // Implement thermodynamic models for steam systems
  const steamModel = await buildSteamHeaderModel(data.steamData);
  
  // Develop heat and mass transfer models for dryers
  const dryerModel = await buildDryerModel(data.dryerData, grades);
  
  // Create chiller performance models
  const chillerModel = await buildChillerModel(data.chillerData);
  
  return {
    steamModel,
    dryerModel,
    chillerModel,
    constraints: extractSafetyConstraints(data)
  };
}
```

## Revenue Generation Flows

```typescript
interface Subscription {
  customerId: string;
  tier: 'starter' | 'professional' | 'enterprise';
  monthlyRevenue: number;
  contractLength: number;
  renewalDate: Date;
}

interface PerformanceContract {
  customerId: string;
  guaranteedSavings: number;
  actualSavings: number;
  performanceFee: number;
  measurementPeriod: DateRange;
}

export async function generateRecurringRevenue(
  customer: Customer,
  usageData: UsageMetrics
): Promise<RevenueGeneration> {
  // Step 1: Calculate base subscription revenue
  const subscriptionRevenue = calculateSubscriptionRevenue(customer.subscription);
  
  // Step 2: Assess performance-based fees
  const performanceFees = await calculatePerformanceFees(customer, usageData);
  
  // Step 3: Identify upsell opportunities
  const upsellOpportunities = await identifyUpsellOpportunities(customer, usageData);
  
  // Step 4: Process renewal and expansion
  const renewalRevenue = await processRenewalAndExpansion(customer, upsellOpportunities);
  
  return {
    subscriptionRevenue,
    performanceFees,
    upsellRevenue: renewalRevenue.expansionRevenue,
    totalRevenue: subscriptionRevenue + performanceFees + renewalRevenue.expansionRevenue
  };
}

async function calculatePerformanceFees(
  customer: Customer,
  usageData: UsageMetrics
): Promise<number> {
  // Verify energy savings using IPMVP methodology
  const verifiedSavings = await verifyEnergySavings(customer, usageData);
  
  // Calculate performance fee based on contract terms
  const performanceRate = customer.contract.performanceRate || 0.15;
  
  if (verifiedSavings > customer.contract.guaranteedSavings) {
    return (verifiedSavings - customer.contract.guaranteedSavings) * performanceRate;
  }
  
  return 0;
}

export async function expandCustomerAccount(
  customer: Customer,
  expansionOpportunity: ExpansionOpportunity
): Promise<AccountExpansion> {
  // Step 1: Assess expansion feasibility
  const feasibilityAssessment = await assessExpansionFeasibility(customer, expansionOpportunity);
  
  // Step 2: Develop expansion proposal
  const expansionProposal = await createExpansionProposal(feasibilityAssessment);
  
  // Step 3: Negotiate expansion terms
  const expandedContract = await negotiateExpansion(customer, expansionProposal);
  
  // Step 4: Implement expansion
  return await implementAccountExpansion(customer, expandedContract);
}
```

## Operational Procedures

```typescript
interface PlantMonitoring {
  plantId: string;
  systemHealth: SystemHealth;
  energyPerformance: EnergyMetrics;
  qualityMetrics: QualityMetrics;
  alerts: Alert[];
}

interface MaintenanceSchedule {
  equipmentId: string;
  maintenanceType: 'preventive' | 'predictive' | 'corrective';
  scheduledDate: Date;
  estimatedDuration: number;
  requiredResources: Resource[];
}

export async function monitorPlantOperations(
  plantId: string
): Promise<PlantMonitoring> {
  // Step 1: Collect real-time data from plant systems
  const realTimeData = await collectPlantData(plantId);
  
  // Step 2: Assess system health and performance
  const systemHealth = await assessSystemHealth(realTimeData);
  
  // Step 3: Calculate energy performance metrics
  const energyPerformance = await calculateEnergyMetrics(realTimeData);
  
  // Step 4: Monitor product quality parameters
  const qualityMetrics = await monitorQualityMetrics(realTimeData);
  
  // Step 5: Generate alerts for anomalies
  const alerts = await generateAlerts(systemHealth, energyPerformance, qualityMetrics);
  
  return {
    plantId,
    systemHealth,
    energyPerformance,
    qualityMetrics,
    alerts
  };
}

export async function optimizePlantPerformance(
  plantId: string,
  currentConditions: PlantConditions
): Promise<OptimizationResults> {
  // Step 1: Run physics-informed models
  const modelPredictions = await runPhysicsModels(plantId, currentConditions);
  
  // Step 2: Execute multi-objective optimization
  const optimizationResults = await executeOptimization(modelPredictions, currentConditions);
  
  // Step 3: Validate recommendations against constraints
  const validatedRecommendations = await validateRecommendations(optimizationResults);
  
  // Step 4: Generate operator-friendly recommendations
  const operatorRecommendations = await generateOperatorRecommendations(validatedRecommendations);
  
  // Step 5: Track implementation and results
  await trackOptimizationResults(plantId, operatorRecommendations);
  
  return {
    recommendations: operatorRecommendations,
    expectedSavings: optimizationResults.expectedSavings,
    confidenceLevel: optimizationResults.confidence,
    implementationPlan: optimizationResults.implementationPlan
  };
}

async function executeOptimization(
  predictions: ModelPredictions,
  conditions: PlantConditions
): Promise<OptimizationResults> {
  // Multi-objective optimization: minimize energy cost, maximize quality
  const objectives = {
    energyCost: (setpoints: Setpoints) => calculateEnergyCost(setpoints, conditions),
    qualityRisk: (setpoints: Setpoints) => assessQualityRisk(setpoints, predictions),
    emissions: (setpoints: Setpoints) => calculateEmissions(setpoints, conditions)
  };
  
  // Apply safety and operational constraints
  const constraints = extractOperationalConstraints(conditions);
  
  // Solve optimization problem
  return await solveMultiObjectiveOptimization(objectives, constraints);
}
```

## Decision-Making Workflows

```typescript
interface BusinessDecision {
  id: string;
  type: 'investment' | 'partnership' | 'product' | 'market';
  description: string;
  options: DecisionOption[];
  criteria: DecisionCriteria;
  stakeholders: Stakeholder[];
}

interface DecisionOption {
  name: string;
  costs: number;
  benefits: number;
  risks: Risk[];
  timeline: number;
  probability: number;
}

export async function makeStrategicDecision(
  decision: BusinessDecision
): Promise<DecisionOutcome> {
  // Step 1: Gather relevant data and analysis
  const analysisData = await gatherDecisionData(decision);
  
  // Step 2: Evaluate each option against criteria
  const evaluatedOptions = await evaluateOptions(decision.options, decision.criteria, analysisData);
  
  // Step 3: Conduct stakeholder consultation
  const stakeholderInput = await consultStakeholders(decision.stakeholders, evaluatedOptions);
  
  // Step 4: Perform risk assessment
  const riskAssessment = await assessDecisionRisks(evaluatedOptions);
  
  // Step 5: Make final decision with rationale
  const finalDecision = await selectOptimalOption(evaluatedOptions, stakeholderInput, riskAssessment);
  
  // Step 6: Create implementation plan
  const implementationPlan = await createImplementationPlan(finalDecision);
  
  return {
    selectedOption: finalDecision,
    rationale: generateDecisionRationale(finalDecision, evaluatedOptions),
    implementationPlan,
    successMetrics: defineSuccessMetrics(finalDecision)
  };
}

export async function evaluateMarketExpansion(
  targetMarket: Market,
  currentCapabilities: Capabilities
): Promise<ExpansionDecision> {
  // Step 1: Analyze market opportunity
  const marketAnalysis = await analyzeMarketOpportunity(targetMarket);
  
  // Step 2: Assess competitive landscape
  const competitiveAnalysis = await analyzeCompetition(targetMarket);
  
  // Step 3: Evaluate capability gaps
  const capabilityGaps = await assessCapabilityGaps(currentCapabilities, targetMarket);
  
  // Step 4: Calculate investment requirements
  const investmentRequirements = await calculateInvestmentNeeds(capabilityGaps, targetMarket);
  
  // Step 5: Project financial returns
  const financialProjections = await projectFinancialReturns(targetMarket, investmentRequirements);
  
  return {
    recommendation: determineExpansionRecommendation(marketAnalysis, financialProjections),
    marketOpportunity: marketAnalysis,
    requiredInvestment: investmentRequirements,
    expectedReturns: financialProjections,
    timeline: estimateExpansionTimeline(capabilityGaps),
    risks: identifyExpansionRisks(targetMarket, capabilityGaps)
  };
}

async function evaluateOptions(
  options: DecisionOption[],
  criteria: DecisionCriteria,
  data: AnalysisData
): Promise<EvaluatedOption[]> {
  return Promise.all(options.map(async option => {
    const scores = await scoreOptionAgainstCriteria(option, criteria, data);
    const weightedScore = calculateWeightedScore(scores, criteria.weights);
    
    return {
      ...option,
      scores,
      weightedScore,
      ranking: 0 // Will be set after all options are evaluated
    };
  }));
}
```

Generated for NAICS 325212 — Synthetic Rubber Manufacturing.
Service: ThermoWeave Copilot - Energy Optimization for Synthetic Rubber Plants
