---
name: LandedLens
slug: landedlens
domain: landedlens.ai
naics:
  primary: "315990"
  occupations: ["Sourcing Manager", "Costing Manager", "Production Planner", "Finance Controller"]
score:
  remote_on_laptop: 0.95
  model_capability: 0.9
  overall: 0.925
vmv:
  vision: "Hit target margins with confidence through AI-driven landed cost precision."
  mission: "Automate BOM-to-landed-cost workflows with ±2% accuracy, cutting costing cycles by 50-70%."
  purpose: "Eliminate margin slippage and costing delays in apparel manufacturing."
leanCanvas:
  problem:
    - "Manual spreadsheet costing leads to 2–5% landed cost variance vs actuals due to duty, freight, and FX volatility."
    - "Costing cycles are slow (3–10 days) because teams manually gather quotes, duty tables, and BOM updates across suppliers."
    - "Missed gross margin targets by 1–3 percentage points from late changes (MOQ, trims, packaging, CO, routing)."
    - "Inconsistent HS code classification and Incoterms handling create compliance risk and unexpected charges/chargebacks."
    - "No standardized way to run what-if scenarios (supplier, CO, qty breaks, mode, FX, tariff changes) to hit target margin at style/SKU level."
    - "Poor integration between PLM/ERP/freight providers causes duplicate data entry and errors in PO creation and vendor negotiations."
    - "Limited visibility into cost drivers across seasons and vendors hampers negotiations and continuous improvement."
  solution:
    - "AI-assisted BOM ingestion maps items, packaging, and process costs; auto-detects HS code candidates by component and country of origin with explainability and human-in-the-loop approval."
    - "Rules + optimization engine computes FOB and landed cost by Incoterm across duty, brokerage, freight (ocean/air/express), surcharges (GRI, BAF), and FX in real time."
    - "What-if simulator to test suppliers, MOQs, qty breaks, routing, modes, CO shifts, packaging specs, and FX hedges to meet target margin and price points."
    - "Target-margin optimizer proposes actions (e.g., packaging change, supplier swap, mode shift) sorted by impact on GM% and lead-time risk."
    - "Variance tracking compares estimates vs actual invoice/PO costs, learning to reduce error over time; alerts on deviations beyond thresholds."
    - "Integrated data feeds: FX, surcharges, tariffs/duties; connectors to PLM/ERP (Centric, FlexPLM, BlueCherry, NetSuite, Infor, SAP AFS) and to freight forwarders."
    - "Governance: approval workflows, audit trails, cost versioning, and change logs per style/season/vendor."
    - "Supplier collaboration portal to collect quotes and BOM confirmations; standardized cost templates and auto-validation."
  uniqueValueProp: "Hit target margins with confidence: an AI-driven BOM-to-landed-cost engine that automates duty, freight, FX, and MOQ scenarios, delivering ±2% first-pass landed cost accuracy and cutting costing cycle time by 50–70%."
  unfairAdvantage: "Closed-loop learning on BOM-to-actual variances across brands and factories yields a unique, domain-specific cost graph. Combined with PLM/logistics integrations and compliance guardrails, this produces faster, more accurate landed-cost scenarios than generic calculators or spreadsheet-based workflows."
  customerSegments:
    - "Primary: Apparel accessories and other apparel manufacturers (NAICS 315990), including hats, belts, gloves, bags, hosiery, and trims suppliers (10–1,000 employees)."
    - "Mid-market apparel and private-label brands/retailers importing accessories (US/EU/UK/CA/AU), annual revenue $10M–$1B."
    - "OEM/ODM factories serving fashion brands seeking faster, more accurate quoting."
    - "Sourcing/merchandising, costing managers, production planners, finance controllers, and logistics/procurement teams."
    - "Trading companies and sourcing agents managing multi-factory quotes."
  channels:
    - "Direct sales to sourcing/costing leaders at NAICS 315990 manufacturers and apparel brands via targeted outbound (LinkedIn Sales Navigator, Apollo, industry lists)."
    - "Partnerships/integrations with PLM/ERP vendors and resellers (Centric, PTC FlexPLM, BlueCherry, NetSuite, Infor Nexus)."
    - "Alliances with freight forwarders and customs brokers to bundle landed-cost simulations in quoting workflows (e.g., Flexport, Maersk, DHL, Expeditors)."
    - "Trade shows and industry events: Sourcing at MAGIC, Texworld NYC/Paris, Première Vision, AAFA events, NRF Supply Chain."
    - "Content-led growth: duty/freight watch reports, margin playbooks, HS code classification guides, webinars with forwarders and brokers."
    - "ROI-driven trials with onboarding sprints for 1–2 categories/brands/factories (30–60 days)."
    - "Referral program for sourcing agents and consultants; partner co-marketing."
    - "Regional distributors in China/VN/IN/BGD for factory/OEM adoption."
  revenueStreams:
    - "SaaS subscriptions (org-level): Starter $500/month (up to 5 users, 2 integrations), Pro $1,500/month (up to 25 users, 5 integrations), Enterprise custom (unlimited users, SSO, SLAs)."
    - "Usage-based add-on: $0.05–$0.15 per simulation beyond plan limits; volume discounts for OEMs/factories."
    - "Implementation/onboarding packages: $3k–$25k based on integrations and data migration scope."
    - "Premium data packs (embedded tariff updates, freight benchmarks) via data partner passthrough + margin."
    - "Supplier portal seats (OEM/ODM) at $15–$30/user/month or included in Enterprise."
    - "Professional services: HS code audits, cost optimization workshops, ERP/PLM custom integrations."
    - "Optional revenue share/commission on freight bookings initiated via platform (where permitted)."
  costStructure:
    - "R&D and product (45–55% of opex): engineering, data science, product, QA."
    - "Cloud infrastructure (8–15% of revenue): compute for simulations, storage, networking; target gross margin ≥80%."
    - "Data licensing (3–8% of revenue): tariff and freight benchmarks, FX feeds."
    - "Go-to-market (20–30% of opex): sales, marketing, events, partner programs."
    - "Customer success and support (10–15% of opex): onboarding, training, account management."
    - "Security/compliance (2–5% of opex): SOC 2, pen testing, audits."
    - "Partner revenue share (as contracted) on bundled data/freight."
    - "General/admin (8–12% of opex): finance, HR, legal."
  keyMetrics:
    - "Product/operational: First-pass landed cost accuracy within ±2% vs actual; reduce costing cycle time from baseline (e.g., 5 days) by 50–70%; margin slippage reduction ≥1.0 pp per season."
    - "Adoption: Active users per org; scenarios per style; % of styles costed through platform; supplier portal adoption rate."
    - "Quality: HS code recommendation acceptance rate ≥85%; exception rate <10%; audit trail completeness 100%."
    - "Business: MRR/ARR; Net revenue retention ≥115%; logo retention ≥90%; CAC payback <12 months; gross margin ≥80%."
    - "Value delivery: Reduction in RFQ-to-PO time by 30–50%; variance-to-PO costs <2%; freight cost predictability ±5%."
    - "Time-to-value: Onboarding time to first scenario <7 days; integration completion within 30–60 days."
    - "Risk/compliance: Duty misclassification incidents trending to zero; number of tariff-change alerts actioned; % scenarios with compliance review."
okrs:
  - objective: "Achieve industry-leading cost accuracy"
    keyResults:
      - metric: "First-pass landed cost accuracy"
        target: "±2% vs actuals"
      - metric: "HS code recommendation acceptance"
        target: "≥85%"
  - objective: "Accelerate costing cycles"
    keyResults:
      - metric: "Costing cycle time reduction"
        target: "50-70% vs baseline"
      - metric: "Time to first scenario"
        target: "<7 days"
  - objective: "Drive margin improvement"
    keyResults:
      - metric: "Margin slippage reduction"
        target: "≥1.0 pp per season"
      - metric: "Variance to PO costs"
        target: "<2%"
storyBrand:
  character: "Sourcing and costing managers"
  problem: "Manual processes causing margin slippage"
  guide: "AI-driven cost optimization platform"
  plan: "Pilot → Integrate → Scale"
  callToAction: "Start ROI trial"
  success: "Hit target margins consistently"
  failure: "Continue losing to cost variance"
branding:
  nameIdeas: ["CostLens", "MarginAI", "LandedLogic"]
  colors: { primary: "#2563EB", secondary: "#1F2937" }
  fonts: { heading: "Inter", body: "Inter" }
  logoPrompt: "Modern lens/scope icon with cost/margin visualization"
pricing:
  plans:
    - id: starter
      name: "Starter"
      price: 500
      interval: monthly
      features: ["Up to 5 users", "2 integrations", "Basic scenarios", "Email support"]
    - id: pro
      name: "Pro"
      price: 1500
      interval: monthly
      features: ["Up to 25 users", "5 integrations", "Advanced scenarios", "Priority support", "Supplier portal"]
    - id: enterprise
      name: "Enterprise"
      price: "Custom"
      interval: monthly
      features: ["Unlimited users", "All integrations", "Custom workflows", "Dedicated CSM", "SLA"]
  stripe:
    productId: ""
    priceIds: {}
prd:
  summary: "AI-driven BOM-to-landed-cost platform for apparel manufacturers"
  scopeMVP:
    - "BOM ingestion and AI-assisted HS code classification"
    - "Real-time landed cost calculation engine"
    - "What-if scenario simulator"
    - "Supplier collaboration portal"
    - "Variance tracking and alerts"
    - "PLM/ERP integrations"
experiments:
  - hypothesis: "AI-assisted HS code classification reduces compliance risk by 80%"
    metric: "Duty misclassification incidents"
    variantCount: 2
  - hypothesis: "Real-time cost scenarios improve margin hit rate by 60%"
    metric: "Target margin achievement"
    variantCount: 3
variants:
  - name: "Factory-focused OEM"
    changes: ["Simplified UI", "Quote-centric workflows", "Multi-language support"]
  - name: "Brand-focused retail"
    changes: ["Season planning tools", "Trend analysis", "Buyer dashboards"]
---

# LandedLens Business Workflows

## Customer Acquisition Workflows

```typescript
interface Lead {
  company: string;
  industry: string;
  revenue: number;
  employees: number;
  currentCostingMethod: 'spreadsheet' | 'erp' | 'manual';
  painPoints: string[];
  contact: ContactInfo;
}

interface QualifiedLead extends Lead {
  fitScore: number;
  urgency: 'high' | 'medium' | 'low';
  budget: number;
  timeline: string;
}

interface Proposal {
  leadId: string;
  solution: SolutionPackage;
  pricing: PricingProposal;
  roi: ROIProjection;
  implementation: ImplementationPlan;
}

export async function acquireCustomer(lead: Lead): Promise<Customer> {
  const qualifiedLead = await qualifyLead(lead);
  const proposal = await generateProposal(qualifiedLead);
  const contract = await negotiateContract(proposal);
  return await onboardCustomer(contract);
}

export async function qualifyLead(lead: Lead): Promise<QualifiedLead> {
  const industryFit = await assessIndustryFit(lead.industry);
  const sizeFit = await assessCompanySize(lead.revenue, lead.employees);
  const painPointMatch = await analyzePainPoints(lead.painPoints);
  const urgency = await determineUrgency(lead);
  
  const fitScore = calculateFitScore(industryFit, sizeFit, painPointMatch);
  
  if (fitScore < 0.6) {
    throw new Error('Lead does not meet qualification criteria');
  }
  
  return {
    ...lead,
    fitScore,
    urgency,
    budget: await estimateBudget(lead),
    timeline: await estimateTimeline(urgency)
  };
}

export async function generateProposal(lead: QualifiedLead): Promise<Proposal> {
  const solution = await designSolution(lead);
  const pricing = await calculatePricing(solution, lead);
  const roi = await projectROI(lead, solution);
  const implementation = await planImplementation(lead, solution);
  
  return {
    leadId: lead.contact.id,
    solution,
    pricing,
    roi,
    implementation
  };
}
```

## Product Development Workflows

```typescript
interface BOMItem {
  id: string;
  description: string;
  material: string;
  quantity: number;
  unitCost: number;
  supplier: Supplier;
  countryOfOrigin: string;
  hsCode?: string;
}

interface CostCalculation {
  bomId: string;
  fobCost: number;
  landedCost: number;
  breakdown: CostBreakdown;
  accuracy: number;
  lastUpdated: Date;
}

interface Scenario {
  id: string;
  name: string;
  parameters: ScenarioParameters;
  results: CostCalculation;
  marginImpact: number;
}

export async function processBOM(bomData: BOMItem[]): Promise<CostCalculation> {
  const enrichedBOM = await enrichBOMWithAI(bomData);
  const classifiedBOM = await classifyHSCodes(enrichedBOM);
  const validatedBOM = await validateWithSuppliers(classifiedBOM);
  return await calculateLandedCost(validatedBOM);
}

export async function enrichBOMWithAI(bomItems: BOMItem[]): Promise<BOMItem[]> {
  return await Promise.all(bomItems.map(async (item) => {
    const enrichedDescription = await enhanceDescription(item);
    const suggestedHSCode = await suggestHSCode(item);
    const materialClassification = await classifyMaterial(item);
    
    return {
      ...item,
      description: enrichedDescription,
      hsCode: suggestedHSCode,
      material: materialClassification
    };
  }));
}

export async function runScenarioAnalysis(
  baseBOM: BOMItem[],
  scenarios: ScenarioParameters[]
): Promise<Scenario[]> {
  return await Promise.all(scenarios.map(async (params) => {
    const modifiedBOM = await applyScenarioParameters(baseBOM, params);
    const results = await calculateLandedCost(modifiedBOM);
    const marginImpact = await calculateMarginImpact(results, params.targetMargin);
    
    return {
      id: generateScenarioId(),
      name: params.name,
      parameters: params,
      results,
      marginImpact
    };
  }));
}
```

## Revenue Generation Workflows

```typescript
interface Subscription {
  customerId: string;
  plan: 'starter' | 'pro' | 'enterprise';
  seats: number;
  monthlyRevenue: number;
  usage: UsageMetrics;
  renewalDate: Date;
}

interface UsageMetrics {
  simulationsRun: number;
  integrations: number;
  supplierPortalUsers: number;
  dataVolume: number;
}

interface RevenueOpportunity {
  type: 'upsell' | 'expansion' | 'renewal';
  customerId: string;
  potentialRevenue: number;
  probability: number;
  timeline: string;
}

export async function generateRevenue(customer: Customer): Promise<RevenueStream[]> {
  const subscription = await manageSubscription(customer);
  const usage = await trackUsage(customer);
  const opportunities = await identifyOpportunities(customer, usage);
  return await executeRevenueActions(opportunities);
}

export async function manageSubscription(customer: Customer): Promise<Subscription> {
  const currentPlan = await getCurrentPlan(customer);
  const usage = await getUsageMetrics(customer);
  
  if (await shouldUpgrade(usage, currentPlan)) {
    return await proposeUpgrade(customer, usage);
  }
  
  if (await isRenewalDue(currentPlan)) {
    return await processRenewal(customer, currentPlan);
  }
  
  return currentPlan;
}

export async function identifyOpportunities(
  customer: Customer,
  usage: UsageMetrics
): Promise<RevenueOpportunity[]> {
  const opportunities: RevenueOpportunity[] = [];
  
  if (usage.simulationsRun > customer.plan.limits.simulations * 0.8) {
    opportunities.push(await createUpsellOpportunity(customer, 'usage'));
  }
  
  if (usage.supplierPortalUsers > 0 && !customer.plan.includes.supplierPortal) {
    opportunities.push(await createUpsellOpportunity(customer, 'supplier-portal'));
  }
  
  const expansionPotential = await assessExpansionPotential(customer);
  if (expansionPotential.score > 0.7) {
    opportunities.push(await createExpansionOpportunity(customer, expansionPotential));
  }
  
  return opportunities;
}
```

## Operational Workflows

```typescript
interface Supplier {
  id: string;
  name: string;
  country: string;
  capabilities: string[];
  certifications: string[];
  status: 'active' | 'pending' | 'suspended';
  performanceScore: number;
}

interface ComplianceCheck {
  type: 'hsCode' | 'tariff' | 'origin' | 'certification';
  status: 'passed' | 'failed' | 'warning';
  details: string;
  actionRequired?: string;
}

interface QualityMetric {
  accuracy: number;
  timeliness: number;
  completeness: number;
  compliance: number;
}

export async function operateSupplierNetwork(suppliers: Supplier[]): Promise<SupplierNetwork> {
  const onboarded = await onboardNewSuppliers(suppliers);
  const validated = await validateSupplierData(onboarded);
  const monitored = await monitorPerformance(validated);
  return await optimizeNetwork(monitored);
}

export async function onboardSupplier(supplier: Supplier): Promise<Supplier> {
  const verified = await verifySupplierCredentials(supplier);
  const assessed = await assessCapabilities(verified);
  const integrated = await integrateSupplierSystems(assessed);
  const trained = await trainSupplierOnPlatform(integrated);
  
  return {
    ...trained,
    status: 'active',
    onboardingDate: new Date()
  };
}

export async function ensureCompliance(
  bomItems: BOMItem[],
  regulations: ComplianceRule[]
): Promise<ComplianceCheck[]> {
  return await Promise.all(regulations.map(async (rule) => {
    const applicable = bomItems.filter(item => rule.applies(item));
    const results = await Promise.all(applicable.map(item => rule.check(item)));
    
    return {
      type: rule.type,
      status: results.every(r => r.passed) ? 'passed' : 'failed',
      details: rule.generateReport(results),
      actionRequired: rule.getRequiredActions(results)
    };
  }));
}

export async function monitorQuality(): Promise<QualityMetric> {
  const accuracy = await measureAccuracy();
  const timeliness = await measureTimeliness();
  const completeness = await measureCompleteness();
  const compliance = await measureCompliance();
  
  const overall = (accuracy + timeliness + completeness + compliance) / 4;
  
  if (overall < 0.85) {
    await triggerQualityImprovement();
  }
  
  return { accuracy, timeliness, completeness, compliance };
}
```

## Decision-Making Workflows

```typescript
interface Decision {
  id: string;
  type: 'supplier' | 'routing' | 'pricing' | 'compliance';
  context: DecisionContext;
  options: DecisionOption[];
  recommendation: DecisionOption;
  confidence: number;
  reasoning: string[];
}

interface DecisionContext {
  bomId: string;
  targetMargin: number;
  constraints: Constraint[];
  priorities: Priority[];
  riskTolerance: number;
}

interface DecisionOption {
  id: string;
  description: string;
  impact: Impact;
  risk: Risk;
  cost: number;
  timeline: string;
}

export async function makeOptimalDecision(context: DecisionContext): Promise<Decision> {
  const options = await generateOptions(context);
  const analyzed = await analyzeOptions(options, context);
  const ranked = await rankOptions(analyzed, context);
  const recommendation = await selectRecommendation(ranked, context);
  
  return {
    id: generateDecisionId(),
    type: inferDecisionType(context),
    context,
    options: analyzed,
    recommendation,
    confidence: recommendation.confidence,
    reasoning: recommendation.reasoning
  };
}

export async function optimizeMargin(
  currentCost: CostCalculation,
  targetMargin: number
): Promise<OptimizationPlan> {
  const gap = calculateMarginGap(currentCost, targetMargin);
  
  if (gap <= 0) {
    return { status: 'target-achieved', actions: [] };
  }
  
  const actions = await generateOptimizationActions(currentCost, gap);
  const prioritized = await prioritizeActions(actions);
  const plan = await createExecutionPlan(prioritized);
  
  return plan;
}

export async function handleVariance(
  estimated: CostCalculation,
  actual: CostCalculation
): Promise<VarianceResponse> {
  const variance = calculateVariance(estimated, actual);
  
  if (Math.abs(variance.percentage) < 2) {
    return { action: 'monitor', adjustments: [] };
  }
  
  const rootCause = await analyzeVarianceRootCause(variance);
  const adjustments = await generateAdjustments(rootCause);
  const prevention = await createPreventionPlan(rootCause);
  
  await updateLearningModel(variance, rootCause);
  
  return {
    action: 'adjust',
    adjustments,
    prevention,
    rootCause
  };
}

export async function assessRisk(
  scenario: Scenario,
  riskFactors: RiskFactor[]
): Promise<RiskAssessment> {
  const risks = await Promise.all(riskFactors.map(async (factor) => {
    const probability = await calculateProbability(factor, scenario);
    const impact = await calculateImpact(factor, scenario);
    const mitigation = await suggestMitigation(factor);
    
    return {
      factor,
      probability,
      impact,
      severity: probability * impact,
      mitigation
    };
  }));
  
  const overallRisk = calculateOverallRisk(risks);
  const recommendations = await generateRiskRecommendations(risks);
  
  return {
    overallRisk,
    risks,
    recommendations,
    acceptableRisk: overallRisk < 0.3
  };
}
```

## Integration & Data Workflows

```typescript
interface Integration {
  system: 'PLM' | 'ERP' | 'Freight' | 'Bank';
  provider: string;
  status: 'connected' | 'error' | 'syncing';
  lastSync: Date;
  dataTypes: string[];
}

interface DataPipeline {
  source: string;
  destination: string;
  transformation: TransformationRule[];
  schedule: string;
  status: 'running' | 'stopped' | 'error';
}

export async function synchronizeData(integrations: Integration[]): Promise<SyncResult[]> {
  return await Promise.all(integrations.map(async (integration) => {
    try {
      const data = await extractData(integration);
      const transformed = await transformData(data, integration);
      const loaded = await loadData(transformed);
      
      await updateIntegrationStatus(integration.system, 'connected');
      
      return {
        system: integration.system,
        status: 'success',
        recordsProcessed: loaded.count,
        lastSync: new Date()
      };
    } catch (error) {
      await updateIntegrationStatus(integration.system, 'error');
      await notifyIntegrationError(integration, error);
      
      return {
        system: integration.system,
        status: 'error',
        error: error.message,
        lastSync: integration.lastSync
      };
    }
  }));
}

export async function maintainDataQuality(): Promise<DataQualityReport> {
  const completeness = await checkDataCompleteness();
  const accuracy = await validateDataAccuracy();
  const consistency = await checkDataConsistency();
  const timeliness = await assessDataTimeliness();
  
  const issues = await identifyDataIssues();
  const recommendations = await generateDataRecommendations(issues);
  
  if (issues.length > 0) {
    await scheduleDataCleanup(issues);
  }
  
  return {
    completeness,
    accuracy,
    consistency,
    timeliness,
    issues,
    recommendations,
    overallScore: (completeness + accuracy + consistency + timeliness) / 4
  };
}
```

These TypeScript functions represent the core business processes for LandedLens, encoding the workflows for customer acquisition, product development, revenue generation, operations, and decision-making as executable code. Each function is strongly typed and includes error handling, async/await patterns, and integration points with other business systems.
